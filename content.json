{"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-08-28T14:12:53.152Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"/404.html","permalink":"https://buzhibujue.cf//404.html","excerpt":"","text":""},{"title":"书单","date":"2020-08-28T14:12:53.162Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"books/index.html","permalink":"https://buzhibujue.cf/books/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-15T11:38:36.000Z","updated":"2020-08-28T14:21:13.712Z","comments":false,"path":"about/index.html","permalink":"https://buzhibujue.cf/about/index.html","excerpt":"","text":"你好=.= 我是来自CDQZ的一名蒟蒻LB 请多多指教 退役了QAQ如果文章有密码就是 buzhibujue"},{"title":"分类","date":"2020-08-28T14:12:53.165Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"categories/index.html","permalink":"https://buzhibujue.cf/categories/index.html","excerpt":"","text":""},{"title":"fun","date":"2019-03-04T14:24:31.000Z","updated":"2019-03-04T15:12:50.000Z","comments":true,"path":"fun/index.html","permalink":"https://buzhibujue.cf/fun/index.html","excerpt":"","text":"Timmy bird Orz Jerome_wei"},{"title":"","date":"2020-08-28T14:12:53.171Z","updated":"2019-03-04T15:17:52.000Z","comments":true,"path":"fun/mobai.html","permalink":"https://buzhibujue.cf/fun/mobai.html","excerpt":"","text":"膜拜 Jerome_Wei * { color: #191970; transition: all 0.3s ease; text-shadow: 0 0 20px #e1ffff; } body{ background-color: #87ceeb; text-align: center; } header{ margin: 2cm 0; } Jerome_Wei 知名Oier&Life winner 膜拜次数越多越有机会获得神秘惊喜. He has AKed IOI 0 times. 他已经被您膜拜了 0 次。 点击膜拜 var counter = 0; document.getElementById(\"mobai\").onclick = function() { ++counter; for(let item of document.getElementsByClassName(\"counter\")) { item.innerText = counter; } if(counter==5)alert(\"你们啊Naive\"); if(counter==10){ alert(\"我精通斯特林\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kOthm4.jpg\"; } if(counter==25){ alert(\"恭喜Jerome_wei\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kONP9P.png\"; } if(counter==55){ alert(\"快爆零了\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kONcEd.png\"; } if(counter==115){ alert(\"很显然吧...\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kONhgf.png\"; } if(counter==235){ alert(\"sb题\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kONIKS.png\"; } if(counter==475){ alert(\"他改变了OI！！！\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kOUpb4.jpg\"; } if(counter==955){ alert(\"看不懂题解\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kOUBin.png\"; } if(counter==1915){ alert(\"我要FST了\"); document.getElementById(\"image\").src=\"https://s2.ax1x.com/2019/03/04/kOUOdH.png\"; } } 想了解 Jerome_wei？请前往 jerome_wei的博客"},{"title":"Repositories","date":"2020-08-28T14:12:53.197Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"repository/index.html","permalink":"https://buzhibujue.cf/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-28T14:12:53.194Z","updated":"2019-03-03T10:37:00.000Z","comments":true,"path":"links/index.html","permalink":"https://buzhibujue.cf/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-28T14:12:53.202Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"tags/index.html","permalink":"https://buzhibujue.cf/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2019-03-03T14:35:55.000Z","updated":"2019-03-03T15:10:24.000Z","comments":true,"path":"tools/index.html","permalink":"https://buzhibujue.cf/tools/index.html","excerpt":"","text":"Rand Rand Graph Editer Paint"},{"title":"","date":"2020-08-28T14:12:53.206Z","updated":"2019-03-03T15:12:28.000Z","comments":true,"path":"tools/paint.html","permalink":"https://buzhibujue.cf/tools/paint.html","excerpt":"","text":"mcfx's Paint Board Line width:DecreaseIncrease Color:BlackWhiteRed UndoRedoClearSave Back var lstX=-1,lstY=-1,frames=Array(),frameNow=0,frameCnt=0; function clear(log){ if(typeof(log)==\"undefined\"){ log=1; } board.save(); board_dom.width=board_dom.width; board.restore(); if(log){ frames.push({type:'clearAll'}); frameCnt++; } } function drawAt(X,Y,color,width){ color=color||document.getElementById(\"cl\").value; width=width||drawWidth; board.fillStyle=color; board.strokeStyle=color; board.lineWidth=width; board.beginPath(); board.arc(X,Y,width*0.5,0,360,false); board.fill(); board.closePath(); if(lstX!=-1){ board.beginPath(); board.moveTo(lstX,lstY); board.lineTo(X,Y); board.stroke(); board.closePath(); } lstX=X,lstY=Y; } function drawEnd(){ lstX=-1,lstY=-1; } function clickAt(X,Y){ if(!frameNow)frameNow=Array(); frameNow.push([X,Y]); drawAt(X,Y); } function clickEnd(){ drawEnd(); if(frameNow) { lstX=-1,lstY=-1; while(frames.length>frameCnt)frames.pop(); frames.push({type:'brush',color:document.getElementById(\"cl\").value,width:drawWidth,frame:frameNow}); frameNow=0; frameCnt++; } } function doFrame(x){ if(x.type=='brush'){ for(var j=0;j0){ frameCnt--; clear(0); for(var i=0;i"},{"title":"","date":"2020-08-28T14:12:53.208Z","updated":"2019-03-03T15:59:42.000Z","comments":true,"path":"tools/rand.html","permalink":"https://buzhibujue.cf/tools/rand.html","excerpt":"","text":"Rand function RND(){ var a = document.getElementById(\"a\"); var b = document.getElementById(\"b\"); var mx = parseInt(a.value); var mn = parseInt(b.value); if(mx"},{"title":"","date":"2020-08-28T14:12:53.185Z","updated":"2019-03-04T14:19:10.000Z","comments":true,"path":"fun/Timmy bird/main.js","permalink":"https://buzhibujue.cf/fun/Timmy bird/main.js","excerpt":"","text":"// Initialize Phaser, and creates a 400x490px game var game = new Phaser.Game(800, 480, Phaser.AUTO, 'game_div'); // Creates a new 'main' state that will contain the game var main_state = { // Function called first to load all the assets preload: function() { // Change the background color of the game this.game.stage.backgroundColor = '#FFFFFF'; // Load the bird sprite this.game.load.image('bird', 'assets/bird.png'); // Load the pipe sprite this.game.load.image('pipe','assets/pipe.png'); }, // Fuction called after 'preload' to setup the game create: function() { // Display the bird on the screen this.bird = this.game.add.sprite(100, 245, 'bird'); // Add gravity to the bird to make it fall this.bird.body.gravity.y = 50; // Call the 'jump' function when the spacekey is hit var space_key = this.game.input.keyboard.addKey(Phaser.Keyboard.K); space_key.onDown.add(this.jump, this); var space_key2 = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR); space_key2.onDown.add(this.jump2, this); // Create a group of 20 pipes this.pipes = game.add.group(); this.pipes.createMultiple(20, 'pipe'); // Timer that calls 'add_row_of_pipes' ever 1.5 seconds this.timer = this.game.time.events.loop(1500, this.add_row_of_pipes, this); // Add a score label on the top left of the screen this.score = 0; var style = { font: \"30px Arial\", fill: \"#000000\" }; this.label_score = this.game.add.text(20, 20, \"0\", style); }, // This function is called 60 times per second update: function() { // If the bird is out of the world (too high or too low), call the 'restart_game' function if (this.bird.inWorld == false) this.restart_game(); // If the bird overlap any pipes, call 'restart_game' this.game.physics.overlap(this.bird, this.pipes, this.restart_game, null, this); }, // Make the bird jump jump: function() { this.game.load.image('bird', 'assets/bird.png'); this.bird.body.velocity.y = -250; }, jump2: function() { this.game.load.image('bird', 'assets/bird.png'); this.bird.body.velocity.y = +200; }, // Restart the game restart_game: function() { // Remove the timer this.game.time.events.remove(this.timer); // Start the 'main' state, which restarts the game this.game.state.start('main'); }, // Add a pipe on the screen add_one_pipe: function(x, y) { // Get the first dead pipe of our group var pipe = this.pipes.getFirstDead(); // Set the new position of the pipe pipe.reset(x, y); // Add velocity to the pipe to make it move left pipe.body.velocity.x = -200; // Kill the pipe when it's no longer visible pipe.outOfBoundsKill = true; }, // Add a row of 6 pipes with a hole somewhere in the middle add_row_of_pipes: function() { var hole = Math.floor(Math.random()*5)+1; for (var i = 0; i < 8; i++) if (i != hole && i != hole +1) this.add_one_pipe(800, i*60); this.score++; this.label_score.content = this.score ; }, }; // Add and start the 'main' state to start the game game.state.add('main', main_state); game.state.start('main');"},{"title":"","date":"2020-08-28T14:12:53.183Z","updated":"2019-03-04T15:07:46.000Z","comments":true,"path":"fun/Timmy bird/index.html","permalink":"https://buzhibujue.cf/fun/Timmy bird/index.html","excerpt":"","text":"alert(\"Press K to go up\"); alert(\"Press to go down\"); 黑白高配版 #game_div, p { width: 1000px; margin: auto; margin-top: 20px; } /*! Phaser v1.1.5 | (c) 2013 Photon Storm Ltd. */ !function(a,b){\"function\"==typeof define&&define.amd?define(b):\"object\"==typeof exports?module.exports=b():a.Phaser=b()}(this,function(){function a(){return b.Matrix=\"undefined\"!=typeof Float32Array?Float32Array:Array,b.Matrix}var b=b||{},c=c||{VERSION:\"1.1.5\",DEV_VERSION:\"1.1.5\",GAMES:[],AUTO:0,CANVAS:1,WEBGL:2,HEADLESS:3,SPRITE:0,BUTTON:1,BULLET:2,GRAPHICS:3,TEXT:4,TILESPRITE:5,BITMAPTEXT:6,GROUP:7,RENDERTEXTURE:8,TILEMAP:9,TILEMAPLAYER:10,EMITTER:11,POLYGON:12,BITMAPDATA:13,CANVAS_FILTER:14,WEBGL_FILTER:15,NONE:0,LEFT:1,RIGHT:2,UP:3,DOWN:4,CANVAS_PX_ROUND:!1,CANVAS_CLEAR_RECT:!0};b.InteractionManager=function(){},c.Utils={shuffle:function(a){for(var b=a.length-1;b>0;b--){var c=Math.floor(Math.random()*(b+1)),d=a[b];a[b]=a[c],a[c]=d}return a},pad:function(a,b,c,d){if(\"undefined\"==typeof b)var b=0;if(\"undefined\"==typeof c)var c=\" \";if(\"undefined\"==typeof d)var d=3;var e=0;if(b+1>=a.length)switch(d){case 1:a=Array(b+1-a.length).join(c)+a;break;case 3:var f=Math.ceil((e=b-a.length)/2),g=e-f;a=Array(g+1).join(c)+a+Array(f+1).join(c);break;default:a+=Array(b+1-a.length).join(c)}return a},isPlainObject:function(a){if(\"object\"!=typeof a||a.nodeType||a===a.window)return!1;try{if(a.constructor&&!hasOwn.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(b){return!1}return!0},extend:function(){var a,b,d,e,f,g,h=arguments[0]||{},i=1,j=arguments.length,k=!1;for(\"boolean\"==typeof h&&(k=h,h=arguments[1]||{},i=2),j===i&&(h=this,--i);j>i;i++)if(null!=(a=arguments[i]))for(b in a)d=h[b],e=a[b],h!==e&&(k&&e&&(c.Utils.isPlainObject(e)||(f=Array.isArray(e)))?(f?(f=!1,g=d&&Array.isArray(d)?d:[]):g=d&&c.Utils.isPlainObject(d)?d:{},h[b]=c.Utils.extend(k,g,e)):void 0!==e&&(h[b]=e));return h}},b.hex2rgb=function(a){return[(255&a>>16)/255,(255&a>>8)/255,(255&a)/255]},\"function\"!=typeof Function.prototype.bind&&(Function.prototype.bind=function(){var a=Array.prototype.slice;return function(b){function c(){var f=e.concat(a.call(arguments));d.apply(this instanceof c?this:b,f)}var d=this,e=a.call(arguments,1);if(\"function\"!=typeof d)throw new TypeError;return c.prototype=function f(a){return a&&(f.prototype=a),this instanceof f?void 0:new f}(d.prototype),c}}()),Array.isArray||(Array.isArray=function(a){return\"[object Array]\"==Object.prototype.toString.call(a)}),a(),b.mat3={},b.mat3.create=function(){var a=new b.Matrix(9);return a[0]=1,a[1]=0,a[2]=0,a[3]=0,a[4]=1,a[5]=0,a[6]=0,a[7]=0,a[8]=1,a},b.mat3.identity=function(a){return a[0]=1,a[1]=0,a[2]=0,a[3]=0,a[4]=1,a[5]=0,a[6]=0,a[7]=0,a[8]=1,a},b.mat4={},b.mat4.create=function(){var a=new b.Matrix(16);return a[0]=1,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=1,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,a},b.mat3.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],f=a[2],g=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],m=b[0],n=b[1],o=b[2],p=b[3],q=b[4],r=b[5],s=b[6],t=b[7],u=b[8];return c[0]=m*d+n*g+o*j,c[1]=m*e+n*h+o*k,c[2]=m*f+n*i+o*l,c[3]=p*d+q*g+r*j,c[4]=p*e+q*h+r*k,c[5]=p*f+q*i+r*l,c[6]=s*d+t*g+u*j,c[7]=s*e+t*h+u*k,c[8]=s*f+t*i+u*l,c},b.mat3.clone=function(a){var c=new b.Matrix(9);return c[0]=a[0],c[1]=a[1],c[2]=a[2],c[3]=a[3],c[4]=a[4],c[5]=a[5],c[6]=a[6],c[7]=a[7],c[8]=a[8],c},b.mat3.transpose=function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[5];return a[1]=a[3],a[2]=a[6],a[3]=c,a[5]=a[7],a[6]=d,a[7]=e,a}return b[0]=a[0],b[1]=a[3],b[2]=a[6],b[3]=a[1],b[4]=a[4],b[5]=a[7],b[6]=a[2],b[7]=a[5],b[8]=a[8],b},b.mat3.toMat4=function(a,c){return c||(c=b.mat4.create()),c[15]=1,c[14]=0,c[13]=0,c[12]=0,c[11]=0,c[10]=a[8],c[9]=a[7],c[8]=a[6],c[7]=0,c[6]=a[5],c[5]=a[4],c[4]=a[3],c[3]=0,c[2]=a[2],c[1]=a[1],c[0]=a[0],c},b.mat4.create=function(){var a=new b.Matrix(16);return a[0]=1,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=1,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,a},b.mat4.transpose=function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[3],f=a[6],g=a[7],h=a[11];return a[1]=a[4],a[2]=a[8],a[3]=a[12],a[4]=c,a[6]=a[9],a[7]=a[13],a[8]=d,a[9]=f,a[11]=a[14],a[12]=e,a[13]=g,a[14]=h,a}return b[0]=a[0],b[1]=a[4],b[2]=a[8],b[3]=a[12],b[4]=a[1],b[5]=a[5],b[6]=a[9],b[7]=a[13],b[8]=a[2],b[9]=a[6],b[10]=a[10],b[11]=a[14],b[12]=a[3],b[13]=a[7],b[14]=a[11],b[15]=a[15],b},b.mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],f=a[2],g=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],m=a[9],n=a[10],o=a[11],p=a[12],q=a[13],r=a[14],s=a[15],t=b[0],u=b[1],v=b[2],w=b[3];return c[0]=t*d+u*h+v*l+w*p,c[1]=t*e+u*i+v*m+w*q,c[2]=t*f+u*j+v*n+w*r,c[3]=t*g+u*k+v*o+w*s,t=b[4],u=b[5],v=b[6],w=b[7],c[4]=t*d+u*h+v*l+w*p,c[5]=t*e+u*i+v*m+w*q,c[6]=t*f+u*j+v*n+w*r,c[7]=t*g+u*k+v*o+w*s,t=b[8],u=b[9],v=b[10],w=b[11],c[8]=t*d+u*h+v*l+w*p,c[9]=t*e+u*i+v*m+w*q,c[10]=t*f+u*j+v*n+w*r,c[11]=t*g+u*k+v*o+w*s,t=b[12],u=b[13],v=b[14],w=b[15],c[12]=t*d+u*h+v*l+w*p,c[13]=t*e+u*i+v*m+w*q,c[14]=t*f+u*j+v*n+w*r,c[15]=t*g+u*k+v*o+w*s,c},b.Point=function(a,b){this.x=a||0,this.y=b||0},b.Point.prototype.clone=function(){return new b.Point(this.x,this.y)},b.Point.prototype.constructor=b.Point,b.Rectangle=function(a,b,c,d){this.x=a||0,this.y=b||0,this.width=c||0,this.height=d||0},b.Rectangle.prototype.clone=function(){return new b.Rectangle(this.x,this.y,this.width,this.height)},b.Rectangle.prototype.contains=function(a,b){if(this.widtha;j&&(c=!c)}return c},b.Polygon.prototype.constructor=b.Polygon,b.DisplayObject=function(){this.last=this,this.first=this,this.position=new b.Point,this.scale=new b.Point(1,1),this.pivot=new b.Point(0,0),this.rotation=0,this.alpha=1,this.visible=!0,this.hitArea=null,this.buttonMode=!1,this.renderable=!1,this.parent=null,this.stage=null,this.worldAlpha=1,this._interactive=!1,this.defaultCursor=\"pointer\",this.worldTransform=b.mat3.create(),this.localTransform=b.mat3.create(),this.color=[],this.dynamic=!0,this._sr=0,this._cr=1,this.filterArea=new b.Rectangle(0,0,1,1)},b.DisplayObject.prototype.constructor=b.DisplayObject,b.DisplayObject.prototype.setInteractive=function(a){this.interactive=a},Object.defineProperty(b.DisplayObject.prototype,\"interactive\",{get:function(){return this._interactive},set:function(a){this._interactive=a,this.stage&&(this.stage.dirty=!0)}}),Object.defineProperty(b.DisplayObject.prototype,\"mask\",{get:function(){return this._mask},set:function(a){a?this._mask?(a.start=this._mask.start,a.end=this._mask.end):(this.addFilter(a),a.renderable=!1):(this.removeFilter(this._mask),this._mask.renderable=!0),this._mask=a}}),Object.defineProperty(b.DisplayObject.prototype,\"filters\",{get:function(){return this._filters},set:function(a){if(a){this._filters&&this.removeFilter(this._filters),this.addFilter(a);for(var b=[],c=0;cd)throw new Error(\"swapChildren: Both the supplied DisplayObjects must be a child of the caller.\");this.removeChild(a),this.removeChild(b),d>c?(this.addChildAt(b,c),this.addChildAt(a,d)):(this.addChildAt(a,d),this.addChildAt(b,c))}},b.DisplayObjectContainer.prototype.getChildAt=function(a){if(a>=0&&aa;a++)this.children[a].updateTransform()}},b.blendModes={},b.blendModes.NORMAL=0,b.blendModes.SCREEN=1,b.Sprite=function(a){b.DisplayObjectContainer.call(this),this.anchor=new b.Point,this.texture=a,this.blendMode=b.blendModes.NORMAL,this._width=0,this._height=0,a.baseTexture.hasLoaded?this.updateFrame=!0:(this.onTextureUpdateBind=this.onTextureUpdate.bind(this),this.texture.addEventListener(\"update\",this.onTextureUpdateBind)),this.renderable=!0},b.Sprite.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Sprite.prototype.constructor=b.Sprite,Object.defineProperty(b.Sprite.prototype,\"width\",{get:function(){return this.scale.x*this.texture.frame.width},set:function(a){this.scale.x=a/this.texture.frame.width,this._width=a}}),Object.defineProperty(b.Sprite.prototype,\"height\",{get:function(){return this.scale.y*this.texture.frame.height},set:function(a){this.scale.y=a/this.texture.frame.height,this._height=a}}),b.Sprite.prototype.setTexture=function(a){this.texture.baseTexture!==a.baseTexture?(this.textureChange=!0,this.texture=a,this.__renderGroup&&this.__renderGroup.updateTexture(this)):this.texture=a,this.updateFrame=!0},b.Sprite.prototype.onTextureUpdate=function(){this._width&&(this.scale.x=this._width/this.texture.frame.width),this._height&&(this.scale.y=this._height/this.texture.frame.height),this.updateFrame=!0},b.Sprite.fromFrame=function(a){var c=b.TextureCache[a];if(!c)throw new Error('The frameId \"'+a+'\" does not exist in the texture cache'+this);return new b.Sprite(c)},b.Sprite.fromImage=function(a){var c=b.Texture.fromImage(a);return new b.Sprite(c)},b.Stage=function(a){b.DisplayObjectContainer.call(this),this.worldTransform=b.mat3.create(),this.interactive=!0,this.interactionManager=new b.InteractionManager(this),this.dirty=!0,this.__childrenAdded=[],this.__childrenRemoved=[],this.stage=this,this.stage.hitArea=new b.Rectangle(0,0,1e5,1e5),this.setBackgroundColor(a),this.worldVisible=!0},b.Stage.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Stage.prototype.constructor=b.Stage,b.Stage.prototype.setInteractionDelegate=function(a){this.interactionManager.setTargetDomElement(a)},b.Stage.prototype.updateTransform=function(){this.worldAlpha=1,this.vcount=b.visibleCount;for(var a=0,c=this.children.length;c>a;a++)this.children[a].updateTransform();this.dirty&&(this.dirty=!1,this.interactionManager.dirty=!0),this.interactive&&this.interactionManager.update()},b.Stage.prototype.setBackgroundColor=function(a){this.backgroundColor=a||0,this.backgroundColorSplit=b.hex2rgb(this.backgroundColor);var c=this.backgroundColor.toString(16);c=\"000000\".substr(0,6-c.length)+c,this.backgroundColorString=\"#\"+c},b.Stage.prototype.getMousePosition=function(){return this.interactionManager.mouse.global},b.CustomRenderable=function(){b.DisplayObject.call(this),this.renderable=!0},b.CustomRenderable.prototype=Object.create(b.DisplayObject.prototype),b.CustomRenderable.prototype.constructor=b.CustomRenderable,b.CustomRenderable.prototype.renderCanvas=function(){},b.CustomRenderable.prototype.initWebGL=function(){},b.CustomRenderable.prototype.renderWebGL=function(){},b.Strip=function(a,c,d){b.DisplayObjectContainer.call(this),this.texture=a,this.blendMode=b.blendModes.NORMAL;try{this.uvs=new Float32Array([0,1,1,1,1,0,0,1]),this.verticies=new Float32Array([0,0,0,0,0,0,0,0,0]),this.colors=new Float32Array([1,1,1,1]),this.indices=new Uint16Array([0,1,2,3])}catch(e){this.uvs=[0,1,1,1,1,0,0,1],this.verticies=[0,0,0,0,0,0,0,0,0],this.colors=[1,1,1,1],this.indices=[0,1,2,3]}this.width=c,this.height=d,a.baseTexture.hasLoaded?(this.width=this.texture.frame.width,this.height=this.texture.frame.height,this.updateFrame=!0):(this.onTextureUpdateBind=this.onTextureUpdate.bind(this),this.texture.addEventListener(\"update\",this.onTextureUpdateBind)),this.renderable=!0},b.Strip.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Strip.prototype.constructor=b.Strip,b.Strip.prototype.setTexture=function(a){this.texture=a,this.width=a.frame.width,this.height=a.frame.height,this.updateFrame=!0},b.Strip.prototype.onTextureUpdate=function(){this.updateFrame=!0},b.Rope=function(a,c){b.Strip.call(this,a),this.points=c;try{this.verticies=new Float32Array(4*c.length),this.uvs=new Float32Array(4*c.length),this.colors=new Float32Array(2*c.length),this.indices=new Uint16Array(2*c.length)}catch(d){this.verticies=new Array(4*c.length),this.uvs=new Array(4*c.length),this.colors=new Array(2*c.length),this.indices=new Array(2*c.length)}this.refresh()},b.Rope.prototype=Object.create(b.Strip.prototype),b.Rope.prototype.constructor=b.Rope,b.Rope.prototype.refresh=function(){var a=this.points;if(!(a.lengthj;j++)f=a[j],g=4*j,h=j/(i-1),j%2?(b[g]=h,b[g+1]=0,b[g+2]=h,b[g+3]=1):(b[g]=h,b[g+1]=0,b[g+2]=h,b[g+3]=1),g=2*j,e[g]=1,e[g+1]=1,g=2*j,d[g]=g,d[g+1]=g+1,c=f}},b.Rope.prototype.updateTransform=function(){var a=this.points;if(!(a.lengthm;m++)g=a[m],h=4*m,c=m1&&(i=1),j=Math.sqrt(e.x*e.x+e.y*e.y),k=this.texture.height/2,e.x/=j,e.y/=j,e.x*=k,e.y*=k,f[h]=g.x+e.x,f[h+1]=g.y+e.y,f[h+2]=g.x-e.x,f[h+3]=g.y-e.y,d=g;b.DisplayObjectContainer.prototype.updateTransform.call(this)}},b.Rope.prototype.setTexture=function(a){this.texture=a,this.updateFrame=!0},b.TilingSprite=function(a,c,d){b.DisplayObjectContainer.call(this),this.texture=a,this.width=c,this.height=d,this.tileScale=new b.Point(1,1),this.tilePosition=new b.Point(0,0),this.renderable=!0,this.blendMode=b.blendModes.NORMAL},b.TilingSprite.prototype=Object.create(b.DisplayObjectContainer.prototype),b.TilingSprite.prototype.constructor=b.TilingSprite,b.TilingSprite.prototype.setTexture=function(a){this.texture=a,this.updateFrame=!0},b.TilingSprite.prototype.onTextureUpdate=function(){this.updateFrame=!0},b.AbstractFilter=function(a,b){this.passes=[this],this.dirty=!0,this.padding=0,this.uniforms=b||{},this.fragmentSrc=a||[]},b.FilterBlock=function(){this.visible=!0,this.renderable=!0},b.Graphics=function(){b.DisplayObjectContainer.call(this),this.renderable=!0,this.fillAlpha=1,this.lineWidth=0,this.lineColor=\"black\",this.graphicsData=[],this.currentPath={points:[]}},b.Graphics.prototype=Object.create(b.DisplayObjectContainer.prototype),b.Graphics.prototype.constructor=b.Graphics,b.Graphics.prototype.lineStyle=function(a,c,d){this.currentPath.points.length||this.graphicsData.pop(),this.lineWidth=a||0,this.lineColor=c||0,this.lineAlpha=arguments.lengthd?c:g,h=d+n>h?d+n:h}else if(k===b.Graphics.CIRC||k===b.Graphics.ELIP){c=a.x,d=a.y;var o=a.radius+l/2;e=e>c-o?c-o:e,f=c+o>f?c+o:f,g=g>d-o?d-o:g,h=d+o>h?d+o:h}else for(var p=0;pc-l?c-l:e,f=c+l>f?c+l:f,g=g>d-l?d-l:g,h=d+l>h?d+l:h}this.bounds=new b.Rectangle(e,g,f-e,h-g)}},b.Graphics.POLY=0,b.Graphics.RECT=1,b.Graphics.CIRC=2,b.Graphics.ELIP=3,b.CanvasGraphics=function(){},b.CanvasGraphics.renderGraphics=function(a,c){for(var d=a.worldAlpha,e=\"\",f=0;fe;e++){var f=a.graphicsData[e],g=f.points;if(f.type===b.Graphics.POLY){c.beginPath(),c.moveTo(g[0],g[1]);for(var h=1;h0&&(b.Texture.frameUpdates=[])},b.CanvasRenderer.prototype.resize=function(a,b){this.width=a,this.height=b,this.view.width=a,this.view.height=b},b.CanvasRenderer.prototype.renderDisplayObject=function(a){var c,d=this.context;d.globalCompositeOperation=\"source-over\";var e=a.last._iNext;a=a.first;do if(c=a.worldTransform,a.visible)if(a.renderable){if(a instanceof b.Sprite){var f=a.texture.frame;f&&f.width&&f.height&&a.texture.baseTexture.source&&(d.globalAlpha=a.worldAlpha,d.setTransform(c[0],c[3],c[1],c[4],c[2],c[5]),this.smoothProperty&&this.scaleMode!==a.texture.baseTexture.scaleMode&&(this.scaleMode=a.texture.baseTexture.scaleMode,d[this.smoothProperty]=this.scaleMode===b.BaseTexture.SCALE_MODE.LINEAR),d.drawImage(a.texture.baseTexture.source,f.x,f.y,f.width,f.height,a.anchor.x*-f.width,a.anchor.y*-f.height,f.width,f.height))}else if(a instanceof b.Strip)d.setTransform(c[0],c[3],c[1],c[4],c[2],c[5]),this.renderStrip(a);else if(a instanceof b.TilingSprite)d.setTransform(c[0],c[3],c[1],c[4],c[2],c[5]),this.renderTilingSprite(a);else if(a instanceof b.CustomRenderable)d.setTransform(c[0],c[3],c[1],c[4],c[2],c[5]),a.renderCanvas(this);else if(a instanceof b.Graphics)d.setTransform(c[0],c[3],c[1],c[4],c[2],c[5]),b.CanvasGraphics.renderGraphics(a,d);else if(a instanceof b.FilterBlock&&a.data instanceof b.Graphics){var g=a.data;if(a.open){d.save();var h=g.alpha,i=g.worldTransform;d.setTransform(i[0],i[3],i[1],i[4],i[2],i[5]),g.worldAlpha=.5,d.worldAlpha=0,b.CanvasGraphics.renderGraphicsMask(g,d),d.clip(),g.worldAlpha=h}else d.restore()}a=a._iNext}else a=a._iNext;else a=a.last._iNext;while(a!==e)},b.CanvasRenderer.prototype.renderStripFlat=function(a){var b=this.context,c=a.verticies,d=c.length/2;this.count++,b.beginPath();for(var e=1;d-2>e;e++){var f=2*e,g=c[f],h=c[f+2],i=c[f+4],j=c[f+1],k=c[f+3],l=c[f+5];b.moveTo(g,j),b.lineTo(h,k),b.lineTo(i,l)}b.fillStyle=\"#FF0000\",b.fill(),b.closePath()},b.CanvasRenderer.prototype.renderTilingSprite=function(a){var b=this.context;b.globalAlpha=a.worldAlpha,a.__tilePattern||(a.__tilePattern=b.createPattern(a.texture.baseTexture.source,\"repeat\")),b.beginPath();var c=a.tilePosition,d=a.tileScale;b.scale(d.x,d.y),b.translate(c.x,c.y),b.fillStyle=a.__tilePattern,b.fillRect(-c.x,-c.y,a.width/d.x,a.height/d.y),b.scale(1/d.x,1/d.y),b.translate(-c.x,-c.y),b.closePath()},b.CanvasRenderer.prototype.renderStrip=function(a){var b=this.context,c=a.verticies,d=a.uvs,e=c.length/2;this.count++;for(var f=1;e-2>f;f++){var g=2*f,h=c[g],i=c[g+2],j=c[g+4],k=c[g+1],l=c[g+3],m=c[g+5],n=d[g]*a.texture.width,o=d[g+2]*a.texture.width,p=d[g+4]*a.texture.width,q=d[g+1]*a.texture.height,r=d[g+3]*a.texture.height,s=d[g+5]*a.texture.height;b.save(),b.beginPath(),b.moveTo(h,k),b.lineTo(i,l),b.lineTo(j,m),b.closePath(),b.clip();var t=n*r+q*p+o*s-r*p-q*o-n*s,u=h*r+q*j+i*s-r*j-q*i-h*s,v=n*i+h*p+o*j-i*p-h*o-n*j,w=n*r*j+q*i*p+h*o*s-h*r*p-q*o*j-n*i*s,x=k*r+q*m+l*s-r*m-q*l-k*s,y=n*l+k*p+o*m-l*p-k*o-n*m,z=n*r*m+q*l*p+k*o*s-k*r*p-q*o*m-n*l*s;b.transform(u/t,x/t,v/t,y/t,w/t,z/t),b.drawImage(a.texture.baseTexture.source,0,0),b.restore()}},b.PixiShader=function(){this.program=null,this.fragmentSrc=[\"precision lowp float;\",\"varying vec2 vTextureCoord;\",\"varying float vColor;\",\"uniform sampler2D uSampler;\",\"void main(void) {\",\" gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;\",\"}\"],this.textureCount=0},b.PixiShader.prototype.init=function(){var a=b.compileProgram(this.vertexSrc||b.PixiShader.defaultVertexSrc,this.fragmentSrc),c=b.gl;c.useProgram(a),this.uSampler=c.getUniformLocation(a,\"uSampler\"),this.projectionVector=c.getUniformLocation(a,\"projectionVector\"),this.offsetVector=c.getUniformLocation(a,\"offsetVector\"),this.dimensions=c.getUniformLocation(a,\"dimensions\"),this.aVertexPosition=c.getAttribLocation(a,\"aVertexPosition\"),this.colorAttribute=c.getAttribLocation(a,\"aColor\"),this.aTextureCoord=c.getAttribLocation(a,\"aTextureCoord\");for(var d in this.uniforms)this.uniforms[d].uniformLocation=c.getUniformLocation(a,d);this.initUniforms(),this.program=a},b.PixiShader.prototype.initUniforms=function(){this.textureCount=1;var a;for(var c in this.uniforms){a=this.uniforms[c];var d=a.type;\"sampler2D\"===d?(a._init=!1,null!==a.value&&this.initSampler2D(a)):\"mat2\"===d||\"mat3\"===d||\"mat4\"===d?(a.glMatrix=!0,a.glValueLength=1,\"mat2\"===d?a.glFunc=b.gl.uniformMatrix2fv:\"mat3\"===d?a.glFunc=b.gl.uniformMatrix3fv:\"mat4\"===d&&(a.glFunc=b.gl.uniformMatrix4fv)):(a.glFunc=b.gl[\"uniform\"+d],a.glValueLength=\"2f\"===d||\"2i\"===d?2:\"3f\"===d||\"3i\"===d?3:\"4f\"===d||\"4i\"===d?4:1)}},b.PixiShader.prototype.initSampler2D=function(a){if(a.value&&a.value.baseTexture&&a.value.baseTexture.hasLoaded){if(b.gl.activeTexture(b.gl[\"TEXTURE\"+this.textureCount]),b.gl.bindTexture(b.gl.TEXTURE_2D,a.value.baseTexture._glTexture),a.textureData){var c=a.textureData,d=c.magFilter?c.magFilter:b.gl.LINEAR,e=c.minFilter?c.minFilter:b.gl.LINEAR,f=c.wrapS?c.wrapS:b.gl.CLAMP_TO_EDGE,g=c.wrapT?c.wrapT:b.gl.CLAMP_TO_EDGE,h=c.luminance?b.gl.LUMINANCE:b.gl.RGBA;if(c.repeat&&(f=b.gl.REPEAT,g=b.gl.REPEAT),b.gl.pixelStorei(b.gl.UNPACK_FLIP_Y_WEBGL,!1),c.width){var i=c.width?c.width:512,j=c.height?c.height:2,k=c.border?c.border:0;b.gl.texImage2D(b.gl.TEXTURE_2D,0,h,i,j,k,h,b.gl.UNSIGNED_BYTE,null)}else b.gl.texImage2D(b.gl.TEXTURE_2D,0,h,b.gl.RGBA,b.gl.UNSIGNED_BYTE,a.value.baseTexture.source);b.gl.texParameteri(b.gl.TEXTURE_2D,b.gl.TEXTURE_MAG_FILTER,d),b.gl.texParameteri(b.gl.TEXTURE_2D,b.gl.TEXTURE_MIN_FILTER,e),b.gl.texParameteri(b.gl.TEXTURE_2D,b.gl.TEXTURE_WRAP_S,f),b.gl.texParameteri(b.gl.TEXTURE_2D,b.gl.TEXTURE_WRAP_T,g)}b.gl.uniform1i(a.uniformLocation,this.textureCount),a._init=!0,this.textureCount++}},b.PixiShader.prototype.syncUniforms=function(){this.textureCount=1;var a;for(var c in this.uniforms)a=this.uniforms[c],1===a.glValueLength?a.glMatrix===!0?a.glFunc.call(b.gl,a.uniformLocation,a.transpose,a.value):a.glFunc.call(b.gl,a.uniformLocation,a.value):2===a.glValueLength?a.glFunc.call(b.gl,a.uniformLocation,a.value.x,a.value.y):3===a.glValueLength?a.glFunc.call(b.gl,a.uniformLocation,a.value.x,a.value.y,a.value.z):4===a.glValueLength?a.glFunc.call(b.gl,a.uniformLocation,a.value.x,a.value.y,a.value.z,a.value.w):\"sampler2D\"===a.type&&(a._init?(b.gl.activeTexture(b.gl[\"TEXTURE\"+this.textureCount]),b.gl.bindTexture(b.gl.TEXTURE_2D,a.value.baseTexture._glTexture),b.gl.uniform1i(a.uniformLocation,this.textureCount),this.textureCount++):this.initSampler2D(a))},b.PixiShader.defaultVertexSrc=[\"attribute vec2 aVertexPosition;\",\"attribute vec2 aTextureCoord;\",\"attribute float aColor;\",\"uniform vec2 projectionVector;\",\"uniform vec2 offsetVector;\",\"varying vec2 vTextureCoord;\",\"varying float vColor;\",\"const vec2 center = vec2(-1.0, 1.0);\",\"void main(void) {\",\" gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);\",\" vTextureCoord = aTextureCoord;\",\" vColor = aColor;\",\"}\"],b.PrimitiveShader=function(){this.program=null,this.fragmentSrc=[\"precision mediump float;\",\"varying vec4 vColor;\",\"void main(void) {\",\" gl_FragColor = vColor;\",\"}\"],this.vertexSrc=[\"attribute vec2 aVertexPosition;\",\"attribute vec4 aColor;\",\"uniform mat3 translationMatrix;\",\"uniform vec2 projectionVector;\",\"uniform vec2 offsetVector;\",\"uniform float alpha;\",\"varying vec4 vColor;\",\"void main(void) {\",\" vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);\",\" v -= offsetVector.xyx;\",\" gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);\",\" vColor = aColor * alpha;\",\"}\"] },b.PrimitiveShader.prototype.init=function(){var a=b.compileProgram(this.vertexSrc,this.fragmentSrc),c=b.gl;c.useProgram(a),this.projectionVector=c.getUniformLocation(a,\"projectionVector\"),this.offsetVector=c.getUniformLocation(a,\"offsetVector\"),this.aVertexPosition=c.getAttribLocation(a,\"aVertexPosition\"),this.colorAttribute=c.getAttribLocation(a,\"aColor\"),this.translationMatrix=c.getUniformLocation(a,\"translationMatrix\"),this.alpha=c.getUniformLocation(a,\"alpha\"),this.program=a},b.StripShader=function(){this.program=null,this.fragmentSrc=[\"precision mediump float;\",\"varying vec2 vTextureCoord;\",\"varying float vColor;\",\"uniform float alpha;\",\"uniform sampler2D uSampler;\",\"void main(void) {\",\" gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));\",\" gl_FragColor = gl_FragColor * alpha;\",\"}\"],this.vertexSrc=[\"attribute vec2 aVertexPosition;\",\"attribute vec2 aTextureCoord;\",\"attribute float aColor;\",\"uniform mat3 translationMatrix;\",\"uniform vec2 projectionVector;\",\"uniform vec2 offsetVector;\",\"varying vec2 vTextureCoord;\",\"varying float vColor;\",\"void main(void) {\",\" vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);\",\" v -= offsetVector.xyx;\",\" gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / projectionVector.y + 1.0 , 0.0, 1.0);\",\" vTextureCoord = aTextureCoord;\",\" vColor = aColor;\",\"}\"]},b.StripShader.prototype.init=function(){var a=b.compileProgram(this.vertexSrc,this.fragmentSrc),c=b.gl;c.useProgram(a),this.uSampler=c.getUniformLocation(a,\"uSampler\"),this.projectionVector=c.getUniformLocation(a,\"projectionVector\"),this.offsetVector=c.getUniformLocation(a,\"offsetVector\"),this.colorAttribute=c.getAttribLocation(a,\"aColor\"),this.aVertexPosition=c.getAttribLocation(a,\"aVertexPosition\"),this.aTextureCoord=c.getAttribLocation(a,\"aTextureCoord\"),this.translationMatrix=c.getUniformLocation(a,\"translationMatrix\"),this.alpha=c.getUniformLocation(a,\"alpha\"),this.program=a},b._batchs=[],b._getBatch=function(a){return 0===b._batchs.length?new b.WebGLBatch(a):b._batchs.pop()},b._returnBatch=function(a){a.clean(),b._batchs.push(a)},b._restoreBatchs=function(a){for(var c=0;cc;c++){var d=6*c,e=4*c;this.indices[d+0]=e+0,this.indices[d+1]=e+1,this.indices[d+2]=e+2,this.indices[d+3]=e+0,this.indices[d+4]=e+2,this.indices[d+5]=e+3}a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this.indexBuffer),a.bufferData(a.ELEMENT_ARRAY_BUFFER,this.indices,a.STATIC_DRAW)},b.WebGLBatch.prototype.refresh=function(){this.dynamicSize1){a.viewport(0,0,d.width,d.height),a.bindBuffer(a.ARRAY_BUFFER,this.vertexBuffer),this.vertexArray[0]=0,this.vertexArray[1]=d.height,this.vertexArray[2]=d.width,this.vertexArray[3]=d.height,this.vertexArray[4]=0,this.vertexArray[5]=0,this.vertexArray[6]=d.width,this.vertexArray[7]=0,a.bufferSubData(a.ARRAY_BUFFER,0,this.vertexArray),a.bindBuffer(a.ARRAY_BUFFER,this.uvBuffer),this.uvArray[2]=d.width/this.width,this.uvArray[5]=d.height/this.height,this.uvArray[6]=d.width/this.width,this.uvArray[7]=d.height/this.height,a.bufferSubData(a.ARRAY_BUFFER,0,this.uvArray);var f=e,g=this.texturePool.pop();g||(g=new b.FilterTexture(this.width,this.height)),a.bindFramebuffer(a.FRAMEBUFFER,g.frameBuffer),a.clear(a.COLOR_BUFFER_BIT),a.disable(a.BLEND);for(var h=0;hs?s:E,E=E>t?t:E,E=E>u?u:E,E=E>v?v:E,F=F>w?w:F,F=F>x?x:F,F=F>y?y:F,F=F>z?z:F,C=s>C?s:C,C=t>C?t:C,C=u>C?u:C,C=v>C?v:C,D=w>D?w:D,D=x>D?x:D,D=y>D?y:D,D=z>D?z:D),l=!1,A=A._iNext}while(A!==B);a.filterArea.x=E,a.filterArea.y=F,a.filterArea.width=C-E,a.filterArea.height=D-F},b.FilterTexture=function(a,c){var d=b.gl;this.frameBuffer=d.createFramebuffer(),this.texture=d.createTexture(),d.bindTexture(d.TEXTURE_2D,this.texture),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.bindFramebuffer(d.FRAMEBUFFER,this.framebuffer),d.bindFramebuffer(d.FRAMEBUFFER,this.frameBuffer),d.framebufferTexture2D(d.FRAMEBUFFER,d.COLOR_ATTACHMENT0,d.TEXTURE_2D,this.texture,0),this.resize(a,c)},b.FilterTexture.prototype.resize=function(a,c){if(this.width!==a||this.height!==c){this.width=a,this.height=c;var d=b.gl;d.bindTexture(d.TEXTURE_2D,this.texture),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,a,c,0,d.RGBA,d.UNSIGNED_BYTE,null)}},b.WebGLGraphics=function(){},b.WebGLGraphics.renderGraphics=function(a,c){var d=b.gl;a._webGL||(a._webGL={points:[],indices:[],lastIndex:0,buffer:d.createBuffer(),indexBuffer:d.createBuffer()}),a.dirty&&(a.dirty=!1,a.clearDirty&&(a.clearDirty=!1,a._webGL.lastIndex=0,a._webGL.points=[],a._webGL.indices=[]),b.WebGLGraphics.updateGraphics(a)),b.activatePrimitiveShader();var e=b.mat3.clone(a.worldTransform);b.mat3.transpose(e),d.blendFunc(d.ONE,d.ONE_MINUS_SRC_ALPHA),d.uniformMatrix3fv(b.primitiveShader.translationMatrix,!1,e),d.uniform2f(b.primitiveShader.projectionVector,c.x,-c.y),d.uniform2f(b.primitiveShader.offsetVector,-b.offset.x,-b.offset.y),d.uniform1f(b.primitiveShader.alpha,a.worldAlpha),d.bindBuffer(d.ARRAY_BUFFER,a._webGL.buffer),d.vertexAttribPointer(b.primitiveShader.aVertexPosition,2,d.FLOAT,!1,24,0),d.vertexAttribPointer(b.primitiveShader.colorAttribute,4,d.FLOAT,!1,24,8),d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,a._webGL.indexBuffer),d.drawElements(d.TRIANGLE_STRIP,a._webGL.indices.length,d.UNSIGNED_SHORT,0),b.deactivatePrimitiveShader()},b.WebGLGraphics.updateGraphics=function(a){for(var c=a._webGL.lastIndex;c3&&b.WebGLGraphics.buildPoly(d,a._webGL),d.lineWidth>0&&b.WebGLGraphics.buildLine(d,a._webGL)):d.type===b.Graphics.RECT?b.WebGLGraphics.buildRectangle(d,a._webGL):(d.type===b.Graphics.CIRC||d.type===b.Graphics.ELIP)&&b.WebGLGraphics.buildCircle(d,a._webGL)}a._webGL.lastIndex=a.graphicsData.length;var e=b.gl;a._webGL.glPoints=new Float32Array(a._webGL.points),e.bindBuffer(e.ARRAY_BUFFER,a._webGL.buffer),e.bufferData(e.ARRAY_BUFFER,a._webGL.glPoints,e.STATIC_DRAW),a._webGL.glIndicies=new Uint16Array(a._webGL.indices),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,a._webGL.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,a._webGL.glIndicies,e.STATIC_DRAW)},b.WebGLGraphics.buildRectangle=function(a,c){var d=a.points,e=d[0],f=d[1],g=d[2],h=d[3];if(a.fill){var i=b.hex2rgb(a.fillColor),j=a.fillAlpha,k=i[0]*j,l=i[1]*j,m=i[2]*j,n=c.points,o=c.indices,p=n.length/6;n.push(e,f),n.push(k,l,m,j),n.push(e+g,f),n.push(k,l,m,j),n.push(e,f+h),n.push(k,l,m,j),n.push(e+g,f+h),n.push(k,l,m,j),o.push(p,p,p+1,p+2,p+3,p+3)}a.lineWidth&&(a.points=[e,f,e+g,f,e+g,f+h,e,f+h,e,f],b.WebGLGraphics.buildLine(a,c))},b.WebGLGraphics.buildCircle=function(a,c){var d=a.points,e=d[0],f=d[1],g=d[2],h=d[3],i=40,j=2*Math.PI/i,k=0;if(a.fill){var l=b.hex2rgb(a.fillColor),m=a.fillAlpha,n=l[0]*m,o=l[1]*m,p=l[2]*m,q=c.points,r=c.indices,s=q.length/6;for(r.push(s),k=0;i+1>k;k++)q.push(e,f,n,o,p,m),q.push(e+Math.sin(j*k)*g,f+Math.cos(j*k)*h,n,o,p,m),r.push(s++,s++);r.push(s-1)}if(a.lineWidth){for(a.points=[],k=0;i+1>k;k++)a.points.push(e+Math.sin(j*k)*g,f+Math.cos(j*k)*h);b.WebGLGraphics.buildLine(a,c)}},b.WebGLGraphics.buildLine=function(a,c){var d=0,e=a.points;if(0!==e.length){if(a.lineWidth%2)for(d=0;dd;d++)l=e[2*(d-1)],m=e[2*(d-1)+1],n=e[2*d],o=e[2*d+1],p=e[2*(d+1)],q=e[2*(d+1)+1],r=-(m-o),s=l-n,F=Math.sqrt(r*r+s*s),r/=F,s/=F,r*=L,s*=L,t=-(o-q),u=n-p,F=Math.sqrt(t*t+u*u),t/=F,u/=F,t*=L,u*=L,x=-s+m-(-s+o),y=-r+n-(-r+l),z=(-r+l)*(-s+o)-(-r+n)*(-s+m),A=-u+q-(-u+o),B=-t+n-(-t+p),C=(-t+p)*(-u+o)-(-t+n)*(-u+q),D=x*B-A*y,Math.abs(D)19600?(v=r-t,w=s-u,F=Math.sqrt(v*v+w*w),v/=F,w/=F,v*=L,w*=L,G.push(n-v,o-w),G.push(O,P,Q,N),G.push(n+v,o+w),G.push(O,P,Q,N),G.push(n-v,o-w),G.push(O,P,Q,N),J++):(G.push(j,k),G.push(O,P,Q,N),G.push(n-(j-n),o-(k-o)),G.push(O,P,Q,N)));for(l=e[2*(I-2)],m=e[2*(I-2)+1],n=e[2*(I-1)],o=e[2*(I-1)+1],r=-(m-o),s=l-n,F=Math.sqrt(r*r+s*s),r/=F,s/=F,r*=L,s*=L,G.push(n-r,o-s),G.push(O,P,Q,N),G.push(n+r,o+s),G.push(O,P,Q,N),H.push(K),d=0;J>d;d++)H.push(K++);H.push(K-1)}},b.WebGLGraphics.buildPoly=function(a,c){var d=a.points;if(!(d.length0){for(var d=0;dc;c++)a[b.type][c](b)},this.removeEventListener=this.off=function(b,c){var d=a[b].indexOf(c);-1!==d&&a[b].splice(d,1)},this.removeAllEventListeners=function(b){var c=a[b];c&&(c.length=0)}},b.PolyK={},b.PolyK.Triangulate=function(a){var c=!0,d=a.length>>1;if(3>d)return[];for(var e=[],f=[],g=0;d>g;g++)f.push(g);g=0;for(var h=d;h>3;){var i=f[(g+0)%h],j=f[(g+1)%h],k=f[(g+2)%h],l=a[2*i],m=a[2*i+1],n=a[2*j],o=a[2*j+1],p=a[2*k],q=a[2*k+1],r=!1;if(b.PolyK._convex(l,m,n,o,p,q,c)){r=!0;for(var s=0;h>s;s++){var t=f[s];if(t!==i&&t!==j&&t!==k&&b.PolyK._PointInTriangle(a[2*t],a[2*t+1],l,m,n,o,p,q)){r=!1;break}}}if(r)e.push(i,j,k),f.splice((g+1)%h,1),h--,g=0;else if(g++>3*h){if(!c)return window.console.log(\"PIXI Warning: shape too complex to fill\"),[];for(e=[],f=[],g=0;d>g;g++)f.push(g);g=0,h=d,c=!1}}return e.push(f[0],f[1],f[2]),e},b.PolyK._PointInTriangle=function(a,b,c,d,e,f,g,h){var i=g-c,j=h-d,k=e-c,l=f-d,m=a-c,n=b-d,o=i*i+j*j,p=i*k+j*l,q=i*m+j*n,r=k*k+l*l,s=k*m+l*n,t=1/(o*r-p*p),u=(r*q-p*s)*t,v=(o*s-p*q)*t;return u>=0&&v>=0&&1>u+v},b.PolyK._convex=function(a,b,c,d,e,f,g){return(b-d)*(e-c)+(c-a)*(f-d)>=0===g},c.Camera=function(a,b,d,e,f,g){this.game=a,this.world=a.world,this.id=0,this.view=new c.Rectangle(d,e,f,g),this.screenView=new c.Rectangle(d,e,f,g),this.bounds=new c.Rectangle(d,e,f,g),this.deadzone=null,this.visible=!0,this.atLimit={x:!1,y:!1},this.target=null,this._edge=0,this.displayObject=null},c.Camera.FOLLOW_LOCKON=0,c.Camera.FOLLOW_PLATFORMER=1,c.Camera.FOLLOW_TOPDOWN=2,c.Camera.FOLLOW_TOPDOWN_TIGHT=3,c.Camera.prototype={follow:function(a,b){\"undefined\"==typeof b&&(b=c.Camera.FOLLOW_LOCKON),this.target=a;var d;switch(b){case c.Camera.FOLLOW_PLATFORMER:var e=this.width/8,f=this.height/3;this.deadzone=new c.Rectangle((this.width-e)/2,(this.height-f)/2-.25*f,e,f);break;case c.Camera.FOLLOW_TOPDOWN:d=Math.max(this.width,this.height)/4,this.deadzone=new c.Rectangle((this.width-d)/2,(this.height-d)/2,d,d);break;case c.Camera.FOLLOW_TOPDOWN_TIGHT:d=Math.max(this.width,this.height)/8,this.deadzone=new c.Rectangle((this.width-d)/2,(this.height-d)/2,d,d);break;case c.Camera.FOLLOW_LOCKON:this.deadzone=null;break;default:this.deadzone=null}},focusOn:function(a){this.setPosition(Math.round(a.x-this.view.halfWidth),Math.round(a.y-this.view.halfHeight))},focusOnXY:function(a,b){this.setPosition(Math.round(a-this.view.halfWidth),Math.round(b-this.view.halfHeight))},update:function(){this.target&&this.updateTarget(),this.bounds&&this.checkBounds(),this.displayObject.position.x=-this.view.x,this.displayObject.position.y=-this.view.y},updateTarget:function(){this.deadzone?(this._edge=this.target.x-this.deadzone.x,this.view.x>this._edge&&(this.view.x=this._edge),this._edge=this.target.x+this.target.width-this.deadzone.x-this.deadzone.width,this.view.xthis._edge&&(this.view.y=this._edge),this._edge=this.target.y+this.target.height-this.deadzone.y-this.deadzone.height,this.view.y0&&(this.uniforms.mouse.y=a.y.toFixed(2))),this.uniforms.time.value=this.game.time.totalElapsedSeconds()},destroy:function(){this.game=null}},c.Filter.prototype.constructor=c.Filter,Object.defineProperty(c.Filter.prototype,\"width\",{get:function(){return this.uniforms.resolution.value.x},set:function(a){this.uniforms.resolution.value.x=a}}),Object.defineProperty(c.Filter.prototype,\"height\",{get:function(){return this.uniforms.resolution.value.y},set:function(a){this.uniforms.resolution.value.y=a}}),c.Plugin=function(a,b){\"undefined\"==typeof b&&(b=null),this.game=a,this.parent=b,this.active=!1,this.visible=!1,this.hasPreUpdate=!1,this.hasUpdate=!1,this.hasPostUpdate=!1,this.hasRender=!1,this.hasPostRender=!1},c.Plugin.prototype={preUpdate:function(){},update:function(){},render:function(){},postRender:function(){},destroy:function(){this.game=null,this.parent=null,this.active=!1,this.visible=!1}},c.Plugin.prototype.constructor=c.Plugin,c.PluginManager=function(a,b){this.game=a,this._parent=b,this.plugins=[],this._pluginsLength=0},c.PluginManager.prototype={add:function(a){var b=!1;return\"function\"==typeof a?a=new a(this.game,this._parent):(a.game=this.game,a.parent=this._parent),\"function\"==typeof a.preUpdate&&(a.hasPreUpdate=!0,b=!0),\"function\"==typeof a.update&&(a.hasUpdate=!0,b=!0),\"function\"==typeof a.postUpdate&&(a.hasPostUpdate=!0,b=!0),\"function\"==typeof a.render&&(a.hasRender=!0,b=!0),\"function\"==typeof a.postRender&&(a.hasPostRender=!0,b=!0),b?((a.hasPreUpdate||a.hasUpdate||a.hasPostUpdate)&&(a.active=!0),(a.hasRender||a.hasPostRender)&&(a.visible=!0),this._pluginsLength=this.plugins.push(a),\"function\"==typeof a.init&&a.init(),a):null},remove:function(a){if(0!==this._pluginsLength)for(this._p=0;this._pf;f++)b==c.Group.SORT_ASCENDING?this._container.children[f][a]>this._container.children[f+1][a]&&(this.swap(this.getAt(f),this.getAt(f+1)),e=this._container.children[f],this._container.children[f]=this._container.children[f+1],this._container.children[f+1]=e,d=!0):this._container.children[f][a]0&&this._container.first._iNext){var i=this._container.first._iNext;do{if(i[a]===b&&(h++,e&&(g[0]=i,e.apply(f,g)),d===c.Group.RETURN_CHILD))return i;i=i._iNext}while(i!=this._container.last._iNext)}return d===c.Group.RETURN_TOTAL?h:d===c.Group.RETURN_CHILD?null:void 0},getFirstExists:function(a){return\"boolean\"!=typeof a&&(a=!0),this.iterate(\"exists\",a,c.Group.RETURN_CHILD)},getFirstAlive:function(){return this.iterate(\"alive\",!0,c.Group.RETURN_CHILD)},getFirstDead:function(){return this.iterate(\"alive\",!1,c.Group.RETURN_CHILD)},countLiving:function(){return this.iterate(\"alive\",!0,c.Group.RETURN_TOTAL)},countDead:function(){return this.iterate(\"alive\",!1,c.Group.RETURN_TOTAL)},getRandom:function(a,b){return 0===this._container.children.length?null:(a=a||0,b=b||this._container.children.length,this.game.math.getRandom(this._container.children,a,b))},remove:function(a){return a.group!==this?!1:(a.events&&a.events.onRemovedFromGroup.dispatch(a,this),a.parent===this._container&&this._container.removeChild(a),this.cursor==a&&(this.cursor=this._container._iNext?this._container._iNext:null),a.group=null,!0)},removeAll:function(){if(0!==this._container.children.length){do this._container.children[0].events&&this._container.children[0].events.onRemovedFromGroup.dispatch(this._container.children[0],this),this._container.removeChild(this._container.children[0]);while(this._container.children.length>0);this.cursor=null}},removeBetween:function(a,b){if(0!==this._container.children.length){if(a>b||0>a||b>this._container.children.length)return!1;for(var c=a;b>c;c++){var d=this._container.children[c];d.events.onRemovedFromGroup.dispatch(d,this),this._container.removeChild(d),this.cursor==d&&(this.cursor=this._container._iNext?this._container._iNext:null)}}},destroy:function(a){if(\"undefined\"==typeof a&&(a=!1),a){if(this._container.children.length>0)do this._container.children[0].group&&this._container.children[0].destroy();while(this._container.children.length>0)}else this.removeAll();this._container.parent.removeChild(this._container),this._container=null,this.game=null,this.exists=!1,this.cursor=null},validate:function(){var a=this.game.stage._stage.last._iNext,b=this.game.stage._stage,c=null,d=null,e=0;do{if(e>0){if(b!==c)return console.log(\"check next fail\"),!1;if(b._iPrev!==d)return console.log(\"check previous fail\"),!1}c=b._iNext,d=b,b=b._iNext,e++}while(b!=a);return!0}},c.Group.prototype.constructor=c.Group,Object.defineProperty(c.Group.prototype,\"total\",{get:function(){return this._container?this.iterate(\"exists\",!0,c.Group.RETURN_TOTAL):0}}),Object.defineProperty(c.Group.prototype,\"length\",{get:function(){return this._container?this._container.children.length:0}}),Object.defineProperty(c.Group.prototype,\"x\",{get:function(){return this._container.position.x},set:function(a){this._container.position.x=a}}),Object.defineProperty(c.Group.prototype,\"y\",{get:function(){return this._container.position.y},set:function(a){this._container.position.y=a}}),Object.defineProperty(c.Group.prototype,\"angle\",{get:function(){return c.Math.radToDeg(this._container.rotation)},set:function(a){this._container.rotation=c.Math.degToRad(a)}}),Object.defineProperty(c.Group.prototype,\"rotation\",{get:function(){return this._container.rotation},set:function(a){this._container.rotation=a}}),Object.defineProperty(c.Group.prototype,\"visible\",{get:function(){return this._container.visible},set:function(a){this._container.visible=a}}),Object.defineProperty(c.Group.prototype,\"alpha\",{get:function(){return this._container.alpha},set:function(a){this._container.alpha=a}}),c.World=function(a){c.Group.call(this,a,null,\"__world\",!1),this.bounds=new c.Rectangle(0,0,a.width,a.height),this.camera=null,this.currentRenderOrderID=0},c.World.prototype=Object.create(c.Group.prototype),c.World.prototype.constructor=c.World,c.World.prototype.boot=function(){this.camera=new c.Camera(this.game,0,0,0,this.game.width,this.game.height),this.camera.displayObject=this._container,this.game.camera=this.camera},c.World.prototype.preUpdate=function(){if(this.game.stage._stage.first._iNext){var a=this.game.stage._stage.first._iNext;do a=a.preUpdate&&!a.preUpdate()?a.last._iNext:a._iNext;while(a!=this.game.stage._stage.last._iNext)}},c.World.prototype.update=function(){if(this.currentRenderOrderID=0,this.game.stage._stage.first._iNext){var a=this.game.stage._stage.first._iNext;do a=a.update&&!a.update()?a.last._iNext:a._iNext;while(a!=this.game.stage._stage.last._iNext)}},c.World.prototype.postUpdate=function(){if(this.camera.target&&this.camera.target.postUpdate){if(this.camera.target.postUpdate(),this.camera.update(),this.game.stage._stage.first._iNext){var a=this.game.stage._stage.first._iNext;do a.postUpdate&&a!==this.camera.target&&a.postUpdate(),a=a._iNext;while(a!=this.game.stage._stage.last._iNext)}}else if(this.camera.update(),this.game.stage._stage.first._iNext){var a=this.game.stage._stage.first._iNext;do a.postUpdate&&a.postUpdate(),a=a._iNext;while(a!=this.game.stage._stage.last._iNext)}},c.World.prototype.setBounds=function(a,b,c,d){c=b;b++)if(this[\"pointer\"+b]&&this[\"pointer\"+b].active&&this[\"pointer\"+b].identifier==a.identifier)return this[\"pointer\"+b].stop(a);return null},getPointer:function(a){if(a=a||!1,this.pointer1.active==a)return this.pointer1;if(this.pointer2.active==a)return this.pointer2;for(var b=3;10>=b;b++)if(this[\"pointer\"+b]&&this[\"pointer\"+b].active==a)return this[\"pointer\"+b];return null},getPointerFromIdentifier:function(a){if(this.pointer1.identifier==a)return this.pointer1;if(this.pointer2.identifier==a)return this.pointer2;for(var b=3;10>=b;b++)if(this[\"pointer\"+b]&&this[\"pointer\"+b].identifier==a)return this[\"pointer\"+b];return null}},c.Input.prototype.constructor=c.Input,Object.defineProperty(c.Input.prototype,\"x\",{get:function(){return this._x},set:function(a){this._x=Math.floor(a)}}),Object.defineProperty(c.Input.prototype,\"y\",{get:function(){return this._y},set:function(a){this._y=Math.floor(a)}}),Object.defineProperty(c.Input.prototype,\"pollLocked\",{get:function(){return this.pollRate>0&&this._pollCounter=a;a++)this[\"pointer\"+a]&&this[\"pointer\"+a].active&&this.currentPointers++;return this.currentPointers}}),Object.defineProperty(c.Input.prototype,\"worldX\",{get:function(){return this.game.camera.view.x+this.x}}),Object.defineProperty(c.Input.prototype,\"worldY\",{get:function(){return this.game.camera.view.y+this.y}}),c.Key=function(a,b){this.game=a,this.isDown=!1,this.isUp=!1,this.altKey=!1,this.ctrlKey=!1,this.shiftKey=!1,this.timeDown=0,this.duration=0,this.timeUp=0,this.repeats=0,this.keyCode=b,this.onDown=new c.Signal,this.onUp=new c.Signal},c.Key.prototype={processKeyDown:function(a){this.altKey=a.altKey,this.ctrlKey=a.ctrlKey,this.shiftKey=a.shiftKey,this.isDown?(this.duration=a.timeStamp-this.timeDown,this.repeats++):(this.isDown=!0,this.isUp=!1,this.timeDown=a.timeStamp,this.duration=0,this.repeats=0,this.onDown.dispatch(this))},processKeyUp:function(a){this.isDown=!1,this.isUp=!0,this.timeUp=a.timeStamp,this.onUp.dispatch(this)},justPressed:function(a){return\"undefined\"==typeof a&&(a=250),this.isDown&&this.duration0){var b=this.game.input.interactiveItems.next;do(b.pixelPerfect||b.priorityID>this._highestInputPriorityID||b.priorityID==this._highestInputPriorityID&&b.sprite.renderOrderID>this._highestRenderOrderID)&&b.checkPointerOver(this)&&(this._highestRenderOrderID=b.sprite.renderOrderID,this._highestInputPriorityID=b.priorityID,this._highestRenderObject=b),b=b.next;while(null!=b)}return null==this._highestRenderObject?this.targetObject&&(this.targetObject._pointerOutHandler(this),this.targetObject=null):null==this.targetObject?(this.targetObject=this._highestRenderObject,this._highestRenderObject._pointerOverHandler(this)):this.targetObject==this._highestRenderObject?this._highestRenderObject.update(this)===!1&&(this.targetObject=null):(this.targetObject._pointerOutHandler(this),this.targetObject=this._highestRenderObject,this.targetObject._pointerOverHandler(this)),this}},leave:function(a){this.withinGame=!1,this.move(a)},stop:function(a){if(this._stateReset)return a.preventDefault(),void 0;if(this.timeUp=this.game.time.now,(this.game.input.multiInputOverride==c.Input.MOUSE_OVERRIDES_TOUCH||this.game.input.multiInputOverride==c.Input.MOUSE_TOUCH_COMBINE||this.game.input.multiInputOverride==c.Input.TOUCH_OVERRIDES_MOUSE&&0===this.game.input.currentPointers)&&(this.game.input.onUp.dispatch(this,a),this.duration>=0&&this.duration0){var b=this.game.input.interactiveItems.next;do b&&b._releasedHandler(this),b=b.next;while(null!=b)}return this.targetObject&&this.targetObject._releasedHandler(this),this.targetObject=null,this},justPressed:function(a){return a=a||this.game.input.justPressedRate,this.isDown===!0&&this.timeDown+a>this.game.time.now},justReleased:function(a){return a=a||this.game.input.justReleasedRate,this.isUp===!0&&this.timeUp+a>this.game.time.now},reset:function(){this.isMouse===!1&&(this.active=!1),this.identifier=null,this.isDown=!1,this.isUp=!0,this.totalTouches=0,this._holdSent=!1,this._history.length=0,this._stateReset=!0,this.targetObject&&this.targetObject._releasedHandler(this),this.targetObject=null}},c.Pointer.prototype.constructor=c.Pointer,Object.defineProperty(c.Pointer.prototype,\"duration\",{get:function(){return this.isUp?-1:this.game.time.now-this.timeDown}}),Object.defineProperty(c.Pointer.prototype,\"worldX\",{get:function(){return this.game.world.camera.x+this.x}}),Object.defineProperty(c.Pointer.prototype,\"worldY\",{get:function(){return this.game.world.camera.y+this.y}}),c.Touch=function(a){this.game=a,this.disabled=!1,this.callbackContext=this.game,this.touchStartCallback=null,this.touchMoveCallback=null,this.touchEndCallback=null,this.touchEnterCallback=null,this.touchLeaveCallback=null,this.touchCancelCallback=null,this.preventDefault=!0,this.event=null,this._onTouchStart=null,this._onTouchMove=null,this._onTouchEnd=null,this._onTouchEnter=null,this._onTouchLeave=null,this._onTouchCancel=null,this._onTouchMove=null},c.Touch.prototype={start:function(){var a=this;this.game.device.touch&&(this._onTouchStart=function(b){return a.onTouchStart(b)},this._onTouchMove=function(b){return a.onTouchMove(b)},this._onTouchEnd=function(b){return a.onTouchEnd(b)},this._onTouchEnter=function(b){return a.onTouchEnter(b)},this._onTouchLeave=function(b){return a.onTouchLeave(b)},this._onTouchCancel=function(b){return a.onTouchCancel(b)},this.game.renderer.view.addEventListener(\"touchstart\",this._onTouchStart,!1),this.game.renderer.view.addEventListener(\"touchmove\",this._onTouchMove,!1),this.game.renderer.view.addEventListener(\"touchend\",this._onTouchEnd,!1),this.game.renderer.view.addEventListener(\"touchenter\",this._onTouchEnter,!1),this.game.renderer.view.addEventListener(\"touchleave\",this._onTouchLeave,!1),this.game.renderer.view.addEventListener(\"touchcancel\",this._onTouchCancel,!1))},consumeDocumentTouches:function(){this._documentTouchMove=function(a){a.preventDefault()},document.addEventListener(\"touchmove\",this._documentTouchMove,!1)},onTouchStart:function(a){if(this.event=a,this.touchStartCallback&&this.touchStartCallback.call(this.callbackContext,a),!this.game.input.disabled&&!this.disabled){this.preventDefault&&a.preventDefault();for(var b=0;bb;b++)if(this._pointerData[b].isOut)return!0}return!1},pointerTimeOver:function(a){return a=a||0,this._pointerData[a].timeOver},pointerTimeOut:function(a){return a=a||0,this._pointerData[a].timeOut},pointerDragged:function(a){return a=a||0,this._pointerData[a].isDragged},checkPointerOver:function(a){return this.enabled===!1||this.sprite.visible===!1||this.sprite.group&&this.sprite.group.visible===!1?!1:(this.sprite.getLocalUnmodifiedPosition(this._tempPoint,a.x,a.y),this._tempPoint.x>=0&&this._tempPoint.x=0&&this._tempPoint.y=this.pixelPerfectAlpha)return!0}return!1},update:function(a){return this.enabled===!1||this.sprite.visible===!1||this.sprite.group&&this.sprite.group.visible===!1?(this._pointerOutHandler(a),!1):this.draggable&&this._draggedPointerID==a.id?this.updateDrag(a):this._pointerData[a.id].isOver===!0?this.checkPointerOver(a)?(this._pointerData[a.id].x=a.x-this.sprite.x,this._pointerData[a.id].y=a.y-this.sprite.y,!0):(this._pointerOutHandler(a),!1):void 0},_pointerOverHandler:function(a){this._pointerData[a.id].isOver===!1&&(this._pointerData[a.id].isOver=!0,this._pointerData[a.id].isOut=!1,this._pointerData[a.id].timeOver=this.game.time.now,this._pointerData[a.id].x=a.x-this.sprite.x,this._pointerData[a.id].y=a.y-this.sprite.y,this.useHandCursor&&this._pointerData[a.id].isDragged===!1&&(this.game.canvas.style.cursor=\"pointer\"),this.sprite.events.onInputOver.dispatch(this.sprite,a))},_pointerOutHandler:function(a){this._pointerData[a.id].isOver=!1,this._pointerData[a.id].isOut=!0,this._pointerData[a.id].timeOut=this.game.time.now,this.useHandCursor&&this._pointerData[a.id].isDragged===!1&&(this.game.canvas.style.cursor=\"default\"),this.sprite&&this.sprite.events&&this.sprite.events.onInputOut.dispatch(this.sprite,a)},_touchedHandler:function(a){return this._pointerData[a.id].isDown===!1&&this._pointerData[a.id].isOver===!0&&(this._pointerData[a.id].isDown=!0,this._pointerData[a.id].isUp=!1,this._pointerData[a.id].timeDown=this.game.time.now,this.sprite.events.onInputDown.dispatch(this.sprite,a),this.draggable&&this.isDragged===!1&&this.startDrag(a),this.bringToTop&&this.sprite.bringToTop()),this.consumePointerEvent},_releasedHandler:function(a){this._pointerData[a.id].isDown&&a.isUp&&(this._pointerData[a.id].isDown=!1,this._pointerData[a.id].isUp=!0,this._pointerData[a.id].timeUp=this.game.time.now,this._pointerData[a.id].downDuration=this._pointerData[a.id].timeUp-this._pointerData[a.id].timeDown,this.checkPointerOver(a)?this.sprite.events.onInputUp.dispatch(this.sprite,a,!0):(this.sprite.events.onInputUp.dispatch(this.sprite,a,!1),this.useHandCursor&&(this.game.canvas.style.cursor=\"default\")),this.draggable&&this.isDragged&&this._draggedPointerID==a.id&&this.stopDrag(a))},updateDrag:function(a){return a.isUp?(this.stopDrag(a),!1):(this.sprite.fixedToCamera?(this.allowHorizontalDrag&&(this.sprite.cameraOffset.x=a.x+this._dragPoint.x+this.dragOffset.x),this.allowVerticalDrag&&(this.sprite.cameraOffset.y=a.y+this._dragPoint.y+this.dragOffset.y),this.boundsRect&&this.checkBoundsRect(),this.boundsSprite&&this.checkBoundsSprite(),this.snapOnDrag&&(this.sprite.cameraOffset.x=Math.round((this.sprite.cameraOffset.x-this.snapOffsetX%this.snapX)/this.snapX)*this.snapX+this.snapOffsetX%this.snapX,this.sprite.cameraOffset.y=Math.round((this.sprite.cameraOffset.y-this.snapOffsetY%this.snapY)/this.snapY)*this.snapY+this.snapOffsetY%this.snapY)):(this.allowHorizontalDrag&&(this.sprite.x=a.x+this._dragPoint.x+this.dragOffset.x),this.allowVerticalDrag&&(this.sprite.y=a.y+this._dragPoint.y+this.dragOffset.y),this.boundsRect&&this.checkBoundsRect(),this.boundsSprite&&this.checkBoundsSprite(),this.snapOnDrag&&(this.sprite.x=Math.round((this.sprite.x-this.snapOffsetX%this.snapX)/this.snapX)*this.snapX+this.snapOffsetX%this.snapX,this.sprite.y=Math.round((this.sprite.y-this.snapOffsetY%this.snapY)/this.snapY)*this.snapY+this.snapOffsetY%this.snapY)),!0)},justOver:function(a,b){return a=a||0,b=b||500,this._pointerData[a].isOver&&this.overDuration(a)a;a++)arguments[b]b;b++)a[b]b;b++)a[b]>a[c]&&(c=b);return a[c]},minProperty:function(a){if(2===arguments.length&&\"object\"==typeof arguments[1])var b=arguments[1];else var b=arguments.slice(1);for(var c=1,d=0,e=b.length;e>c;c++)b[c][a]c;c++)b[c][a]>b[d][a]&&(d=c);return b[d][a]},wrapAngle:function(a){return this.wrap(a,-180,180)},angleLimit:function(a,b,c){var d=a;return a>c?d=c:b>a&&(d=b),d},linearInterpolation:function(a,b){var c=a.length-1,d=c*b,e=Math.floor(d);return 0>b?this.linear(a[0],a[1],d):b>1?this.linear(a[c],a[c-1],c-d):this.linear(a[e],a[e+1>c?c:e+1],d-e)},bezierInterpolation:function(a,b){for(var c=0,d=a.length-1,e=0;d>=e;e++)c+=Math.pow(1-b,d-e)*Math.pow(b,e)*a[e]*this.bernstein(d,e);return c},catmullRomInterpolation:function(a,b){var c=a.length-1,d=c*b,e=Math.floor(d);return a[0]===a[c]?(0>b&&(e=Math.floor(d=c*(1+b))),this.catmullRom(a[(e-1+c)%c],a[e],a[(e+1)%c],a[(e+2)%c],d-e)):0>b?a[0]-(this.catmullRom(a[0],a[0],a[1],a[1],-d)-a[0]):b>1?a[c]-(this.catmullRom(a[c],a[c],a[c-1],a[c-1],d-c)-a[c]):this.catmullRom(a[e?e-1:0],a[e],a[e+1>c?c:e+1],a[e+2>c?c:e+2],d-e)},linear:function(a,b,c){return(b-a)*c+a},bernstein:function(a,b){return this.factorial(a)/this.factorial(b)/this.factorial(a-b)},catmullRom:function(a,b,c,d,e){var f=.5*(c-a),g=.5*(d-b),h=e*e,i=e*h;return(2*b-2*c+f+g)*i+(-3*b+3*c-2*f-g)*h+f*e+b},difference:function(a,b){return Math.abs(a-b)},getRandom:function(a,b,c){if(\"undefined\"==typeof b&&(b=0),\"undefined\"==typeof c&&(c=0),null!=a){var d=c;if((0===d||d>a.length-b)&&(d=a.length-b),d>0)return a[b+Math.floor(Math.random()*d)]}return null},floor:function(a){var b=0|a;return a>0?b:b!=a?b-1:b},ceil:function(a){var b=0|a;return a>0?b!=a?b+1:b:b},sinCosGenerator:function(a,b,c,d){\"undefined\"==typeof b&&(b=1),\"undefined\"==typeof c&&(c=1),\"undefined\"==typeof d&&(d=1);for(var e=b,f=c,g=d*Math.PI/a,h=[],i=[],j=0;a>j;j++)f-=e*g,e+=f*g,h[j]=f,i[j]=e;return{sin:i,cos:h,length:a}},shift:function(a){var b=a.shift();return a.push(b),b},shuffleArray:function(a){for(var b=a.length-1;b>0;b--){var c=Math.floor(Math.random()*(b+1)),d=a[b];a[b]=a[c],a[c]=d}return a},distance:function(a,b,c,d){var e=a-c,f=b-d;return Math.sqrt(e*e+f*f)},distancePow:function(a,b,c,d,e){return\"undefined\"==typeof e&&(e=2),Math.sqrt(Math.pow(c-a,e)+Math.pow(d-b,e))},distanceRounded:function(a,b,d,e){return Math.round(c.Math.distance(a,b,d,e))},clamp:function(a,b,c){return b>a?b:a>c?c:a},clampBottom:function(a,b){return b>a?b:a},within:function(a,b,c){return Math.abs(a-b)=a?0:a>=c?1:(a=(a-b)/(c-b),a*a*(3-2*a))},smootherstep:function(a,b,c){return b>=a?0:a>=c?1:(a=(a-b)/(c-b),a*a*a*(a*(6*a-15)+10))},sign:function(a){return 0>a?-1:a>0?1:0},degToRad:function(){var a=Math.PI/180;return function(b){return b*a}}(),radToDeg:function(){var a=180/Math.PI;return function(b){return b*a}}()},c.QuadTree=function(a,b,c,d,e,f,g){this.maxObjects=e||10,this.maxLevels=f||4,this.level=g||0,this.bounds={x:Math.round(a),y:Math.round(b),width:c,height:d,subWidth:Math.floor(c/2),subHeight:Math.floor(d/2),right:Math.round(a)+Math.floor(c/2),bottom:Math.round(b)+Math.floor(d/2)},this.objects=[],this.nodes=[]},c.QuadTree.prototype={populate:function(a){a.forEach(this.populateHandler,this,!0)},populateHandler:function(a){a.body&&a.body.checkCollision.none===!1&&a.alive&&this.insert(a.body)},split:function(){this.level++,this.nodes[0]=new c.QuadTree(this.bounds.right,this.bounds.y,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level),this.nodes[1]=new c.QuadTree(this.bounds.x,this.bounds.y,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level),this.nodes[2]=new c.QuadTree(this.bounds.x,this.bounds.bottom,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level),this.nodes[3]=new c.QuadTree(this.bounds.right,this.bounds.bottom,this.bounds.subWidth,this.bounds.subHeight,this.maxObjects,this.maxLevels,this.level)},insert:function(a){var b,c=0;if(null!=this.nodes[0]&&(b=this.getIndex(a),-1!==b))return this.nodes[b].insert(a),void 0;if(this.objects.push(a),this.objects.length>this.maxObjects&&this.levelthis.x?(this._radius=0,this._diameter=0):this.radius=this.x-a}}),Object.defineProperty(c.Circle.prototype,\"right\",{get:function(){return this.x+this._radius},set:function(a){athis.y?(this._radius=0,this._diameter=0):this.radius=this.y-a}}),Object.defineProperty(c.Circle.prototype,\"bottom\",{get:function(){return this.y+this._radius},set:function(a){a0?Math.PI*this._radius*this._radius:0}}),Object.defineProperty(c.Circle.prototype,\"empty\",{get:function(){return 0===this._diameter},set:function(a){a===!0&&this.setTo(0,0,0)}}),c.Circle.contains=function(a,b,c){if(b>=a.left&&b=a.top&&c=e&&f>=b&&b+d>=f},c.Rectangle.containsPoint=function(a,b){return c.Rectangle.contains(a,b.x,b.y)},c.Rectangle.containsRect=function(a,b){return a.volume>b.volume?!1:a.x>=b.x&&a.y>=b.y&&a.rightMath.pow(a.x-b.x+(a.y-b.y),2))return null;if(Math.pow(g.x-e.x+(g.y-e.y),2)>Math.pow(d.x-e.x+(d.y-e.y),2))return null;if(Math.pow(g.x-d.x+(g.y-d.y),2)>Math.pow(d.x-e.x+(d.y-e.y),2))return null}return g},c.Line.intersects=function(a,b,d,e){return c.Line.intersectsPoints(a.start,a.end,b.start,b.end,d,e)},c.Net=function(a){this.game=a},c.Net.prototype={getHostName:function(){return window.location&&window.location.hostname?window.location.hostname:null},checkDomainName:function(a){return-1!==window.location.hostname.indexOf(a)},updateQueryString:function(a,b,c,d){\"undefined\"==typeof c&&(c=!1),(\"undefined\"==typeof d||\"\"===d)&&(d=window.location.href);var e=\"\",f=new RegExp(\"([?|&])\"+a+\"=.*?(&|#|$)(.*)\",\"gi\");if(f.test(d))e=\"undefined\"!=typeof b&&null!==b?d.replace(f,\"$1\"+a+\"=\"+b+\"$2$3\"):d.replace(f,\"$1$3\").replace(/(&|\\?)$/,\"\");else if(\"undefined\"!=typeof b&&null!==b){var g=-1!==d.indexOf(\"?\")?\"&\":\"?\",h=d.split(\"#\");d=h[0]+g+a+\"=\"+b,h[1]&&(d+=\"#\"+h[1]),e=d}else e=d;return c?(window.location.href=e,void 0):e},getQueryString:function(a){\"undefined\"==typeof a&&(a=\"\");var b={},c=location.search.substring(1).split(\"&\");for(var d in c){var e=c[d].split(\"=\");if(e.length>1){if(a&&a==this.decodeURI(e[0]))return this.decodeURI(e[1]);b[this.decodeURI(e[0])]=this.decodeURI(e[1])}}return b},decodeURI:function(a){return decodeURIComponent(a.replace(/\\+/g,\" \"))}},c.Net.prototype.constructor=c.Net,c.TweenManager=function(a){this.game=a,this._tweens=[],this._add=[],this.game.onPause.add(this.pauseAll,this),this.game.onResume.add(this.resumeAll,this)},c.TweenManager.prototype={getAll:function(){return this._tweens},removeAll:function(){for(var a=0;aa;)this._tweens[a].update(this.game.time.now)?a++:(this._tweens.splice(a,1),b--);return this._add.length>0&&(this._tweens=this._tweens.concat(this._add),this._add.length=0),!0},isTweening:function(a){return this._tweens.some(function(b){return b._object===a})},pauseAll:function(){for(var a=this._tweens.length-1;a>=0;a--)this._tweens[a].pause()},resumeAll:function(){for(var a=this._tweens.length-1;a>=0;a--)this._tweens[a].resume()}},c.TweenManager.prototype.constructor=c.TweenManager,c.Tween=function(a,b){this._object=a,this.game=b,this._manager=this.game.tweens,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._repeat=0,this._yoyo=!1,this._reversed=!1,this._delayTime=0,this._startTime=null,this._easingFunction=c.Easing.Linear.None,this._interpolationFunction=c.Math.linearInterpolation,this._chainedTweens=[],this._onStartCallbackFired=!1,this._onUpdateCallback=null,this._onUpdateCallbackContext=null,this._pausedTime=0,this.pendingDelete=!1;for(var d in a)this._valuesStart[d]=parseFloat(a[d],10);this.onStart=new c.Signal,this.onLoop=new c.Signal,this.onComplete=new c.Signal,this.isRunning=!1},c.Tween.prototype={to:function(a,b,c,d,e,f,g){b=b||1e3,c=c||null,d=d||!1,e=e||0,f=f||0,g=g||!1;var h;return this._parent?(h=this._manager.create(this._object),this._lastChild.chain(h),this._lastChild=h):(h=this,this._parent=this,this._lastChild=this),h._repeat=f,h._duration=b,h._valuesEnd=a,null!==c&&(h._easingFunction=c),e>0&&(h._delayTime=e),h._yoyo=g,d?this.start():this},start:function(){if(null!==this.game&&null!==this._object){this._manager.add(this),this.isRunning=!0,this._onStartCallbackFired=!1,this._startTime=this.game.time.now+this._delayTime;for(var a in this._valuesEnd){if(this._valuesEnd[a]instanceof Array){if(0===this._valuesEnd[a].length)continue;this._valuesEnd[a]=[this._object[a]].concat(this._valuesEnd[a])}this._valuesStart[a]=this._object[a],this._valuesStart[a]instanceof Array==!1&&(this._valuesStart[a]*=1),this._valuesStartRepeat[a]=this._valuesStart[a]||0}return this}},stop:function(){return this.isRunning=!1,this._onUpdateCallback=null,this._manager.remove(this),this},delay:function(a){return this._delayTime=a,this},repeat:function(a){return this._repeat=a,this},yoyo:function(a){return this._yoyo=a,this},easing:function(a){return this._easingFunction=a,this},interpolation:function(a){return this._interpolationFunction=a,this},chain:function(){return this._chainedTweens=arguments,this},loop:function(){return this._lastChild.chain(this),this},onUpdateCallback:function(a,b){return this._onUpdateCallback=a,this._onUpdateCallbackContext=b,this},pause:function(){this._paused=!0,this._pausedTime=this.game.time.now},resume:function(){this._paused=!1,this._startTime+=this.game.time.now-this._pausedTime},update:function(a){if(this.pendingDelete)return!1;if(this._paused||a0){isFinite(this._repeat)&&this._repeat--;for(b in this._valuesStartRepeat){if(\"string\"==typeof this._valuesEnd[b]&&(this._valuesStartRepeat[b]=this._valuesStartRepeat[b]+parseFloat(this._valuesEnd[b],10)),this._yoyo){var g=this._valuesStartRepeat[b];this._valuesStartRepeat[b]=this._valuesEnd[b],this._valuesEnd[b]=g,this._reversed=!this._reversed}this._valuesStart[b]=this._valuesStartRepeat[b]}return this._startTime=a+this._delayTime,this.onLoop.dispatch(this._object),!0}this.isRunning=!1,this.onComplete.dispatch(this._object);for(var h=0,i=this._chainedTweens.length;i>h;h++)this._chainedTweens[h].start(a);return!1}return!0}},c.Tween.prototype.constructor=c.Tween,c.Easing={Linear:{None:function(a){return a}},Quadratic:{In:function(a){return a*a},Out:function(a){return a*(2-a)},InOut:function(a){return(a*=2)0?this.order():(this.expired=!0,this.onComplete.dispatch(this))}return this.expired&&this.autoDestroy?!1:!0},pause:function(){this.running&&!this.expired&&(this._pauseStarted=this.game.time.now,this.paused=!0)},resume:function(){if(this.running&&!this.expired){for(var a=this.game.time.now-this._pauseStarted,b=0;bthis._now?this.nextTick-this._now:0}}),Object.defineProperty(c.Timer.prototype,\"length\",{get:function(){return this.events.length}}),Object.defineProperty(c.Timer.prototype,\"ms\",{get:function(){return this._now}}),Object.defineProperty(c.Timer.prototype,\"seconds\",{get:function(){return.001*this._now}}),c.Timer.prototype.constructor=c.Timer,c.TimerEvent=function(a,b,c,d,e,f,g,h){this.timer=a,this.delay=b,this.tick=c,this.repeatCount=d-1,this.loop=e,this.callback=f,this.callbackContext=g,this.args=h,this.pendingDelete=!1},c.TimerEvent.prototype.constructor=c.TimerEvent,c.AnimationManager=function(a){this.sprite=a,this.game=a.game,this.currentFrame=null,this.updateIfVisible=!0,this.isLoaded=!1,this._frameData=null,this._anims={},this._outputFrames=[]},c.AnimationManager.prototype={loadFrameData:function(a){this._frameData=a,this.frame=0,this.isLoaded=!0},add:function(a,d,e,f,g){return null==this._frameData?(console.warn(\"No FrameData available for Phaser.Animation \"+a),void 0):(e=e||60,\"undefined\"==typeof f&&(f=!1),\"undefined\"==typeof g&&(g=d&&\"number\"==typeof d[0]?!0:!1),null==this.sprite.events.onAnimationStart&&(this.sprite.events.onAnimationStart=new c.Signal,this.sprite.events.onAnimationComplete=new c.Signal,this.sprite.events.onAnimationLoop=new c.Signal),this._outputFrames.length=0,this._frameData.getFrameIndexes(d,g,this._outputFrames),this._anims[a]=new c.Animation(this.game,this.sprite,a,this._frameData,this._outputFrames,e,f),this.currentAnim=this._anims[a],this.currentFrame=this.currentAnim.currentFrame,this.sprite.setTexture(b.TextureCache[this.currentFrame.uuid]),this._anims[a])},validateFrames:function(a,b){\"undefined\"==typeof b&&(b=!0);for(var c=0;cthis._frameData.total)return!1}else if(this._frameData.checkFrameName(a[c])===!1)return!1;return!0},play:function(a,b,c,d){if(this._anims[a]){if(this.currentAnim!=this._anims[a])return this.currentAnim=this._anims[a],this.currentAnim.paused=!1,this.currentAnim.play(b,c,d);if(this.currentAnim.isPlaying===!1)return this.currentAnim.paused=!1,this.currentAnim.play(b,c,d)}},stop:function(a,b){\"undefined\"==typeof b&&(b=!1),\"string\"==typeof a?this._anims[a]&&(this.currentAnim=this._anims[a],this.currentAnim.stop(b)):this.currentAnim&&this.currentAnim.stop(b)},update:function(){return this.updateIfVisible&&this.sprite.visible===!1?!1:this.currentAnim&&this.currentAnim.update()===!0?(this.currentFrame=this.currentAnim.currentFrame,this.sprite.currentFrame=this.currentFrame,!0):!1},getAnimation:function(a){return\"string\"==typeof a&&this._anims[a]?this._anims[a]:null},refreshFrame:function(){this.sprite.currentFrame=this.currentFrame,this.sprite.setTexture(b.TextureCache[this.currentFrame.uuid])},destroy:function(){this._anims={},this._frameData=null,this._frameIndex=0,this.currentAnim=null,this.currentFrame=null}},c.AnimationManager.prototype.constructor=c.AnimationManager,Object.defineProperty(c.AnimationManager.prototype,\"frameData\",{get:function(){return this._frameData}}),Object.defineProperty(c.AnimationManager.prototype,\"frameTotal\",{get:function(){return this._frameData?this._frameData.total:-1}}),Object.defineProperty(c.AnimationManager.prototype,\"paused\",{get:function(){return this.currentAnim.isPaused},set:function(a){this.currentAnim.paused=a}}),Object.defineProperty(c.AnimationManager.prototype,\"frame\",{get:function(){return this.currentFrame?this._frameIndex:void 0},set:function(a){\"number\"==typeof a&&this._frameData&&null!==this._frameData.getFrame(a)&&(this.currentFrame=this._frameData.getFrame(a),this._frameIndex=a,this.sprite.currentFrame=this.currentFrame,this.sprite.setTexture(b.TextureCache[this.currentFrame.uuid]))}}),Object.defineProperty(c.AnimationManager.prototype,\"frameName\",{get:function(){return this.currentFrame?this.currentFrame.name:void 0},set:function(a){\"string\"==typeof a&&this._frameData&&null!==this._frameData.getFrameByName(a)?(this.currentFrame=this._frameData.getFrameByName(a),this._frameIndex=this.currentFrame.index,this.sprite.currentFrame=this.currentFrame,this.sprite.setTexture(b.TextureCache[this.currentFrame.uuid])):console.warn(\"Cannot set frameName: \"+a)}}),c.Animation=function(a,b,c,d,e,f,g){this.game=a,this._parent=b,this._frameData=d,this.name=c,this._frames=[],this._frames=this._frames.concat(e),this.delay=1e3/f,this.looped=g,this.killOnComplete=!1,this.isFinished=!1,this.isPlaying=!1,this.isPaused=!1,this._pauseStartTime=0,this._frameIndex=0,this._frameDiff=0,this._frameSkip=1,this.currentFrame=this._frameData.getFrame(this._frames[this._frameIndex])},c.Animation.prototype={play:function(a,c,d){return\"number\"==typeof a&&(this.delay=1e3/a),\"boolean\"==typeof c&&(this.looped=c),\"undefined\"!=typeof d&&(this.killOnComplete=d),this.isPlaying=!0,this.isFinished=!1,this.paused=!1,this._timeLastFrame=this.game.time.now,this._timeNextFrame=this.game.time.now+this.delay,this._frameIndex=0,this.currentFrame=this._frameData.getFrame(this._frames[this._frameIndex]),this._parent.setTexture(b.TextureCache[this.currentFrame.uuid]),this._parent.events&&this._parent.events.onAnimationStart.dispatch(this._parent,this),this},restart:function(){this.isPlaying=!0,this.isFinished=!1,this.paused=!1,this._timeLastFrame=this.game.time.now,this._timeNextFrame=this.game.time.now+this.delay,this._frameIndex=0,this.currentFrame=this._frameData.getFrame(this._frames[this._frameIndex])},stop:function(a){\"undefined\"==typeof a&&(a=!1),this.isPlaying=!1,this.isFinished=!0,this.paused=!1,a&&(this.currentFrame=this._frameData.getFrame(this._frames[0]))},update:function(){return this.isPaused?!1:this.isPlaying===!0&&this.game.time.now>=this._timeNextFrame?(this._frameSkip=1,this._frameDiff=this.game.time.now-this._timeNextFrame,this._timeLastFrame=this.game.time.now,this._frameDiff>this.delay&&(this._frameSkip=Math.floor(this._frameDiff/this.delay),this._frameDiff-=this._frameSkip*this.delay),this._timeNextFrame=this.game.time.now+(this.delay-this._frameDiff),this._frameIndex+=this._frameSkip,this._frameIndex>=this._frames.length?this.looped?(this._frameIndex%=this._frames.length,this.currentFrame=this._frameData.getFrame(this._frames[this._frameIndex]),this.currentFrame&&this._parent.setTexture(b.TextureCache[this.currentFrame.uuid]),this._parent.events.onAnimationLoop.dispatch(this._parent,this)):this.onComplete():(this.currentFrame=this._frameData.getFrame(this._frames[this._frameIndex]),this.currentFrame&&this._parent.setTexture(b.TextureCache[this.currentFrame.uuid])),!0):!1},destroy:function(){this.game=null,this._parent=null,this._frames=null,this._frameData=null,this.currentFrame=null,this.isPlaying=!1},onComplete:function(){this.isPlaying=!1,this.isFinished=!0,this.paused=!1,this._parent.events&&this._parent.events.onAnimationComplete.dispatch(this._parent,this),this.killOnComplete&&this._parent.kill()}},c.Animation.prototype.constructor=c.Animation,Object.defineProperty(c.Animation.prototype,\"paused\",{get:function(){return this.isPaused},set:function(a){this.isPaused=a,a?this._pauseStartTime=this.game.time.now:this.isPlaying&&(this._timeNextFrame=this.game.time.now+this.delay)}}),Object.defineProperty(c.Animation.prototype,\"frameTotal\",{get:function(){return this._frames.length}}),Object.defineProperty(c.Animation.prototype,\"frame\",{get:function(){return null!==this.currentFrame?this.currentFrame.index:this._frameIndex},set:function(a){this.currentFrame=this._frameData.getFrame(a),null!==this.currentFrame&&(this._frameIndex=a,this._parent.setTexture(b.TextureCache[this.currentFrame.uuid]))}}),c.Animation.generateFrameNames=function(a,b,d,e,f){\"undefined\"==typeof e&&(e=\"\");var g=[],h=\"\";if(d>b)for(var i=b;d>=i;i++)h=\"number\"==typeof f?c.Utils.pad(i.toString(),f,\"0\",1):i.toString(),h=a+h+e,g.push(h);else for(var i=b;i>=d;i--)h=\"number\"==typeof f?c.Utils.pad(i.toString(),f,\"0\",1):i.toString(),h=a+h+e,g.push(h);return g},c.Frame=function(a,b,d,e,f,g,h){this.index=a,this.x=b,this.y=d,this.width=e,this.height=f,this.name=g,this.uuid=h,this.centerX=Math.floor(e/2),this.centerY=Math.floor(f/2),this.distance=c.Math.distance(0,0,e,f),this.rotated=!1,this.rotationDirection=\"cw\",this.trimmed=!1,this.sourceSizeW=e,this.sourceSizeH=f,this.spriteSourceSizeX=0,this.spriteSourceSizeY=0,this.spriteSourceSizeW=0,this.spriteSourceSizeH=0},c.Frame.prototype={setTrim:function(a,b,c,d,e,f,g){this.trimmed=a,a&&(this.width=b,this.height=c,this.sourceSizeW=b,this.sourceSizeH=c,this.centerX=Math.floor(b/2),this.centerY=Math.floor(c/2),this.spriteSourceSizeX=d,this.spriteSourceSizeY=e,this.spriteSourceSizeW=f,this.spriteSourceSizeH=g)}},c.Frame.prototype.constructor=c.Frame,c.FrameData=function(){this._frames=[],this._frameNames=[]},c.FrameData.prototype={addFrame:function(a){return a.index=this._frames.length,this._frames.push(a),\"\"!==a.name&&(this._frameNames[a.name]=a.index),a},getFrame:function(a){return this._frames.length>a?this._frames[a]:null},getFrameByName:function(a){return\"number\"==typeof this._frameNames[a]?this._frames[this._frameNames[a]]:null},checkFrameName:function(a){return null==this._frameNames[a]?!1:!0},getFrameRange:function(a,b,c){\"undefined\"==typeof c&&(c=[]);for(var d=a;b>=d;d++)c.push(this._frames[d]);return c},getFrames:function(a,b,c){if(\"undefined\"==typeof b&&(b=!0),\"undefined\"==typeof c&&(c=[]),\"undefined\"==typeof a||0===a.length)for(var d=0;dd;d++)b?c.push(this.getFrame(a[d])):c.push(this.getFrameByName(a[d]));return c},getFrameIndexes:function(a,b,c){if(\"undefined\"==typeof b&&(b=!0),\"undefined\"==typeof c&&(c=[]),\"undefined\"==typeof a||0===a.length)for(var d=0,e=this._frames.length;e>d;d++)c.push(this._frames[d].index);else for(var d=0,e=a.length;e>d;d++)b?c.push(a[d]):this.getFrameByName(a[d])&&c.push(this.getFrameByName(a[d]).index);return c}},c.FrameData.prototype.constructor=c.FrameData,Object.defineProperty(c.FrameData.prototype,\"total\",{get:function(){return this._frames.length}}),c.AnimationParser={spriteSheet:function(a,d,e,f,g,h,i){var j=a.cache.getImage(d);if(null==j)return null;var k=j.width,l=j.height;0>=e&&(e=Math.floor(-k/Math.min(-1,e))),0>=f&&(f=Math.floor(-l/Math.min(-1,f)));var m=Math.round(k/e),n=Math.round(l/f),o=m*n;if(-1!==g&&(o=g),0===k||0===l||e>k||f>l||0===o)return console.warn(\"Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight\"),null;for(var p=new c.FrameData,q=h,r=h,s=0;o>s;s++){var t=a.rnd.uuid();p.addFrame(new c.Frame(s,q,r,e,f,\"\",t)),b.TextureCache[t]=new b.Texture(b.BaseTextureCache[d],{x:q,y:r,width:e,height:f}),q+=e+i,q===k&&(q=h,r+=f+i)}return p},JSONData:function(a,d,e){if(!d.frames)return console.warn(\"Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array\"),console.log(d),void 0;for(var f,g=new c.FrameData,h=d.frames,i=0;i0?(this._fileIndex++,this.loadFile()):(this.hasLoaded=!0,this.isLoading=!1,this.removeAll(),this.onLoadComplete.dispatch())},totalLoadedFiles:function(){for(var a=0,b=0;b=a&&(this._volume=a,this._sound.volume=a)}}),c.SoundManager=function(a){this.game=a,this.onSoundDecode=new c.Signal,this._muted=!1,this._unlockSource=null,this._volume=1,this._sounds=[],this.context=null,this.usingWebAudio=!0,this.usingAudioTag=!1,this.noAudio=!1,this.connectToMaster=!0,this.touchLocked=!1,this.channels=32},c.SoundManager.prototype={boot:function(){if(this.game.device.iOS&&this.game.device.webAudio===!1&&(this.channels=1),this.game.device.iOS||window.PhaserGlobal&&window.PhaserGlobal.fakeiOSTouchLock?(this.game.input.touch.callbackContext=this,this.game.input.touch.touchStartCallback=this.unlock,this.game.input.mouse.callbackContext=this,this.game.input.mouse.mouseDownCallback=this.unlock,this.touchLocked=!0):this.touchLocked=!1,window.PhaserGlobal){if(window.PhaserGlobal.disableAudio===!0)return this.usingWebAudio=!1,this.noAudio=!0,void 0;if(window.PhaserGlobal.disableWebAudio===!0)return this.usingWebAudio=!1,this.usingAudioTag=!0,this.noAudio=!1,void 0}window.AudioContext?this.context=new window.AudioContext:window.webkitAudioContext?this.context=new window.webkitAudioContext:window.Audio?(this.usingWebAudio=!1,this.usingAudioTag=!0):(this.usingWebAudio=!1,this.noAudio=!0),null!==this.context&&(this.masterGain=\"undefined\"==typeof this.context.createGain?this.context.createGainNode():this.context.createGain(),this.masterGain.gain.value=1,this.masterGain.connect(this.context.destination))},unlock:function(){if(this.touchLocked!==!1)if(this.game.device.webAudio===!1||window.PhaserGlobal&&window.PhaserGlobal.disableWebAudio===!0)this.touchLocked=!1,this._unlockSource=null,this.game.input.touch.callbackContext=null,this.game.input.touch.touchStartCallback=null,this.game.input.mouse.callbackContext=null,this.game.input.mouse.mouseDownCallback=null;else{var a=this.context.createBuffer(1,1,22050);this._unlockSource=this.context.createBufferSource(),this._unlockSource.buffer=a,this._unlockSource.connect(this.context.destination),this._unlockSource.noteOn(0)}},stopAll:function(){for(var a=0;ag;g++){var h=a[g].dot(b);d>h&&(d=h),h>e&&(e=h)}c[0]=d,c[1]=e}function g(a,b,c,d,e,g){var h=p.pop(),i=p.pop(),j=n.pop().copy(b).sub(a),k=j.dot(e);if(f(c,e,h),f(d,e,i),i[0]+=k,i[1]+=k,h[0]>i[1]||i[0]>h[1])return n.push(j),p.push(h),p.push(i),!0;if(g){var l=0;if(h[0]i[1])l=h[0]-i[1],g.aInB=!1;else{var m=h[1]-i[0],o=i[1]-h[0];l=o>m?m:-o}var q=Math.abs(l);ql&&g.overlapN.reverse())}return n.push(j),p.push(h),p.push(i),!1}function h(a,b){var c=a.len2(),d=b.dot(a);return 0>d?q:d>c?s:r}function i(a,b,c){var d=n.pop().copy(b.pos).sub(a.pos),e=a.r+b.r,f=e*e,g=d.len2();if(g>f)return n.push(d),!1;if(c){var h=Math.sqrt(g);c.a=a,c.b=b,c.overlap=e-h,c.overlapN.copy(d.normalize()),c.overlapV.copy(d).scale(c.overlap),c.aInB=a.re)return n.push(d),n.push(j),n.push(k),!1;c&&(c.bInA=!1,r=k.normalize(),p=e-v)}}else{var w=j.perp().normalize(),v=k.dot(w),x=Math.abs(v);if(v>0&&x>e)return n.push(d),n.push(w),n.push(k),!1; c&&(r=w,p=e-v,(v>=0||2*e>p)&&(c.bInA=!1))}r&&c&&Math.abs(p)i;i++)if(g(a.pos,b.pos,d,f,a.normals[i],c))return!1;for(var i=0;h>i;i++)if(g(a.pos,b.pos,d,f,b.normals[i],c))return!1;return c&&(c.a=a,c.b=b,c.overlapV.copy(c.overlapN).scale(c.overlap)),!0}var m={};m.Vector=a,m.V=a,a.prototype.copy=a.prototype.copy=function(a){return this.x=a.x,this.y=a.y,this},a.prototype.perp=a.prototype.perp=function(){var a=this.x;return this.x=this.y,this.y=-a,this},a.prototype.rotate=a.prototype.rotate=function(a){var b=this.x,c=this.y;return this.x=b*Math.cos(a)-c*Math.sin(a),this.y=b*Math.sin(a)+c*Math.cos(a),this},a.prototype.rotatePrecalc=a.prototype.rotatePrecalc=function(a,b){var c=this.x,d=this.y;return this.x=c*b-d*a,this.y=c*a+d*b,this},a.prototype.reverse=a.prototype.reverse=function(){return this.x=-this.x,this.y=-this.y,this},a.prototype.normalize=a.prototype.normalize=function(){var a=this.len();return a>0&&(this.x=this.x/a,this.y=this.y/a),this},a.prototype.add=a.prototype.add=function(a){return this.x+=a.x,this.y+=a.y,this},a.prototype.sub=a.prototype.sub=function(a){return this.x-=a.x,this.y-=a.y,this},a.prototype.scale=a.prototype.scale=function(a,b){return this.x*=a,this.y*=b||a,this},a.prototype.project=a.prototype.project=function(a){var b=this.dot(a)/a.len2();return this.x=b*a.x,this.y=b*a.y,this},a.prototype.projectN=a.prototype.projectN=function(a){var b=this.dot(a);return this.x=b*a.x,this.y=b*a.y,this},a.prototype.reflect=a.prototype.reflect=function(a){var b=this.x,c=this.y;return this.project(a).scale(2),this.x-=b,this.y-=c,this},a.prototype.reflectN=a.prototype.reflectN=function(a){var b=this.x,c=this.y;return this.projectN(a).scale(2),this.x-=b,this.y-=c,this},a.prototype.dot=a.prototype.dot=function(a){return this.x*a.x+this.y*a.y},a.prototype.len2=a.prototype.len2=function(){return this.dot(this)},a.prototype.len=a.prototype.len=function(){return Math.sqrt(this.len2())},m.Circle=b,m.Polygon=c,c.prototype.recalc=c.prototype.recalc=function(){this.edges=[],this.normals=[];for(var b=this.points,c=b.length,d=0;c>d;d++){var e=b[d],f=c-1>d?b[d+1]:b[0],g=(new a).copy(f).sub(e),h=(new a).copy(g).perp().normalize();this.edges.push(g),this.normals.push(h)}return this},c.prototype.rotate=c.prototype.rotate=function(a){var b,c=this.points,d=this.edges,e=this.normals,f=c.length,g=Math.cos(a),h=Math.sin(a);for(b=0;f>b;b++)c[b].rotatePrecalc(h,g),d[b].rotatePrecalc(h,g),e[b].rotatePrecalc(h,g);return this},c.prototype.scale=c.prototype.scale=function(a,b){var c,d=this.points,e=this.edges,f=this.normals,g=d.length;for(c=0;g>c;c++)d[c].scale(a,b),e[c].scale(a,b),f[c].scale(a,b);return this},c.prototype.translate=c.prototype.translate=function(a,b){var c,d=this.points,e=d.length;for(c=0;e>c;c++)d[c].x+=a,d[c].y+=b;return this},m.Box=d,d.prototype.toPolygon=d.prototype.toPolygon=function(){var b=this.pos,d=this.w,e=this.h;return new c(new a(b.x,b.y),[new a,new a(d,0),new a(d,e),new a(0,e)])},m.Response=e,e.prototype.clear=e.prototype.clear=function(){return this.aInB=!0,this.bInA=!0,this.overlap=Number.MAX_VALUE,this};for(var n=[],o=0;10>o;o++)n.push(new a);for(var p=[],o=0;5>o;o++)p.push([]);var q=-1,r=0,s=1;return m.testCircleCircle=i,m.testPolygonCircle=j,m.testCirclePolygon=k,m.testPolygonPolygon=l,m}();return c.Physics={},c.Physics.Arcade=function(a){this.game=a,this.gravity=new c.Point,this.worldLeft=null,this.worldRight=null,this.worldTop=null,this.worldBottom=null,this.worldPolys=[null,null,null,null],this.quadTree=new c.QuadTree(this.game.world.bounds.x,this.game.world.bounds.y,this.game.world.bounds.width,this.game.world.bounds.height,this.maxObjects,this.maxLevels),this.maxObjects=10,this.maxLevels=4,this._mapData=[],this._mapTiles=0,this._result=!1,this._total=0,this._angle=0,this._drag=0,this._dx=0,this._dy=0,this._p=new c.Point(0,0),this._intersection=[0,0,0,0],this._gravityX=0,this._gravityY=0,this._response=new f.Response,this.setBoundsToWorld(!0,!0,!0,!0)},c.Physics.Arcade.RECT=0,c.Physics.Arcade.CIRCLE=1,c.Physics.Arcade.POLYGON=2,c.Physics.Arcade.prototype={checkBounds:function(a){if(!a.collideWorldBounds||!this.worldLeft&&!this.worldRight&&!this.worldTop&&!this.worldBottom)return!1;this._response.clear();var b=f.testPolygonPolygon,d=a.polygon,e=!1;return a.type===c.Physics.Arcade.CIRCLE&&(b=f.testPolygonCircle,d=a.shape),this.worldLeft&&b(this.worldPolys[0],d,this._response)?(a.blocked.left=!0,d.pos.add(this._response.overlapV),a.blocked.x=Math.floor(a.x),a.blocked.y=Math.floor(a.y),e=!0):this.worldRight&&b(this.worldPolys[1],d,this._response)&&(a.blocked.right=!0,d.pos.add(this._response.overlapV),a.blocked.x=Math.floor(a.x),a.blocked.y=Math.floor(a.y),e=!0),this._response.clear(),this.worldTop&&b(this.worldPolys[2],d,this._response)?(a.blocked.up=!0,d.pos.add(this._response.overlapV),a.blocked.x=Math.floor(a.x),a.blocked.y=Math.floor(a.y),e=!0):this.worldBottom&&b(this.worldPolys[3],d,this._response)&&(a.blocked.down=!0,d.pos.add(this._response.overlapV),a.blocked.x=Math.floor(a.x),a.blocked.y=Math.floor(a.y),e=!0),e},setBoundsToWorld:function(a,b,c,d){this.setBounds(this.game.world.bounds.x,this.game.world.bounds.y,this.game.world.bounds.width,this.game.world.bounds.height,a,b,c,d)},setBounds:function(a,b,c,d,e,g,h,i){\"undefined\"==typeof e&&(e=!0),\"undefined\"==typeof g&&(g=!0),\"undefined\"==typeof h&&(h=!0),\"undefined\"==typeof i&&(i=!0);var j=100;e?(this.worldLeft=new f.Box(new f.Vector(a-j,b),j,d),this.worldPolys[0]=this.worldLeft.toPolygon()):(this.worldLeft=null,this.worldPolys[0]=null),g?(this.worldRight=new f.Box(new f.Vector(a+c,b),j,d),this.worldPolys[1]=this.worldRight.toPolygon()):(this.worldRight=null,this.worldPolys[1]=null),h?(this.worldTop=new f.Box(new f.Vector(a,b-j),c,j),this.worldPolys[2]=this.worldTop.toPolygon()):(this.worldTop=null,this.worldPolys[2]=null),i?(this.worldBottom=new f.Box(new f.Vector(a,b+d),c,j),this.worldPolys[3]=this.worldBottom.toPolygon()):(this.worldBottom=null,this.worldPolys[3]=null)},updateMotion:function(a){return a.allowGravity?(this._gravityX=this.gravity.x+a.gravity.x,this._gravityY=this.gravity.y+a.gravity.y):(this._gravityX=a.gravity.x,this._gravityY=a.gravity.y),(this._gravityX0&&a.blocked.right)&&(this._gravityX=0),(this._gravityY0&&a.blocked.down)&&(this._gravityY=0),a.allowRotation&&(this._velocityDelta=a.angularAcceleration*this.game.time.physicsElapsed,0!==a.angularDrag&&0===a.angularAcceleration&&(this._drag=a.angularDrag*this.game.time.physicsElapsed,a.angularVelocity>0?a.angularVelocity-=this._drag:a.angularVelocitya.maxAngular?a.angularVelocity=a.maxAngular:a.angularVelocityf;f++)this.collideHandler(a,b[f],c,d,e,!0);else this.collideHandler(a,b,c,d,e,!0);return this._total>0},collide:function(a,b,c,d,e){if(c=c||null,d=d||null,e=e||c,this._result=!1,this._total=0,Array.isArray(b))for(var f=0,g=b.length;g>f;f++)this.collideHandler(a,b[f],c,d,e,!1);else this.collideHandler(a,b,c,d,e,!1);return this._total>0},collideHandler:function(a,b,d,e,f,g){return\"undefined\"!=typeof b||a.type!==c.GROUP&&a.type!==c.EMITTER?(a&&b&&a.exists&&b.exists&&(a.type==c.SPRITE||a.type==c.TILESPRITE?b.type==c.SPRITE||b.type==c.TILESPRITE?this.collideSpriteVsSprite(a,b,d,e,f,g):b.type==c.GROUP||b.type==c.EMITTER?this.collideSpriteVsGroup(a,b,d,e,f,g):b.type==c.TILEMAPLAYER&&this.collideSpriteVsTilemapLayer(a,b,d,e,f):a.type==c.GROUP?b.type==c.SPRITE||b.type==c.TILESPRITE?this.collideSpriteVsGroup(b,a,d,e,f,g):b.type==c.GROUP||b.type==c.EMITTER?this.collideGroupVsGroup(a,b,d,e,f,g):b.type==c.TILEMAPLAYER&&this.collideGroupVsTilemapLayer(a,b,d,e,f):a.type==c.TILEMAPLAYER?b.type==c.SPRITE||b.type==c.TILESPRITE?this.collideSpriteVsTilemapLayer(b,a,d,e,f):(b.type==c.GROUP||b.type==c.EMITTER)&&this.collideGroupVsTilemapLayer(b,a,d,e,f):a.type==c.EMITTER&&(b.type==c.SPRITE||b.type==c.TILESPRITE?this.collideSpriteVsGroup(b,a,d,e,f,g):b.type==c.GROUP||b.type==c.EMITTER?this.collideGroupVsGroup(a,b,d,e,f,g):b.type==c.TILEMAPLAYER&&this.collideGroupVsTilemapLayer(a,b,d,e,f))),void 0):(this.collideGroupVsSelf(a,d,e,f,g),void 0)},collideSpriteVsSprite:function(a,b,c,d,e,f){this.separate(a.body,b.body,d,e,f)&&(c&&c.call(e,a,b),this._total++)},collideSpriteVsGroup:function(a,b,d,e,f,g){if(0!==b.length){this.quadTree.clear(),this.quadTree=new c.QuadTree(this.game.world.bounds.x,this.game.world.bounds.y,this.game.world.bounds.width,this.game.world.bounds.height,this.maxObjects,this.maxLevels),this.quadTree.populate(b),this._potentials=this.quadTree.retrieve(a);for(var h=0,i=this._potentials.length;i>h;h++)this.separate(a.body,this._potentials[h],e,f,g)&&(d&&d.call(f,a,this._potentials[h].sprite),this._total++)}},collideGroupVsSelf:function(a,b,c,d,e){if(0!==a.length)for(var f=a._container.children.length,g=0;f>g;g++)for(var h=g+1;f>=h;h++)a._container.children[g]&&a._container.children[h]&&a._container.children[g].exists&&a._container.children[h].exists&&this.collideSpriteVsSprite(a._container.children[g],a._container.children[h],b,c,d,e)},collideGroupVsGroup:function(a,b,c,d,e,f){if(0!==a.length&&0!==b.length&&a._container.first._iNext){var g=a._container.first._iNext;do g.exists&&this.collideSpriteVsGroup(g,b,c,d,e,f),g=g._iNext;while(g!=a._container.last._iNext)}},collideSpriteVsTilemapLayer:function(a,b,c,d,e){if(this._mapData=b.getTiles(a.body.left,a.body.top,a.body.width,a.body.height,!0),0!==this._mapData.length)if(this._mapData.length>1)this.separateTiles(a.body,this._mapData);else{var f=0;this.separateTile(a.body,this._mapData[f])&&(d?d.call(e,a,this._mapData[f])&&(this._total++,c&&c.call(e,a,this._mapData[f])):(this._total++,c&&c.call(e,a,this._mapData[f])))}},collideGroupVsTilemapLayer:function(a,b,c,d,e){if(0!==a.length&&a._container.first._iNext){var f=a._container.first._iNext;do f.exists&&this.collideSpriteVsTilemapLayer(f,b,c,d,e),f=f._iNext;while(f!=a._container.last._iNext)}},separate:function(a,b,c,d,e){return a===b||this.intersects(a,b)===!1?!1:c&&c.call(d,a.sprite,b.sprite)===!1?!1:(this._response.clear(),e?a.overlap(b,this._response):a.overlap(b,this._response)?a.separate(b,this._response):!1)},intersects:function(a,b){var c=!1;(a.width=0&&this.velocity.y0))&&(this.velocity.y=0)}},getUpwardForce:function(){return this.allowGravity?this.gravity.x+this.game.physics.gravity.x+this.velocity.x:this.gravity.x+this.velocity.x},getDownwardForce:function(){return this.allowGravity?this.gravity.y+this.game.physics.gravity.y+this.velocity.y:this.gravity.y+this.velocity.y},sub:function(a){this.x-=a.x,this.y-=a.y},add:function(a){this.x+=a.x,this.y+=a.y},give:function(a,b){this.add(b.overlapV),this.rebound&&(this.processRebound(a),this.reboundCheck(!0,!0,!1),a.reboundCheck(!0,!0,!1))},take:function(a,b){this.sub(b.overlapV),this.rebound&&(this.processRebound(a),this.reboundCheck(!0,!0,!1),a.reboundCheck(!0,!0,!1))},split:function(a,b){b.overlapV.scale(.5),this.sub(b.overlapV),a.add(b.overlapV),this.rebound&&(this.exchange(a),this.reboundCheck(!0,!0,!1),a.reboundCheck(!0,!0,!1))},exchange:function(a){if(this.mass===a.mass&&this.speed>0&&a.speed>0)this._dx=a.velocity.x,this._dy=a.velocity.y,a.velocity.x=this.velocity.x*a.bounce.x,a.velocity.y=this.velocity.y*a.bounce.x,this.velocity.x=this._dx*this.bounce.x,this.velocity.y=this._dy*this.bounce.y;else{var b=Math.sqrt(a.velocity.x*a.velocity.x*a.mass/this.mass)*(a.velocity.x>0?1:-1),c=Math.sqrt(this.velocity.x*this.velocity.x*this.mass/a.mass)*(this.velocity.x>0?1:-1),d=.5*(b+c);b-=d,c-=d,this.velocity.x=b,a.velocity.x=c,b=Math.sqrt(a.velocity.y*a.velocity.y*a.mass/this.mass)*(a.velocity.y>0?1:-1),c=Math.sqrt(this.velocity.y*this.velocity.y*this.mass/a.mass)*(this.velocity.y>0?1:-1),d=.5*(b+c),b-=d,c-=d,this.velocity.y=b,a.velocity.y=c}},processRebound:function(a){this._vx0||this._vx>=0&&this.velocity.x=0&&this.velocity.y1||this.height>1?a.reset(this.game.rnd.integerInRange(this.left,this.right),this.game.rnd.integerInRange(this.top,this.bottom)):a.reset(this.emitX,this.emitY),a.lifespan=this.lifespan,a.body.bounce.setTo(this.bounce.x,this.bounce.y),a.body.velocity.x=this.minParticleSpeed.x!=this.maxParticleSpeed.x?this.game.rnd.integerInRange(this.minParticleSpeed.x,this.maxParticleSpeed.x):this.minParticleSpeed.x,a.body.velocity.y=this.minParticleSpeed.y!=this.maxParticleSpeed.y?this.game.rnd.integerInRange(this.minParticleSpeed.y,this.maxParticleSpeed.y):this.minParticleSpeed.y,a.body.gravity.y=this.gravity,a.body.angularVelocity=this.minRotation!=this.maxRotation?this.game.rnd.integerInRange(this.minRotation,this.maxRotation):this.minRotation,1!==this.minParticleScale||1!==this.maxParticleScale){var b=this.game.rnd.realInRange(this.minParticleScale,this.maxParticleScale);a.scale.setTo(b,b)}a.body.friction=this.particleFriction,a.body.angularDrag=this.angularDrag}},c.Particles.Arcade.Emitter.prototype.setSize=function(a,b){this.width=a,this.height=b},c.Particles.Arcade.Emitter.prototype.setXSpeed=function(a,b){a=a||0,b=b||0,this.minParticleSpeed.x=a,this.maxParticleSpeed.x=b},c.Particles.Arcade.Emitter.prototype.setYSpeed=function(a,b){a=a||0,b=b||0,this.minParticleSpeed.y=a,this.maxParticleSpeed.y=b},c.Particles.Arcade.Emitter.prototype.setRotation=function(a,b){a=a||0,b=b||0,this.minRotation=a,this.maxRotation=b},c.Particles.Arcade.Emitter.prototype.at=function(a){a.center&&(this.emitX=a.center.x,this.emitY=a.center.y)},Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"alpha\",{get:function(){return this._container.alpha},set:function(a){this._container.alpha=a}}),Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"visible\",{get:function(){return this._container.visible},set:function(a){this._container.visible=a}}),Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"x\",{get:function(){return this.emitX},set:function(a){this.emitX=a}}),Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"y\",{get:function(){return this.emitY},set:function(a){this.emitY=a}}),Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"left\",{get:function(){return Math.floor(this.x-this.width/2)}}),Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"right\",{get:function(){return Math.floor(this.x+this.width/2)}}),Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"top\",{get:function(){return Math.floor(this.y-this.height/2)}}),Object.defineProperty(c.Particles.Arcade.Emitter.prototype,\"bottom\",{get:function(){return Math.floor(this.y+this.height/2)}}),c.Tile=function(a,b,c,d,e,f){this.layer=a,this.index=b,this.x=c,this.y=d,this.width=e,this.height=f,this.alpha=1,this.properties={},this.scanned=!1,this.faceTop=!1,this.faceBottom=!1,this.faceLeft=!1,this.faceRight=!1,this.collides=!1,this.collideNone=!0,this.collideLeft=!1,this.collideRight=!1,this.collideUp=!1,this.collideDown=!1,this.callback=null,this.callbackContext=this},c.Tile.prototype={setCollisionCallback:function(a,b){this.collisionCallbackContext=b,this.collisionCallback=a},destroy:function(){this.collisionCallback=null,this.collisionCallbackContext=null,this.properties=null},setCollision:function(a,b,c,d){this.collideLeft=a,this.collideRight=b,this.collideUp=c,this.collideDown=d,this.collideNone=a||b||c||d?!1:!0},resetCollision:function(){this.collideNone=!0,this.collideLeft=!1,this.collideRight=!1,this.collideUp=!1,this.collideDown=!1},copy:function(a){this.index=a.index,this.alpha=a.alpha,this.properties=a.properties,this.collides=a.collides,this.collideNone=a.collideNone,this.collideUp=a.collideUp,this.collideDown=a.collideDown,this.collideLeft=a.collideLeft,this.collideRight=a.collideRight,this.collisionCallback=a.collisionCallback,this.collisionCallbackContext=a.collisionCallbackContext}},c.Tile.prototype.constructor=c.Tile,Object.defineProperty(c.Tile.prototype,\"canCollide\",{get:function(){return this.collides||this.collisionCallback||this.layer.callbacks[this.index]}}),Object.defineProperty(c.Tile.prototype,\"left\",{get:function(){return this.x}}),Object.defineProperty(c.Tile.prototype,\"right\",{get:function(){return this.x+this.width}}),Object.defineProperty(c.Tile.prototype,\"top\",{get:function(){return this.y}}),Object.defineProperty(c.Tile.prototype,\"bottom\",{get:function(){return this.y+this.height}}),c.Tilemap=function(a,b){this.game=a,this.key=b;var d=c.TilemapParser.parse(this.game,b);null!==d&&(this.width=d.width,this.height=d.height,this.tileWidth=d.tileWidth,this.tileHeight=d.tileHeight,this.orientation=d.orientation,this.version=d.version,this.properties=d.properties,this.widthInPixels=d.widthInPixels,this.heightInPixels=d.heightInPixels,this.layers=d.layers,this.tilesets=d.tilesets,this.tiles=d.tiles,this.objects=d.objects,this.images=d.images,this.currentLayer=0,this.debugMap=[],this._results=[],this._tempA=0,this._tempB=0)},c.Tilemap.CSV=0,c.Tilemap.TILED_JSON=1,c.Tilemap.prototype={create:function(a,b,d){for(var e=[],f=0;d>f;f++){e[f]=[];for(var g=0;b>g;g++)e[f][g]=0}this.layers.push({name:a,width:b,height:d,alpha:1,visible:!0,tileMargin:0,tileSpacing:0,format:c.Tilemap.CSV,data:e,indexes:[],dirty:!0}),this.currentLayer=this.layers.length-1},addTilesetImage:function(a,b){if(\"undefined\"==typeof b){if(\"string\"!=typeof a)return!1;b=a}return\"string\"==typeof a&&(a=this.getTilesetIndex(a)),this.tilesets[a]?(this.tilesets[a].image=this.game.cache.getImage(b),!0):!1},createFromObjects:function(a,b,c,d,e,f,g){if(\"undefined\"==typeof e&&(e=!0),\"undefined\"==typeof f&&(f=!0),\"undefined\"==typeof g&&(g=this.game.world),!this.objects[a])return console.warn(\"Tilemap.createFromObjects: Invalid objectgroup name given: \"+a),void 0;for(var h,i=0,j=this.objects[a].length;j>i;i++)if(this.objects[a][i].gid===b){h=g.create(this.objects[a][i].x,this.objects[a][i].y,c,d,e),h.anchor.setTo(0,1),h.name=this.objects[a][i].name,h.visible=this.objects[a][i].visible,h.autoCull=f;for(property in this.objects[a][i].properties)g.set(h,property,this.objects[a][i].properties[property],!1,!1,0)}},createLayer:function(a,b,d,e){\"undefined\"==typeof b&&(b=this.game.width),\"undefined\"==typeof d&&(d=this.game.height),\"undefined\"==typeof e&&(e=this.game.world);var f=a;return\"string\"==typeof a&&(f=this.getLayerIndex(a)),null===f||f>this.layers.length?(console.warn(\"Tilemap.createLayer: Invalid layer ID given: \"+f),void 0):e.add(new c.TilemapLayer(this.game,this,f,b,d))},getIndex:function(a,b){for(var c=0;ce;e++)this.layers[d].callbacks[a[e]]={callback:b,callbackContext:c}},setTileLocationCallback:function(a,b,c,d,e,f,g){if(g=this.getLayer(g),this.copy(a,b,c,d,g),!(this._results.lengthb)){for(var e=a;b>=e;e++)this.setCollisionByIndex(e,c,d,!1);this.calculateFaces(d)}},setCollisionByExclusion:function(a,b,c){\"undefined\"==typeof b&&(b=!0),c=this.getLayer(c);for(var d=0,e=this.tiles.length;e>d;d++)-1===a.indexOf(d)&&this.setCollisionByIndex(d,b,c,!1);this.calculateFaces(c)},setCollisionByIndex:function(a,b,c,d){\"undefined\"==typeof b&&(b=!0),\"undefined\"==typeof c&&(c=this.currentLayer),\"undefined\"==typeof d&&(d=!0);for(var e=0;eh;h++){var j=this.layers[a].data[f][h];j&&(b=this.getTileAbove(a,h,f),c=this.getTileBelow(a,h,f),d=this.getTileLeft(a,h,f),e=this.getTileRight(a,h,f),b&&b.collides&&(j.faceTop=!1),c&&c.collides&&(j.faceBottom=!1),d&&d.collides&&(j.faceLeft=!1),e&&e.collides&&(j.faceRight=!1))}},getTileAbove:function(a,b,c){return c>0?this.layers[a].data[c-1][b]:null},getTileBelow:function(a,b,c){return c0?this.layers[a].data[c][b-1]:null},getTileRight:function(a,b,c){return b=0&&b=0&&d=0&&a=0&&ba&&(a=0),0>b&&(b=0),c>this.layers[e].width&&(c=this.layers[e].width),d>this.layers[e].height&&(d=this.layers[e].height),this._results.length=0,this._results.push({x:a,y:b,width:c,height:d,layer:e});for(var f=b;b+d>f;f++)for(var g=a;a+c>g;g++)this._results.push(this.layers[e].data[f][g]);return this._results},paste:function(a,b,c,d){if(\"undefined\"==typeof a&&(a=0),\"undefined\"==typeof b&&(b=0),d=this.getLayer(d),c&&!(c.lengthl||e>m||0===j?(console.warn(\"Phaser.TilemapParser.tileSet: width/height zero or width/height < given tileWidth/tileHeight\"),null):new c.Tileset(k,b,d,e,f,g,h,i,j)},parse:function(a,b){var d=a.cache.getTilemapData(b);return d?d.format===c.Tilemap.CSV?this.parseCSV(d.data):d.format===c.Tilemap.TILED_JSON?this.parseTiledJSON(d.data):void 0:{layers:[],objects:[],images:[],tilesets:[]}},parseCSV:function(a){a=a.trim();for(var b=[],c=a.split(\"\\n\"),d=c.length,e=0,f=0;f"}],"posts":[{"title":"AFO","slug":"AFO","date":"2020-06-28T14:21:36.000Z","updated":"2020-08-28T14:22:05.610Z","comments":true,"path":"2020/06/28/AFO/","link":"","permalink":"https://buzhibujue.cf/2020/06/28/AFO/","excerpt":"","text":"AFO","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/tags/随笔/"}]},{"title":"LOJ2474","slug":"loj2474","date":"2020-04-26T04:00:00.000Z","updated":"2020-05-03T15:33:14.000Z","comments":true,"path":"2020/04/26/loj2474/","link":"","permalink":"https://buzhibujue.cf/2020/04/26/loj2474/","excerpt":"","text":"LOJ2474 Description对于一颗树 $T$，定义无向简单图 $G(T)$ 中上的两点 $u,v$ 之间有边当且仅当 $T$ 中 $u,v$ 之间的路径上的所有点编号都小于 $u,v$。 有一棵树 $T$，初始时只有一个点，编号为 $1$，接下来有 $q$ 次操作，操作有以下两种： $1\\ u\\ v$ 表示加入一个编号为 $v$ 的节点并与当前编号为 $u$ 的节点相连（保证任何时刻不会有两个编号相同的节点）； $2\\ u\\ v$ 表示查询 $G(T)$ 中点 $u$ 到 $v$ 的最短路（每条边长度均为 $1$ ）。 请你回答所有查询。 Input第一行两个整数 $n,q$，表示编号的最大可能值及询问个数。 接下来 $q$ 行每行三个整数 $op u v$，以题目描述中的格式描述一次操作。 Output依次对于每一个 类型的操作，输出一行一个整数表示其对应的答案。 Sample Input12345678910117 101 1 21 2 31 3 51 5 62 1 61 1 42 1 61 1 72 1 62 3 6 Sample Output12344322 Solution假定读者已经大致看过论文和 zx2003 的博客了 重点就是两个函数：qry(x,y) 和 add(x,y) qry(x,y)只需要分别找 $x,y$ 到 LCA（或其祖先） 的最小步数和最后一步之前（即跳”最小步数 $-1$ “步）的位置，再判断 $x,y$ 能否一步到 $z$ 即可 即实现一个 query(x,z) 函数返回 pair(step,point) 先求跳的步数，发现就是 C 中 $x$ 到 $z$ 或其祖先的路径上（不包括最后的 $z$ 或其祖先）点权之和 $+1$ ；特殊的，如果在跳到 $z$ （及其祖先）之前最上面的点权为 $1$ ，则不用 $+1$ ，相当于已经算过跳上去这一步的贡献 再求跳了最小步数 $-1$ 能跳到哪里，不难发现是跳到 $z$ （及其祖先）之前最上面的那一个 “1” 的前驱（如果 “1” 恰好是 $z$ （及其祖先）之前最上面的一个则忽略这个 “1” ，用第二个 “1” 来找前驱） 求 $x$ 能否一步到 $z$ 即判断在 C 上 $z$ 是否能到达 $x$，即 $z$ 向其含有 $x$ 的子树内连的一条链的链底是否是 $x$ 的子孙。 易得 $z$ 连的链底就是 $x$ 到 $z$ 路径上离 $z$ 最近的点，然后就可以 check 了 add(x,y)先判掉 $x&gt;y$ 的情况，这时直接 C 中连一下且 F 中 $fa(y)=x$ 否则 $x&lt;y$，$y$ 会插入成 $x$ 的祖先。C 中 $y$ 会向 $x$ 及其祖先连边直到 $y$ 本身 $x$ 到 $y$ 在 C 中形成的链的一部分后缀的点的 F 中的 fa 会改为 $y$ 需要把这条链上的点权都变成 $0$ 同时可能会影响某些点权为 $0$ 的点，需要把它们点权变为 $1$ 并把他们 LCT 上的父亲改为指向它们的 F （具体见最后一部分） 特别注意这里的 access 每次不是跳 F 中的 fa 而是 C 中的 fa ！！！ （因为 C 中的 fa 不一定是 F 中的 fa，当点权为 $1$ 时相当于跳了一大段 C 中的祖先） 然后把跳到 $y$ 的链上的点的点权全变成 $0$，链顶点权设为 $1$ 并接在 $y$ 上 至于 $y$ 在 C 及 F 上的父亲，可以发现和之前在 $y$ 位置上的点（ $x$ 祖先中最大的编号小于 $y$ 的点）相同。 关于 0 变 1 的处理 一种是从定义上，可以发现是 $u$ 到其在 C 中的父亲所夹的连通块中的最大值，可以通过求连通块任意一点一直跳 fa 直到 $u$ 之前的最后一点得到 一种是考虑特殊处理 LCT 上的链，若能保证每个链头点权都为 $1$ 那么直接找 u 在 LCT 上的后继即可；（但这种 access 要多写一堆东西防止断边出现链头 $0$ ……） add 函数中特殊情况新建的链头以及 access 时断开的链的链头都会变 1； query 函数中 access 提取一条链时可能会断开一个链使得 $0$ 作为链头，这时可以直接强行将其点权变为 $1$，即强行让其指向它 F 中的父亲 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497#include&lt;bits/stdc++.h&gt;#define FIO \"L2474\"#define ll long long#define pii std::pair&lt;int,int&gt;//#define DEBUGconst int N=1e5+5,Q=5e5+5,lgN=18;using namespace std;int premax,vis[N];int n,q,op[Q],u[Q],v[Q];struct Graph&#123; int h[N],to[N&lt;&lt;1],nxt[N&lt;&lt;1],ecnt; int fa[N]; int dfn[N],sz[N],cnt; inline void adde(int u,int v)&#123;nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;&#125; inline void add(int u,int v)&#123;adde(u,v);adde(v,u);&#125;&#125;T,C;struct DSU&#123; int f[N]; inline void init()&#123; for(int i=1;i&lt;=n;i++)f[i]=i; &#125; inline int find(int x)&#123; while(x^f[x])x=f[x]=f[f[x]]; return x; &#125; inline void merge(int x,int y)&#123; if((x=find(x))==(y=find(y)))return; C.add(x,y); f[x]=y; &#125;&#125;U;int mx[N&lt;&lt;1][lgN],lg[N&lt;&lt;1];int dcnt,id[N];set&lt;int&gt;s[N];int top[N],mxs[N],cfa[N];inline void dfsC(int u,int fa=0)&#123; C.dfn[u]=++C.cnt; C.sz[u]=1; mx[id[u]=++dcnt][0]=u; for(int i=C.h[u],v;i;i=C.nxt[i])if((v=C.to[i])^fa)&#123; cfa[v]=u; dfsC(v,u); if(C.sz[v]&gt;C.sz[mxs[u]])mxs[u]=v; C.sz[u]+=C.sz[v]; mx[++dcnt][0]=u; &#125;&#125;inline void dfs2(int u,int tp)&#123; top[u]=tp; if(mxs[u])dfs2(mxs[u],tp); for(int i=C.h[u],v;i;i=C.nxt[i])if((v=C.to[i])^cfa[u]&amp;&amp;v^mxs[u]) dfs2(v,v);&#125;std::vector&lt;int&gt;son[N];inline int cmp(const int &amp;x,const int &amp;y)&#123; return T.dfn[x]&lt;T.dfn[y];&#125;inline void dfsT(int u,int fa=0)&#123; T.dfn[u]=++T.cnt; T.sz[u]=1; for(int i=T.h[u],v;i;i=T.nxt[i])if((v=T.to[i])^fa)&#123; T.fa[v]=u; dfsT(v,u); T.sz[u]+=T.sz[v]; son[u].push_back(v); &#125;&#125;inline int lca(int x,int y)&#123; x=id[x];y=id[y]; if(x&gt;y)std::swap(x,y); int t=lg[y-x+1]; return std::max(mx[x][t],mx[y-(1&lt;&lt;t)+1][t]);&#125;inline void init()&#123; U.init(); for(int u=1;u&lt;=n;u++)&#123; for(int i=T.h[u],v;i;i=T.nxt[i])if((v=T.to[i])&lt;u)&#123; U.merge(v,u); &#125; &#125; for(int i=n;i;i--)if(!id[i])dfsC(i); for(int i=n;i;i--)if(!top[i])dfs2(i,i); for(int i=1;i&lt;=n;i++)if(!T.dfn[i])dfsT(i); lg[0]=-1; for(int i=1;i&lt;=dcnt;i++)lg[i]=lg[i&gt;&gt;1]+1; for(int j=1;(1&lt;&lt;j)&lt;=dcnt;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=dcnt;i++) mx[i][j]=std::max(mx[i][j-1],mx[i+(1&lt;&lt;(j-1))][j-1]);&#125;int ch[N][2],fa[N];int w[N],sum[N];#define lx ch[x][0]#define rx ch[x][1]#define chk(x) ((x)==ch[fa[x]][1])#define isrt(x) (ch[fa[x]][0]!=x&amp;&amp;ch[fa[x]][1]!=x)inline void pushup(int x)&#123; sum[x]=sum[lx]+w[x]+sum[rx];&#125;inline void rotate(int x)&#123; int y=fa[x],z=fa[y],t=chk(x); fa[ch[x][!t]]=y; ch[y][t]=ch[x][!t]; fa[x]=z; if(!isrt(y))ch[z][chk(y)]=x; ch[x][!t]=y; fa[y]=x; pushup(y); pushup(x);&#125;/*inline void out_lct()&#123; for(int i=1;i&lt;=n;i++)if(vis[i])&#123; printf(\"%d:fa=%d ch=(%d,%d) w=%d s=%d\\n\",i,fa[i],ch[i][0],ch[i][1],w[i],sum[i]); &#125; puts(\"\");&#125;vector&lt;int&gt;STA;int tim,lst[N];inline void dfs(int x,int tim)&#123; if(!x)return; lst[x]=tim; dfs(lx,tim); STA.push_back(x); dfs(rx,tim);&#125;inline void checkGG()&#123; for(int i=1;i&lt;=n;i++)if((ch[i][0]&amp;&amp;i&gt;ch[i][0])||i&lt;ch[i][1])&#123; printf(\"GG in %d\\n\",i); cout.flush(); assert(i&lt;=ch[i][0]&amp;&amp;i&gt;=ch[i][1]); &#125;&#125;inline void out_C()&#123; for(int i=1;i&lt;=n;i++)if(vis[i])&#123; printf(\"%d:C.fa=%d\\n\",i,C.fa[i]); &#125;&#125;*/inline void splay(int x)&#123; assert(x); for(int y=fa[x];!isrt(x);rotate(x),y=fa[x])if(!isrt(y)) rotate(chk(x)^chk(y)?x:y);&#125;/*inline void checkorder()&#123; tim++; for(int i=1;i&lt;=n;i++)if(lst[i]!=tim)&#123; STA.clear(); splay(i); dfs(i,tim); for(int i=1,sz=STA.size();i&lt;sz;i++)&#123; if(STA[i]&gt;STA[i-1])&#123; out_lct(); printf(\"STA=\"); for(int i=0;i&lt;sz;i++) printf(\"%d \",STA[i]); puts(\"\"); &#125; cout.flush(); assert(STA[i]&lt;=STA[i-1]); &#125; &#125;&#125;*/inline int find_fir(int x)&#123; while(lx)x=lx; return x;&#125;inline int find_one(int x,int prefer)&#123; if(!sum[x])assert(0); while(x)&#123; if(sum[ch[x][prefer]])x=ch[x][prefer]; else if(w[x])return x; else x=ch[x][!prefer]; &#125; assert(0);&#125;inline int find_pre(int x)&#123; splay(x); if(!lx)return fa[x]; x=lx; while(rx)x=rx; return x;&#125;inline void link(int x,int y,int flag=1)&#123; if(y)assert(x&lt;y); splay(x); if(y)splay(y); w[x]=1; pushup(x); if(flag&amp;&amp;y)&#123; if(ch[y][1])&#123; int tmp=find_fir(ch[y][1]); fa[ch[y][1]]=0; splay(tmp); ch[y][1]=0; if(!w[tmp])&#123; link(tmp,find_pre(find_one(y,1)),0); &#125; &#125; ch[y][1]=x; pushup(y); &#125; fa[x]=y;&#125;inline int upper_floor(int x,int z)&#123; int ret=x; while(x)&#123; if(x&lt;z)&#123; ret=x; x=lx; &#125;else x=rx; &#125; return ret;&#125;inline pii query(int x,int z)&#123; if(x==z)return pii(0,x); pii ret; ret.second=x; int y=0; while(x)&#123; splay(x); if(rx)&#123; int w=rx; rx=0; w=find_fir(w); pushup(x); if(!::w[w])&#123; splay(w); fa[w]=0; int tt=find_pre(find_one(x,1)); link(w,tt,0); &#125; splay(x); &#125; rx=y; pushup(x); if(!(fa[x]&amp;&amp;fa[x]&lt;z))break; y=x; x=fa[x]; &#125; //printf(\"x=%d lower=%d\\n\",x,upper_floor(x,z)); splay(x); x=upper_floor(x,z); splay(x); ret.first=sum[rx]+1; if(sum[rx]) ret.second=find_pre(find_one(rx,0)); return ret;&#125;inline bool in(int *dfn,int *sz,int x,int y)&#123; return dfn[y]&lt;=dfn[x]&amp;&amp;dfn[x]&lt;dfn[y]+sz[y];&#125;inline int get_down(int x,int y)&#123; if(!in(T.dfn,T.sz,y,x))return T.fa[x]; assert(x^y); int z=*--upper_bound(son[x].begin(),son[x].end(),y,cmp); return z;&#125;inline bool check(int x,int y)&#123; if(x==y)return 1; cout.flush(); int z=get_down(y,x); return in(C.dfn,C.sz,z,x);&#125;inline int qry(int x,int y)&#123; //printf(\"------------\\nqry %d %d\\n\",x,y); int z=lca(x,y); pii a=query(x,z),b=query(y,z);#ifdef DEBUG printf(\"a=(%d,%d)\\n\",a.first,a.second); printf(\"b=(%d,%d)\\n\",b.first,b.second); printf(\"lca=%d\\n\",z);#endif return a.first+b.first+!(check(a.second,z)&amp;&amp;check(b.second,z));&#125;inline int access(int x)&#123; int y=0; while(x)&#123; splay(x); if(rx)&#123; int w=rx; rx=0; pushup(x); w=find_fir(w); if(!::w[w])&#123; splay(w); fa[w]=0; int tt=find_pre(find_one(x,1)); link(w,tt,0); &#125; splay(x); &#125; rx=y; pushup(x); if(!fa[x]||sum[x])break; y=x; x=fa[x]; &#125; if(sum[x]) return find_one(x,1); else return find_fir(x);&#125;inline int getson(int x,int y)&#123; int ret=x; assert(x); while(top[x]^top[y])&#123; if(s[top[x]].size()) ret=*s[top[x]].rbegin(); x=cfa[top[x]]; &#125; set&lt;int&gt;::iterator it=s[top[x]].lower_bound(y); if(it!=s[top[x]].begin())&#123; ret=*--it; &#125; /* while(C.fa[x]&amp;&amp;C.fa[x]&lt;y)&#123; x=C.fa[x]; if(vis[x])ret=x; &#125; */ return ret;&#125;inline void add(int x,int y)&#123; if(x&gt;y)&#123; link(y,x,0); C.fa[y]=x; s[top[y]].insert(y); return; &#125; int z=getson(x,y); s[top[y]].insert(y); std::vector&lt;int&gt;v; int lstx=0; while(x)&#123; v.push_back(x); x=access(x); int z=find_pre(x); if(z&gt;y)&#123; v.pop_back(); break; &#125; splay(x); lstx=x; fa[lx]=fa[x]; w[x]=fa[x]=lx=0; pushup(x); x=C.fa[x]; &#125;#ifdef DEBUG printf(\"v=&#123;\"); for(int i=0,szv=v.size();i&lt;szv;i++)printf(\"%d,\",v[i]); puts(\"&#125;\");#endif for(int i=0,szv=v.size();i&lt;szv-1;i++)&#123; splay(v[i]); splay(v[i+1]); assert(!ch[v[i+1]][1]); ch[v[i+1]][1]=v[i]; fa[v[i]]=v[i+1]; pushup(v[i+1]); &#125; if(v.size()) link(lstx,y,0); /* * !!! the same as &#123; splay(v.back()); link(find_fir(v.back()),y,0); &#125; */ C.fa[y]=C.fa[z]; C.fa[z]=y; if(!C.fa[y])&#123; return; &#125; splay(z); //printf(\"Before add y to tree:(son=%d)\\n\",x); out_lct(); ch[y][0]=ch[z][0]; if(ch[z][0])fa[ch[z][0]]=y; ch[z][0]=y; fa[y]=z; w[y]=w[z]; w[z]=0; pushup(y); pushup(z);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for(int i=1;i&lt;=q;i++)&#123; scanf(\"%d%d%d\",&amp;op[i],&amp;u[i],&amp;v[i]); if(op[i]==1)&#123; T.add(u[i],v[i]); &#125; &#125; vis[1]=1; init(); for(int i=1;i&lt;=q;i++)&#123; if(op[i]==1)&#123; premax=max(premax,v[i]); vis[v[i]]=1; add(u[i],v[i]); &#125;else printf(\"%d\\n\",qry(u[i],v[i]));#ifdef DEBUG //out_lct(); out_C(); puts(\"===========\");#endif &#125; return 0;&#125;","categories":[{"name":"LOJ","slug":"LOJ","permalink":"https://buzhibujue.cf/categories/LOJ/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://buzhibujue.cf/tags/图论/"},{"name":"LCT","slug":"LCT","permalink":"https://buzhibujue.cf/tags/LCT/"}]},{"title":"图计数","slug":"图计数","date":"2020-02-22T10:45:00.000Z","updated":"2020-08-28T14:17:31.617Z","comments":true,"path":"2020/02/22/图计数/","link":"","permalink":"https://buzhibujue.cf/2020/02/22/图计数/","excerpt":"","text":"图计数$n$ 个点的有标号 DAG$h_n$ 表示 $n$ 个点的DAG方案数 $f_{n,i}$ 表示一共 $n$ 个点，其中至少 $i$ 个是汇点的方案数 $g_{n,i}$ 表示一共 $n$ 个点，其中恰好 $i$ 个是汇点的方案数 于是有如下恒等式： f_{n,i}=2^{i(n-i)}\\binom ni h_{n-i}\\\\ f_{n,i}=\\sum_{j=i}^n\\binom ji g_{n,j}\\\\ \\downarrow\\\\ g_{n,i}=\\sum_{j=i}^n\\binom ji (-1)^{j-i}f_{n,j}\\\\ h_{n}=\\sum_{i=1}^ng_i然后得到 \\begin{aligned} h_n=&\\sum_{i=1}^ng_i \\\\=& \\sum_{i=1}^n\\sum_{j=1}^n(-1)^{j-i}\\binom ji f_j \\\\=& \\sum_{j=1}^n(-1)^jf_j\\sum_{i=1}^n\\binom ji(-1)^i \\\\=& \\sum_{i=1}^n(-1)^i2^{i(n-i)}\\binom ni h_{n-i}(-1+[j=0]) \\\\=& \\sum_{i=1}^n(-1)^i2^{i(n-i)}\\binom ni h_{n-i}(-1) \\\\=& \\sum_{i=1}^n(-1)^{i-1}2^{i(n-i)}\\binom ni h_{n-i} \\\\=& \\sum_{i=1}^n(-1)^{i-1}2^{\\binom n2-\\binom i2-\\binom {n-i}2}\\frac{n!}{i!(n-i)!}h_{n-i} \\\\=& n!2^{\\binom n2}\\sum_{i=1}^n\\frac{(-1)^{i-1}}{2^\\binom i2i!}\\times \\frac{h_{n-i}}{2^\\binom {n-i}2(n-i)!} \\end{aligned}然后令 $H(x)=\\sum_{i=0}^\\infin \\frac{h_i}{2^\\binom i2 i!}x^i$ ， $G(x)=\\sum_{i=1}^\\infin \\frac{(-1)^{i-1}}{2^\\binom i2 i!}x^i$ 有 $H(x)=1+H(x)G(x)$ 所以 $H(x)=\\frac{1}{1-G(x)}$ ，使用多项式求逆即可 对 $h_n=\\sum_{i=1}^n(-1)^{i-1}2^{i(n-i)}\\binom ni h_{n-i}$ 还有一个组合上的解释： 考虑 $\\sum_{i=0}^n(-1)^i2^{i(n-i)}\\binom ni h_{n-i}$ 这个式子，这里每个 $g_i$ 被其大小为奇数的子集贡献 $-1$ ，大小为偶数的子集贡献 $+1$ ，所以得到 $\\sum_{i=0}^n(-1)^i2^{i(n-i)}\\binom ni h_{n-i}=g_0$ 去掉 $i=0$ 时的贡献得到 $\\sum_{i=1}^n(-1)^i2^{i(n-i)}\\binom ni h_{n-i}=-g_1-g_2-g_3-\\cdots -g_n$ 所以 $h_n=g_1+g_2+g_3+\\cdots=\\sum_{i=1}^n(-1)^{i-1}2^{i(n-i)}\\binom ni h_{n-i}$ 注意：$\\binom i2$ 不要写成 $i\\times (i-1)$ 忘除以 $2$ 了。。。以及这个好像 oeis 上叫什么 3-multigraph 又可以出毒瘤题了 $n$ 个点有标号的弱连通 DAG解一： 感性理解一下，用上面的东西直接求个ln即可 （怎么学X写题解） 解二： 令 $f_n$ 表示上面求出来的 $n$ 个点不要求联通DAG数 $g_n$ 表示要求联通的DAG数 用可以联通可以不连通的数量减去一定不连通的就是答案，枚举 $1$ 所在连通块大小有 g_n=f_n-\\sum_{i=1}^{n-1}\\binom{n-1}{i-1}g_{i}f_{n-i}（实际上和求ln等价的） 如果要拆开的话就是 \\begin{aligned} g_n&=f_n-\\sum_{i=1}^{n-1}\\frac{(n-1)!}{(i-1)!(n-i)!}g_if_{n-i} \\\\&=f_n-(n-1)!\\sum_{i=1}^{n-1}\\frac{g_i}{(i-1)!}\\frac{f_{n-i}}{(n-i)!} \\\\&= (n-1)!\\left(\\frac{f_n}{(n-1)!}-\\sum_{i=1}^{n-1}\\frac{g_i}{(i-1)!}\\frac{f_{n-i}}{(n-i)!}\\right) \\end{aligned}令 $F(x)=\\sum_{i=0}^\\infin \\frac{f_i}{i!}x^i$ ， $G(x)=\\sum_{i=1}^\\infin \\frac{g_i}{i!}$ 由上面得到 G’(x)=F’(x)-G’(x)(F(X)-1)\\\\ G‘(x)=\\frac{F’(x)}{F(x)}\\\\ G(x)=\\int\\frac{F’(x)}{F(x)}=\\ln F(x)所以这玩意确实是直接求 $\\operatorname{ln}$ 即可 给定一无向图的边集，计算给所有无向边定向使得 $1$ 号点恰好能访问到点集 $S$ 的方案数设 $f_S$ 为只考虑 $S$ 内部的无向边定向后的答案， $ans_S$ 为题目中所求的答案，则 $ \\complement_U S$ 与 $S$ 之间的边一定是从前者到后者，记 $E_S$ 表示 $S$ 内部连边的数量，则 f_S=2^{E_S}-\\sum_{T\\subsetneq S}f_T\\times 2^{E_{S\\oplus T}}\\\\ ans_S=f_S\\times 2^{E_{\\complement _US}} $n$ 个点的仙人掌$C(x)=x\\exp((\\sum_{i\\geq 2}\\frac{C(x)^i}{2})+C(x))=x\\exp(\\frac{2C(x)-C(x)^2)}{2-2C(x)}{})$ 令 $G(C(x))=x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})-C(x)$ $C(x)=C_0(x)-\\frac{G(C_0(x)))}{G’(C_0(x))}$ \\begin{aligned} G'(C(x))&= \\left(x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})-C(x)\\right)' \\\\&= x\\left(\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})\\right)'-1 \\\\&= x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})\\times \\left(\\frac{2C(x)-C(x)^2}{2-2C(x)}\\right)'-1 \\\\&= x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})\\times \\left(1+\\frac{4C(x)-2C(x)^2}{(2-2C(x))^2}\\right)-1 \\end{aligned} \\begin{aligned} C_1(x) &= C(x)-\\frac{G(C(x))}{G'(C(x))} \\\\&= C(x)-\\frac{x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})-C(x)}{x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})\\times \\left(1+\\frac{4C(x)-2C(x)^2}{(2-2C(x))^2}\\right)-1} \\\\&= C(x)-\\frac{x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})-C(x)}{x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})\\times \\left(\\frac{2C(x)^2-4C(x)+4}{(2-2C(x))^2}\\right)-1} \\\\&= C(x)-\\frac{2x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})-2C(x)}{x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})\\times \\left(\\frac{C(x)^2-2C(x)+2}{(1-C(x))^2}\\right)-2} \\\\&= C(x)-\\frac{2x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})-2C(x)}{x\\exp(\\frac{2C(x)-C(x)^2}{2-2C(x)})\\times \\left(1+\\frac{1}{(1-C(x))^2}\\right)-2} \\end{aligned} $n$ 个点的有标号点双记 $n$ 个点的有根连通图的 EGF 为 $H(x)$，$n$ 个点的点双个数的 EGF 为 $B(x)$ 对于一个有根连通图，找到根节点所在的点双，删掉点双内部所有的连边，一定会形成一个中间的根和若干个有根的连通块。所以得到 $H(x)=x\\times \\sum_{i=0}^\\infin b_{i+1}\\frac{(H(x))^i}{i!}=xe^{B_1(H(x))}$ 其中 $B_1(x)=\\sum_{i=0}^\\infin b_{i+1}\\frac{x^i}{i!}=B`(x)$ 有 $H^{-1}(H(x))=x,\\frac{H(x)}{e^{B_1(H(x))}}=x$ 比较系数得到 $H^{-1}(x)=\\frac{x}{e^{B_1(x)}}$ 得到 $B_1(x)=\\ln(\\frac{x}{H^{-1}(x)})$ 求 $B_1(x)$ 第 $n$ 项： 考虑拓展拉格朗日反演的形式 令 $ff(H^{-1}(x))=B_1(x)=\\ln(\\frac{x}{H^{-1}(x)})$ ，得到 $ff(H^{-1}(H(x)))=ff(x)=\\ln(\\frac{H(x)}{x})$ 。 所以 $[x^n]B_1(x)=[x^n]ff(H^{-1}(x))=\\frac 1n[x^{n-1}]ff’(x)(\\frac{x}{H(x)})^n$ $n$ 个点的有标号边双设 $n$ 个点的有根连通图的 EGF 为 $H(x)$，$n$ 个点的边双个数的 EGF 为 $B(x)$ 考虑一个有根联通图，令根节点所在的边双的点数为 $n$，选根是这个边双中的哪一个有 $n$ 种选法。考虑缩边双形成的 BCC 树，根节点所在的超级点会有若干子树，每个子树都是一个有根联通图，可以选超级点中任意一个连边，一个子树 EGF 就是 $nH(x)$ ，若干个就是 $e^{nH(x)}$ 得到 $H(x)=\\sum_{i}i\\times \\frac{b_i}{i!}x^ie^{iH(x)}=\\sum_{i=0}^\\infin\\frac{b_{i+1}}{i!}x^{i+1}e^{(i+1)H(x)}=xe^{H(x)}\\sum_{i=0}^\\infin\\frac{b_{i+1}}{i!}(xe^{H(x)})^i=B_1(xe^{H(x)})$， 其中 $B_1(x)=x\\times\\sum_i\\frac{b_{i+1}}{i!}x^i=xB’(x)$ 于是得 到 $H(x)=B_1(xe^{H(x)})$ 求 $B_1(x)$ 第 $n$ 项： $x=H(H^{-1}(x))=B_1(H^{-1}(x)e^x)$ $G(x)=xe^{H(x)}$ 所以 $B(G(x))=H(x)$，$B(x)=H(G^{-1}(x))$ $[x^n]B_1(x)=H(G^{-1}(x))=\\frac 1n[x^{n-1}]H’(x)(\\frac{x}{G(x)})^n$ $n$ 个点有标号强连通图令 $h_n$ 表示 $n$ 个点有向图个数。定义集合 $S$ 的权值是 $(-1)^{|S|}$，设 $e_n$ 表示（这个集合里所有元素都是强连通图）所有这样的 集合内元素总点数为 $n$ 的集合的权值和。 e_n=-\\sum_{i=1}^ne^{n-i}\\times h_i\\times 2^{i(n-i)}\\times \\binom ni \\\\ ans_n=-e_n-\\sum_{i=1}^{n-1}ans_i\\times e_{n-i}\\times \\binom{n-1}{i-1} 给定无向图的边的子集满足形成边双的方案数记 $f(S)$ 为 $S$ 形成连通图方案数，$h(S,T)$ 为 $S$ 分成若干块且每块都和 $T$ 连恰好一条边的方案数 ans[S]=f[S]-\\sum_{\\min S\\in S_0\\subseteq S}ans[S_0]\\times h[S\\backslash S_0][S_0]\\\\ h[S][T]= \\begin{cases} 1,&S=\\varnothing \\\\ \\sum_{\\min S\\in S_0\\subsetneq S}h[S\\oplus S_0][T]\\times f[S_0]\\times edge(S_0,T),&\\text{otherwise} \\end{cases} $edge(S,T)$ 直接 $E(S\\oplus T)-E(S)-E(T)$即可 给定有向图的边的子集满足形成强连通的方案数$f[S]$ 表示把集合 $S$ 分为非强连通分量的方案数 $h_k[S]$ 表示把集合 $S$ 分为 $k$ 个 $SCC$ 的方案数 $ans[S]$ 表示把集合 $S$ 分为 $1$ 个 $SCC$ 的方案数（也即是 $h_1[S]$ ） \\begin{align} f[S]&=\\sum_{\\varnothing\\neq T\\subseteq S}(-1)^{|T|-1}\\times f[T]\\times 2^{edge(T,S\\backslash T)}\\\\ &= \\sum_{\\varnothing\\neq T\\subseteq S}\\sum_{k=1}^{|T|}(-1)^{k-1}\\times h_k[T]\\times 2^{edge(T,S\\backslash T)}\\times 2^{E(S\\backslash T)} \\\\ &= \\sum_{\\varnothing\\neq T\\subseteq S}g[T]\\times 2^{edge(T,S\\backslash T)+E(S\\backslash T)}\\\\ 定义其中的 g[S]&= \\sum_{i=1}^{\\max}h_{2i-1}[S]-\\sum_{i=1}^{\\max}h_{2i}[S]\\\\ &= ans[S]-\\sum_{\\min S\\in T\\subsetneq S}ans[T]\\times g[S\\backslash T]\\\\ ans[S]&=2^{E(S)}-f[S] \\end{align}对于 $edge(T,S\\backslash T)$ , 令 $u=\\min S\\backslash T$ edge(T,S\\backslash T)=edge(T\\cup u,(S\\backslash T)\\backslash u)-edge(u,(S\\backslash T)\\backslash u)+edge(T,u)后两项可以通过预处理一个点的出度集合和入度集合来快速计算 Q： 算 $f[S]$ 时要用到 $g[S]$ 但算 $g[S] $ 时不是应该加上当前的 $ans[S]$ 吗，$ans[S]$ 又要通过 $f[S]$ 求？ A: 想一下我们现在求的是什么：当前情况的合法状态数 $ans[S]$ 。这个要通过 $2^{E[S]}-f[S]$ 实现，那么就要把之前算的答案导致的不合法情况容斥掉，而 $g$ 的意义只是为了我们后面再算的时候降低复杂度，是我们“定义”出来的一个值，没有什么实际含义，即我们只需要算之前的 $g[T]$ 导致的不合法情况并删除，剩下的就是现在合法的情况数，然后再用这个去更新现在的 $g[S]$ 以便以后用到的时候值正确","categories":[{"name":"总结","slug":"总结","permalink":"https://buzhibujue.cf/categories/总结/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://buzhibujue.cf/tags/计数/"},{"name":"数学","slug":"数学","permalink":"https://buzhibujue.cf/tags/数学/"}]},{"title":"FFT&NTT","slug":"fft","date":"2020-02-18T14:08:01.000Z","updated":"2020-05-03T15:47:50.000Z","comments":true,"path":"2020/02/18/fft/","link":"","permalink":"https://buzhibujue.cf/2020/02/18/fft/","excerpt":"","text":"FFT&amp;NTTFFTDFT单位根定义 $\\omega_n=\\cos (\\frac {2\\pi}{n})+i\\sin (\\frac {2\\pi}{n})$ 得到 $\\omega_n^k=\\cos(\\frac{2k\\pi}{n})+i\\sin(\\frac{2k\\pi}{n})$ 单位根性质 $\\omega_n^0=1,\\omega_n^{n/2}=-1$ $\\omega_{dn}^{dk}=\\omega_{n}^{k}$ $\\omega_{n}^{i+n/2}=\\omega_{n}^{n/2}\\cdot\\omega_{n}^{i}=-\\omega_{n}^{i}$ 令 $F_n(x)=\\sum_{i=0}^{n-1}f_ix^i$ $F_0(x)=\\sum_{i=0}^{n/2-1}f_{2i}x^i,F_1(x)=\\sum_{i=0}^{n/2-1}f_{2i+1}x^i$ 得到 $F(x)=F_0(x^2)+xF_1(x^2)$ \\begin{aligned} F(\\omega_n^i)&=F_0(\\omega_n^{2i})+\\omega_n^iF_1(\\omega_n^{2i}) \\\\&= F_0(\\omega_{n/2}^i)+\\omega_n^iF_1(\\omega_{n/2}^i) \\\\ F(\\omega_n^{i+n/2})&=F(-\\omega_n^{i})=F_0(\\omega_n^{2i})-\\omega_n^iF_1(\\omega_n^{2i}) \\\\&= F_0(\\omega_{n/2}^i)-\\omega_n^iF_1(\\omega_{n/2}^i) \\end{aligned}每一项系数 $f_i$ 对第 $j$ 个点值表示的贡献是 $f_i(\\omega_n^j)^i$ IDFT把DFT的过程写成矩阵的形式 \\begin{bmatrix} (\\omega_n^0)^0 & (\\omega_n^0)^1 & \\cdots & (\\omega_n^0)^{n-1} \\\\ (\\omega_n^1)^0 & (\\omega_n^1)^1 & \\cdots & (\\omega_n^1)^{n-1} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ (\\omega_n^{n-1})^0 & (\\omega_n^{n-1})^1 & \\cdots & (\\omega_n^{n-1})^{n-1} \\end{bmatrix} \\begin{bmatrix} f_0 \\\\ f_1 \\\\ \\vdots \\\\ f_{n-1} \\end{bmatrix} = \\begin{bmatrix} F(\\omega_n^0) \\\\ F(\\omega_n^1) \\\\ \\vdots \\\\ F(\\omega_n^{n-1}) \\end{bmatrix}尝试得到左边矩阵（记为 $\\mathbf V$ ）的逆，精心构造得到： \\mathbf D = \\begin{bmatrix} (\\omega_n^{-0})^0 & (\\omega_n^{-0})^1 & \\cdots & (\\omega_n^{-0})^{n-1} \\\\ (\\omega_n^{-1})^0 & (\\omega_n^{-1})^1 & \\cdots & (\\omega_n^{-1})^{n-1} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ (\\omega_n^{-(n-1)})^0 & (\\omega_n^{-(n-1)})^1 & \\cdots & (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix}发现若 $\\mathbf{E=D\\cdot V}$ \\begin{aligned} e_{i,j}&=\\sum_{k=0}^{n-1}v_{i,k}d_{k,j} \\\\&= \\sum_{k=0}^{n-1}v_{i,k}d_{k,j} \\\\&= \\sum_{k=0}^{n-1} (\\omega_n^i)^k (\\omega_n^{-k})^j \\\\&= \\sum_{k=0}^{n-1} (\\omega_n^k)^{i-j} \\\\&= \\begin{cases} n,&i=j\\\\ \\sum_{k=0}^{n-1} (\\omega_n^{i-j})^k =\\frac{1-(\\omega_n^{i-j})^{n}}{1-\\omega_n^{i-j}}=0,&i\\neq j \\end{cases} \\end{aligned}所以得到$\\mathbf{D\\cdot V}=\\mathbf E=n\\cdot \\mathbf I$ 即 $\\frac 1n\\mathbf D=\\mathbf V^{-1}$ \\begin{bmatrix} f_0 \\\\ f_1 \\\\ \\vdots \\\\ f_{n-1} \\end{bmatrix} = \\frac{1}{n} \\begin{bmatrix} (\\omega_n^{-0})^0 & (\\omega_n^{-0})^1 & \\cdots & (\\omega_n^{-0})^{n-1} \\\\ (\\omega_n^{-1})^0 & (\\omega_n^{-1})^1 & \\cdots & (\\omega_n^{-1})^{n-1} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ (\\omega_n^{-(n-1)})^0 & (\\omega_n^{-(n-1)})^1 & \\cdots & (\\omega_n^{-(n-1)})^{n-1} \\end{bmatrix} \\begin{bmatrix} F(\\omega_n^0) \\\\ F(\\omega_n^1) \\\\ \\vdots \\\\ F(\\omega_n^{n-1}) \\end{bmatrix}把IDFT的系数取倒数（即直接虚部取相反数）做一遍DFT再除以 $n$ 即可 NTT 对于一个质数 $p$ ，其原根 $g$ 满足 $g^0,g^1,g^2,\\cdots ,g^{p−2}$ 在模 $p$ 意义下两两不同 所以 $\\omega_n\\to g^{(p-1)/n}$ 这就需要 $p-1$ 是 $2$ 的幂 $\\omega_n^0=1,\\omega_n^{n/2}=-1$ $(g^{(p-1)/n})^0=g^0=1$ $(g^{(p-1)/2})^2=g^{p-1}=1$ 所以 $g^{(p-1)/2}=\\pm 1$ 因为 $g^0\\neq g^1\\neq g^2\\neq \\cdots\\neq g^{p-2}$ 且 $g^0=1$ 所以 $g^{(p-1)/2}\\neq 1$ 所以 $g^{(p-1)/2}=-1$ $(g^{(p-1)/n})^{n/2}=g^{(p-1)/2}=-1$ $\\omega_{dn}^{dk}=\\omega_{n}^{k}$ $(g^{(p-1)/(dn)})^{dk}=g^{k(p-1)/n}$ $\\omega_{n}^{i+n/2}=\\omega_{n}^{n/2}\\cdot\\omega_{n}^{i}=-\\omega_{n}^{i}$ $(g^{(p-1)/n})^{i+n/2}=(g^{(p-1)/n})^{n/2}\\cdot(g^{(p-1)/n})^{i}=-(g^{(p-1)/n})^{i}$ 看上去都没什么问题 $\\frac{1-(\\omega_n^{i-j})^{n}}{1-\\omega_n^{i-j}}=0$ $\\frac{1-((g^{(p-1)/n})^{i-j})^{n}}{1-(g^{(p-1)/n})^{i-j}}=\\frac{1-((g^{(p-1)})^{i-j})}{1-(g^{(p-1)/n})^{i-j}}=\\frac{1-1^{i-j}}{1-(g^{(p-1)/n})^{i-j}}=0$ 所以 DFT 等操作的写法和 FFT 基本等价 HDU 6067$ans=\\prod_{x=1}^{k-1}\\left(\\sum_{i=0}^ng_{x,i}\\frac{x^i}{i!}\\right)[x^n]\\times n!$ 每次更改一个多项式的一项系数 对于其点值表示的影响可以顺次算出来 再算一个所有多项式的对应的 $L$ 个点值表示，改了一个就先除去再修改再乘上即可 因为可能有 $0$ 不能直接除要记录一下 $0$ 的个数 最后求 $ans$ 不能每次都还原多项式算和可能常数太大，发现最后求的是一堆多项式的第 $n$ 项和，直接记录点值和，最后再从这个点值反推回所有的多项式的和对应系数和即可 过了这题才发现一直以来的`NTT``的单位根都处理反了… 一开始以为NTT长度只用到 $n$ 然而是每个数最多出现 $n$ 次，NTT长度是 $10n$ 记得去掉第 $0$ 位的答案，因为不存在只有 $0$ 位的数字 这题模数小最好预处理逆元到 $MOD$ 不然复杂度多个 $\\log$ 可能过不了 cf286E每个能表示出来的数一定能被至多两个数表示出来，否则假如只能由 $a+b+c$ 表示，那么就一定不能表示 $a+b$ 相当于这个集合对加法封闭 直接对集合里出现的数做集合幂级数再并上一个 $0$ 即可 考虑每一位： 如果原来为 $0$ 现在不为 $0$ 那么这个集合不是封闭的输出NO 如果原来不为 $0$ 现在为 $0$ 不可能因为 $0$ 次项是 $1$ 如果原来为 $0$ 现在也为 $0$ 不影响 如果原来不为 $0$ 现在也不为 $0$ 那么看它的值是否是 $2$ 是的话就只能是 $0+i$ 和 $i+0$ 凑出来，这个数就必选;否则一定有两个非零的和为 $i$ ，这个数可以被其他数表示出来所以不必选 BZOJ4836 二元运算在值域上分治，每次直接算两遍左边卷右边的东西贡献到答案数组上 最后每次 $O(1)$ 出答案 cf553E Kyoya and Train设 $f_{u,x}$ 表示在时间 $x$ 时点 $u$ 到 $n$ 所需要的最短路的期望 则 $f_{u,x}=\\min_{(u,v)\\in E}c_{u,v}+\\sum_{d=0}^tf_{v,x+d}\\times P_{t_{u,v}=d}$ 令后者为 $g_{i,x}$ 即第 $i$ 条边的东西 转移就成了 $f_{u,x}=\\min_{(u,v)\\in E}c_{u,v}+g_{v,t}$ 然后这个 $g$ 的转移即为 $g_{u,x}=\\sum_{d=0}^tf_{v,x+d}\\times P_{t_{u,v}=d}$ 是一个卷积的形式，直接分治 fft 就搞完了 然后记得当把 $[mid+1,r]$ 更新到 $[l,mid]$ 时的 $P$ 数组要开 $r-l+1$ 而不是 $r-mid+1$ 因为要把 $f_r$ 对 $g_l$ 的贡献全部算进去而不是只是 $f_r\\to g_{mid}\\cdots f_{mid+1}\\to g_l$ 这样 注意边界的最小最大值各取什么，不要想着有clang++查错，一个边界的小问题可能卡半个多小时 BZOJ4451 Frightful Formula ans= \\sum_{i=2}^nf_{1,i}\\times a^{n-i}b^{n-1}\\binom{2n-i-2}{n-i} + \\sum_{i=2}^nf_{i,1}\\times a^{n-1}b^{n-i}\\binom{2n-i-2}{n-i} + \\sum_{i=2}^n\\sum_{j=2}^nc\\times \\binom{2n-i-j}{n-i}a^{n-j}b^{n-i} \\begin{aligned} &\\sum_{i=2}^n\\sum_{j=2}^nc\\times \\binom{2n-i-j}{n-i}a^{n-j}b^{n-i} \\\\=& c\\sum_{i=2}^n\\sum_{j=2}^n\\binom{2n-i-j}{n-i}a^{n-j}b^{n-i} \\\\=& c\\sum_{i=0}^{n-2}\\sum_{j=0}^{n-2}\\binom{i+j}{i}a^{j}b^{i} \\\\=& c\\sum_{k=0}^{2n-4}\\sum_{i=0}^{n-2}\\binom{k}{i}a^{k-i}b^{i} \\\\=& c\\sum_{k=0}^{2n-4}k!\\sum_{i=0}^{n-2}\\frac{a^{k-i}}{(k-i)!}\\frac{b^i}{i!} \\end{aligned}这已经可以直接任意模数NTT做了，只是常数大 由于这题的形式特殊，尝试再推一些东西 令 $f_n=\\sum_{i=0}^n\\sum_{j=0}^n\\binom{i+j}{i}a^ib^j$ 则上面那个东西就是 $c\\times f_{n-2}$ \\begin{aligned} f_{n}=& \\sum_{i=0}^n\\sum_{j=0}^n\\binom{i+j}{i}a^ib^j \\\\=& \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}\\binom{i+j}{i}a^ib^j+\\sum_{i=0}^n\\binom{i+n}{i}a^ib^n+\\sum_{j=0}^n\\binom{n+j}{n}a^nb^j-\\binom{2n}{n}a^nb^n \\\\=& f_{n-1}+\\sum_{i=0}^n\\binom{i+n}{i}a^ib^n+\\sum_{j=0}^n\\binom{n+j}{n}a^nb^j-\\binom{2n}{n}a^nb^n \\end{aligned}边界是 $f_0=1$ 后两项是类似的，以 $g_a(n)=\\sum_{i=0}^n\\binom{i+n}{i}a^ib^n$ 为例 \\begin{aligned} g_a(n)=&\\sum_{i=0}^n\\binom{i+n}{i}a^ib^n \\\\=& \\sum_{i=0}^n\\left(\\binom{i+n-1}{i}+\\binom{i+n-1}{i-1}\\right)a^ib^{n} \\\\=& \\sum_{i=0}^n\\binom{i+n-1}{i}a^ib^n+\\sum_{i=0}^n\\binom{i+n-1}{i-1}a^ib^{n} \\\\=& b\\times \\sum_{i=0}^{n-1}\\binom{i+n-1}{i}a^ib^{n-1}+\\binom{2n-1}{n}a^nb^n+\\sum_{i=0}^n\\binom{i+n-1}{i-1}a^ib^{n} \\\\=& b\\times g_a(n-1)+\\binom{2n-1}{n}a^nb^n+a\\times \\sum_{i=0}^{n-1}\\binom{i+n}{i}a^ib^n \\\\=& b\\times g_a(n-1)+\\binom{2n-1}{n}a^nb^n+a\\times \\left(g_a(n)-\\binom{2n}{n}a^nb^n\\right) \\\\=& b\\times g_a(n-1)+\\binom{2n-1}{n}a^nb^n+a\\times g_a(n)-\\binom{2n}{n}a^{n+1}b^n \\end{aligned}边界 $g_a(0)=1$ 得到 $(1-a)g_a(n)=b\\times ga_(n-1)+\\binom{2n-1}{n}a^nb^n-\\binom{2n}{n}a^{n+1}b^n$ 当 $a=1$ 时有 0=b\\times g_a(n-1)+\\binom{2n-1}{n}b^n-\\binom{2n}{n}b^n\\\\ \\therefore g_a(n-1)=b^{n-1}\\left(\\binom{2n}n-\\binom{2n-1}{n}\\right)=b^{n-1}\\binom{2n-1}{n-1}\\\\ g_a(n)=b^n\\binom{2n+1}{n} g_a(n)= \\begin{cases} \\frac 1{1-a}\\left(b\\times g_a(n-1)+\\binom{2n-1}{n}a^nb^n-\\binom{2n}{n}a^{n+1}b^n\\right),&a\\neq 1\\\\ b^n\\binom{2n+1}{n},&a=1\\\\ \\end{cases}同理 g_b(n)= \\begin{cases} \\frac 1{1-b}\\left(a\\times g_b(n-1)+\\binom{2n-1}{n}b^na^n-\\binom{2n}{n}b^{n+1}a^n\\right),&b\\neq 1\\\\ a^n\\binom{2n+1}{n},&b=1\\\\ \\end{cases}然后递推的时候直接 $f_n=f_{n-1}+g_a(n)+g_b(n)-\\binom{2n}{n}a^nb^n$ 非常优质 cf958F相当于求一堆 $1+x+x^2+x\\cdots$ 的积的某一项 直接分治FTT常数可能有点问题 改成启发式合并，用个堆维护当前最小的多项式的 $size$ ，每次合并果子一样合并就行了 cf623E每个数至少使“前缀或”多一位的 $1$，最多 $k$ 位所以当 $n&gt;k$ 时直接puts(&quot;0&quot;) 所以现在 $n,k$ 同阶了 感觉其他人搞得状态有点麻烦就自己搞了一种（然后发现差不多麻烦） 令 $f_{i,j}$ 表示前 $i$ 个数，一共在 $j$ 个位置下有 $1$ 的方案数，注意这 $j$ 个位置是在 $k$ 中的 最后答案就是 $\\sum_{i=1}^kf_{n,i}$ 一开始想的转移是 $f_{x,i}\\times \\binom{k-i}{j} 2^i \\to f_{x+1,i+j}$ 然后发现这个转移太慢了，每次似乎可以转移多个数： f_{x,i}\\times f_{y,j}\\times \\binom{k-i}{j}\\times 2^{yi}\\to f_{x+y,i+j}那个 $2^{yi}$ 是因为对于右边的 $y$ 个数的每一个来说，左边 $i$ 位可以任选 $0/1$ 所以是 $(2^i)^y=2^{iy}$ 然后高兴地打了个分治，然后样例就挂了 因为这个 $f_{y,j}$ 是考虑了 $j$ 位在 $k$ 中的位置的，而我们的 $\\binom{k-i}{j}$ 相当于已经给这 $j$ 位确定了位置 所以 $f_{y,j}$ 还要除以 $\\binom{k}{j}$ 才是不考虑在 $k$ 中顺序的方案数 转移即为 f_{x,i}\\times \\frac{f_{y,j}}{\\binom{k}{j}}\\times \\binom{k-i}{j}\\times 2^{yi}\\to f_{x+y,i+j}然后又调了一年： fft精度差要+0.5 每次 $w\\times=wn$ 时精度丢失也很严重","categories":[{"name":"总结","slug":"总结","permalink":"https://buzhibujue.cf/categories/总结/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://buzhibujue.cf/tags/NTT/"},{"name":"数学","slug":"数学","permalink":"https://buzhibujue.cf/tags/数学/"},{"name":"FFT","slug":"FFT","permalink":"https://buzhibujue.cf/tags/FFT/"}]},{"title":"cf886E","slug":"cf886E","date":"2020-02-05T02:43:37.000Z","updated":"2020-05-03T15:35:10.000Z","comments":true,"path":"2020/02/05/cf886E/","link":"","permalink":"https://buzhibujue.cf/2020/02/05/cf886E/","excerpt":"","text":"cf886E Description对于一个 $n$ 个数的排列，定义这个排列的极大值为第一个满足它比后面的 $k$ 个数都大的数（如果后面不足 $k$ 个则只需要比后面的数大即可） 给定 $n,k$ 求有多少个长为 $n$ 的排列满足其极大值不为 $n$，对 $10^9+7$ 取模。 Input一行两个整数 $n,k$ $n,k\\leq 10^6$ Output一行一个整数，即满足条件的排列个数 Sample Input15 2 15 3 16 3 Sample Output122 16 184 Hint样例二的所有情况：$[4,1,2,3,5] , [4,1,3,2,5], [4,2,1,3,5] , [4,2,3,1,5] , [4,3,1,2,5] , [4,3,2,1,5] .$ Solution考虑容斥计算所有合法的情况 定义 $f_i$ 为 $i$ 个数极大值在最后 $k$ 个中（如果 $i&lt;k$ 则任意）的排列数（可以发现这时最大值一定等于极大值））。 （这样定义是因为在后面接上一个更大的数则极大值就一定不在这前面 $i$ 个数之中） 转移是枚举这 $i$ 个数中的最大值 $i$ 在最后 $k$ 个数中的哪一个，右边任意排列且左边的极大值在左边的最后 $k$ 个中（这样才能被新加入的 $i$ 覆盖掉）的方案数 \\begin{aligned} f_n&=\\sum_{i=n-k+1}^nf_{i-1}\\times \\binom{n-1}{i-1}\\times (n-i)! \\\\&= \\sum_{i=n-k+1}^nf_{i-1}\\times \\frac{(n-1)!}{(i-1)!} \\\\&= (n-1)!\\sum_{i=n-k+1}^n\\times \\frac{f_{i-1}}{(i-1)!} \\end{aligned}可以通过计算 $\\frac{f_i}{i!}$ 的前缀和来加速转移 所有极大值等于 $n$ 的排列数就是：枚举 $n$ 的位置 $i$ ，在 $n-1$ 个数中选 $i-1$ 个放到左边且前面 $i-1$ 个数的极大值在这 $i-1$ 个数的最后 $k$ 个之中（这样整个排列的极大值才会被覆盖成 $n$），后面任意排的方案 \\begin{aligned} ans&=n!-\\sum_{i=1}^nf_{i-1}\\times\\binom{n-1}{i-1}\\times(n-i)! \\\\&=n!-(n-1)!\\sum_{i=0}^{n-1}\\frac{f_i}{i!} \\end{aligned}复杂度 $O(n)$ Code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"cf886E\"#define mul3(a,b,c) mul(mul(a,b),c)using namespace std;const int N=1e6+5,MOD=1e9+7;inline int add(int a,const int &amp;b)&#123;return (a+=b)&gt;=MOD?a-MOD:a;&#125;inline int sub(int a,const int &amp;b)&#123;return (a-=b)&lt; 0?a+MOD:a;&#125;inline int mul(const int &amp;a,const int &amp;b)&#123;return 1ll*a*b%MOD;&#125;inline int&amp; inc(int &amp;a,const int &amp;b)&#123;return a=add(a,b);&#125;inline int&amp; dec(int &amp;a,const int &amp;b)&#123;return a=sub(a,b);&#125;inline int&amp; pro(int &amp;a,const int &amp;b)&#123;return a=mul(a,b);&#125;inline int qpow(int a,int b)&#123;int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;&#125;int fac[N],inv[N],invc[N];inline int C(const int &amp;a,const int &amp;b)&#123;return mul3(fac[a],invc[b],invc[a-b]);&#125;int n,k,f[N],g[N],pre[N];int main()&#123; freopen(FIO\".in\",\"r\",stdin); //freopen(FIO\".out\",\"w\",stdout); fac[0]=fac[1]=inv[0]=inv[1]=invc[0]=invc[1]=1; for(int i=2;i&lt;N;i++) fac[i]=mul(fac[i-1],i),inv[i]=mul(MOD-MOD/i,inv[MOD%i]),invc[i]=mul(invc[i-1],inv[i]); scanf(\"%d%d\",&amp;n,&amp;k); f[0]=pre[0]=1; for(int i=1;i&lt;=n;i++)&#123; f[i]=mul(fac[i-1],sub(pre[i-1],i&gt;=k+1?pre[i-k-1]:0)); pre[i]=add(pre[i-1],mul(f[i],invc[i])); &#125; printf(\"%d\\n\",sub(fac[n],mul(fac[n-1],pre[n-1]))); return 0;&#125;","categories":[{"name":"codeforces","slug":"codeforces","permalink":"https://buzhibujue.cf/categories/codeforces/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://buzhibujue.cf/tags/计数/"},{"name":"容斥","slug":"容斥","permalink":"https://buzhibujue.cf/tags/容斥/"}]},{"title":"THUWC2020","slug":"THUWC2020","date":"2020-01-21T13:50:01.000Z","updated":"2020-08-28T14:20:05.393Z","comments":true,"path":"2020/01/21/THUWC2020/","link":"","permalink":"https://buzhibujue.cf/2020/01/21/THUWC2020/","excerpt":"","text":"THUWC2020Day1T1桌上写着 k 个数有 k 个人先后依共 n 次来到桌上，每次手上拿着新的 k 个数。如果第 i 次来的第 pi 个人找到桌上写的 k 个数字中的他的数字严格小于他手上当前拿的 k 个数字中他所对应的数字，则把桌上的 k 个换成自己手上的 k 个数字。 n 1e5k 20 解法 :二分加线段树查区间 max 两个log本地极限数据1s直接过了改成线段树上二分一个log 本地0.4秒 T2有 n个点 m条边有边权的有向图，每次指定一个起点和最多走的步数 s ，每次在一个点选择出边到的点编号最小的，问最后到那个点停下。停下就是走完了限定的步数或者没有出边了。(经过一个边就把权值减一，权值为0就没那条边了) n m 1e5w 1e18s 1 e9 解法:同一时刻所有的边的情况只可能是棵基环树森林使用 lct 维护 T3给定一颗树和一个整数 X 。每次询问一个标号区间的点内的新图的连通块个数，两个点在新图中有连边当且仅当它们之间距离小于等于 X。 n 3e5m 6e5X＜n 解法: DAY2T1给定 n 个形如 a|x|+bx+c 的函数和初值 s 要求排列 n 个函数使得最终结果最大n a b c 绝对值15 解法:如果 c等于 0 则转移只跟是正数还是负数有关 记录最大最小即可否则由于 c 的缘故可能把正负性改了于是记录-1515到+1515是否能表示以及最大最小值来做n*2∧n dp即可 T2给定 m 条有向边 保证不存在环 使用dfs 的方法建出一颗外向树。每次询问 ban 掉 u 到 v 的树链后 v 子树内不可达节点个数，保证询问的 u 一定是 v 祖先 m q 1e5 解法: 半支配点相关 T3给定一棵树，每个点上有值且不重复每次询问提取一条链后形成的一个排列有多少种排列进行 k 次冒泡排序的第二步后会形成该链的排列 n q 1e5 解法:n方都不会。。。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/tags/随笔/"}]},{"title":"csp2019游记","slug":"CSP2019游记","date":"2019-11-24T15:28:15.000Z","updated":"2020-05-03T15:33:54.000Z","comments":true,"path":"2019/11/24/CSP2019游记/","link":"","permalink":"https://buzhibujue.cf/2019/11/24/CSP2019游记/","excerpt":"","text":"CSP2019 游记转眼就过了一年，去年看着高二学长的状态就感觉他们的心境会和当时的我完全不同，现在看来的确如此。在这样事关重大的赛季伊始，过去的种种都不影响了，现在一个失误就可能葬送全局1，即使平时自诩心态还行的我也在考前有些许担心。 Day 1开场看到三道题后两道没大看懂怎么做，剩下 T1 试着在脑中回想一下格雷码的构造无果一看题意才发现直接给出了构造（然而要是考到构造明明见过却记不住，这也许是平时看书当做消遣却不认真记录的后果），直接写了个递归（有趣的是 SCOI2019 D1T1 也直接写了个递归以为可以过就没管了最终挂 50）想了下大概需要开 unsigned，然后一遍过了所有样例感觉还行但极限数据 $n=64,k=2^{64}-1$ 时却输出不正确，乱改一通没什么作用，把左移的一些东西预处理出来才过。（考后得知因为左移 64 位是 ub（undefined behavior） 所以可能挂，而且题面中还有一个 $95$ 分的部分分是专门给没开 unsigned 的选手，居然没有发现这个提示） 第二题主要问题是求以一个节点结尾的合法括号序列个数，这个感觉很熟悉但考场上只想到了要求个区间 min 的多带了个 $\\log$ 的辣鸡做法，还很难写导致调了巨久。在 Windows 下开栈过了最后一个样例。（写完那个 min 的判断后直觉感觉可以再优化但数据范围已经可以过了就没管） 第三题一开始以为是简单题，试着猜结论例如一条链只能覆盖一遍或者一条边只能『传』两个东西到彼此的对面，感觉样例很强就打算先写再看能不能过样例，花很长时间写了一堆线段树的东西发现过 RE，调完 RE 后过不了样例一，调完样例一才发现算法是假的而且根本修不了（中途想到了直接按边拓扑排序但是又随手造了组数据卡掉了）在没确认算法可以通过所有小样例的情况下写题，这是策略的巨大失误（原因的话我想可能主要是去年 NOIP 的 D1T3 并不难，当时就是大概感觉从小到大排序或者从大到小排就行，先把代码写完最后来调，幸好最后十分钟调出来了）导致这次对难度的预估不够）（经验主义害人）（然而 CSP 和 NOIP 没有任何关系）又试着思考一下链和菊花的部分分发现都没有任何思路，要是知道思路细节多还可以慢慢调，但当时是完全连思路都没有，感觉需要特判的条件数不胜数，搞得整个人头晕脑胀。之后可能只剩一个小时了还没有测代码在 Linux 的编译是否通过，急匆匆 rush 了个 10 分暴力打开虚拟机，发现其他样例都能过就 T2 最后一个大样例不输出弹出一个： 『已杀死』？ 我转念一想是不是没开栈？使用只有模糊记忆的命令 ulimit unlimited ，再测发现毫无作用，再凭借几乎没有的英语理解认为开栈空间就是开内存嘛，内存 = memory，所以打了一遍 ulimit -m unlimited 还是无用，当时心态就完全崩了，这 T3 一个高点的部分分没写 T2 还过不了？那不是当场退役？（主要还是去年 NOIP Day1 几乎人均 AK 导致对于 D1T3 的难度没有正确认识，以往几届 D1T3 并没有去年那么简单，然而我几乎没有系统做过往年题目又导致这个认识并没有解决） 最后半个小时各种乱改乱删，平时的代码整洁度都没有管了，只要能过！然而并没有任何作用，在 Windows 下开栈后完美运行的程序在 Linux 下就是跑不出来，写个中间过程的输出结果输出到一半就『已杀死』了，把一个调用求 min 的函数注释掉后就能跑完（这让我又确认了不是栈空间的问题，因为我凭感觉认为调用后的程序栈空间会和调用前完全一样，那么注释掉的那个函数一定是写成 ub 了。最后半小时的各种细节暂且不表，只记得最后看着各种增删填补的像扭曲污秽的打着各种补丁冒着黑烟滴着黑油的废土中的早已不能入眼的程序仍然只返回一个冰冷的『已杀死』时就像是自身也被『已杀死』那样的内心浓烈的绝望与无力感以及之前被当做玩笑话说过无数次但它可能就要发生在自身上的颓丧的一句： 也许，我就要退役了。 （最后五分钟时监考人员来收草稿纸，然而我并没有交，感觉交了就像递交了战争中的投降协议完全放弃了一般，但是到结尾也没能调出来的那种感觉或许只有完全经历过的菜人才能理解吧。） （最后出来 210 的人应该不少，还算守住了标准分） （有班上的神妹 T3 AC T2写挂分还是比我高，实力差距啊） （最后出来有人告诉我是 ulimit -s 因为栈空间是指栈 stack 和内存 memory 是两个东西。当时的想法可能有许多：如果我早知道这个或许最后半小时能多拿一个 T3 的部分分？我平时都用的 Linux 却把开栈的命令记错了？可能种种都有，最主要的只有希望它的确是因为这个的缘故被卡的） Day 2T1 看到题想到是容斥+背包（D2T1 考 998244353 ，真有你的），T3 部分分似乎很多，T2像是斜率优化。（顺带确认了下默认的虚拟机是没开栈的，昨天似乎确实是没开栈的问题） 中间过程暂且不提，最终 T1 写的太久 T2 先想到了个 $O(n^2)$ 感觉可以优化成 $O(n)$ 写完发现是假的过不了样例 3，写了个边界可能有误的 $O(n^2)$ 过不了任何一个样例，最后只能写个 $O(n^3)$ 匆忙跑路。T3 部分分有 75 比昨天 T3 良心多了就没去想正解（时间安排也只留了 75 分）（要是有足够的实力也就不会这样『限制自己』的时间了吧，也是以为 T2 比 T3 简单，但真正有实力的选手 T1 会几分钟内解决，T2 第一遍 $O(n)$ 就可以直接过掉所有大样例，也不会存在没时间想 T3 正解的情况）写完后尝试改 T2 边界无果，最终老师又来收草稿纸选择了交出去，像是认同了事先预料到的这样的结果一样，大致检查了下文件就到时间了。模拟考许多人会的题不会，正式考试又能『超常发挥』到哪去呢？ （出来的时候的确基本上同班的所有人都会 $O(n^2)$ ，又如 THUSC 一样掉在了没拿满标准分的坑里，不过实力比不过也确实是只有认栽吧） （写这篇不知道在写什么的东西时候有的班上同学已经改完了今天的题，我却半点没动，实力啊） 总结： 目前为止成绩没出，在班上各种民间数据是处于倒三的状态，至少应该能去 THUWC ，NOIWC 不清楚不过不是重点，至少希望接下来几个月能提高点实力 1. ——LOL 英雄卡莎 &#8617; 写到这忽然想写一些一直想写的毫无作用的碎碎念，（如果这次退役了以后就没机会写了）对游戏有 PTSD 的可以关掉了：其实一直以来有个感觉就是 OI 和电子竞技有着许多类似之处（比如都是用电脑打比赛？），（比如CSP 考前一个月正好是 LOL S9 全球总决赛）。今年最终夺冠的是一支赛前人气并不是很高的来自中国赛区的战队，但比起这支战队来说，另两只中国赛区的战队『似乎』队内都有着更强的选手，但却都没有走到最后的领奖台上，个人认为主要是因为他们都或多或少有着某个致命的缺陷或短板，能看出来的是只有最强的一个人可能不能带领全队走向胜利，但有着默契协同和完美配合的五个人可能加起来会产生远远大于五的效果（并且这支队伍还有一个完美的节奏发动机）。感觉就和 OI 中各个板块类似，一个人只精通某些类型但比赛可能完全不考那类题，就会陷入毫无用武之地，你需要至少能做出每个版块的中档位置的题最好还有一个精通的版块才有希望考出理想的成绩。 另一个方面来看是：能走到全球总决赛的舞台上的（至少纸面实力上）无一是弱旅，但正式比赛中却常有出现『不知道该怎么赢』，就是团战有来有回两边看上去还差不多，实际上两边的实力有着天壤之别，在暗中两者的经济差早已拉开，劣势的一方只是在像无头的苍蝇一样四处乱撞，一步步走向优势方的陷阱中最终被一波击溃。这或许和平时模拟赛大家都看上去考的都差不多，背后的实力差别却可能早已产生，像是温水煮青蛙一样，可能最终的一次重要考试在『打醒』某些人时就会一并将其『打死』了。（目前看来我可能还没有陷入被『打死』这个境地，顶多是一次『打醒』吧）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/tags/随笔/"}]},{"title":"洛谷5577","slug":"洛谷5577","date":"2019-11-08T08:23:54.000Z","updated":"2020-05-03T15:36:14.000Z","comments":true,"path":"2019/11/08/洛谷5577/","link":"","permalink":"https://buzhibujue.cf/2019/11/08/洛谷5577/","excerpt":"","text":"洛谷5577 Description$n$ 个不超过 $m$ 位的 $k$ 进制数，每次随意取出一些数 （注意可以一个数都不选）， 然后把这些数进行 $k$ 进制下不进位加法。 求最终 $0\\sim k^m-1$ 的每个数字被表示出来的方案数对 $998244353$ 取模 Input第一行三个整数 $n,k,m$ 意义为题目中所述。 第二行 $n$ 个整数，之间用空格隔开，表示纸条上的数字。 （注意 , 纸条上的数均为 $k$ 进制数） Output 共 $k^m$ 行，你需要在第 $i$ 行输出最终得到数字 $i−1$ 的方案数模 $998244353$ 的值。 Sample Input 123 5 11 2 3 Sample Output 1234522121 Constraints$n\\leq 10^6$$k=5$ 时 $m\\leq 7$$k=6$ 时 $m\\leq 6$ Solution答案是形如 $\\prod_{i=1}^n(1+x^{a_i})$ 的所有项的系数并且此处卷积的定义是：两个下标乘起来得到的下标是这两个下标的 $k$ 进制下不进位加法得到的值。 于是就有了个 $O(nk^m)$ 的优质做法：每次加入一个数就枚举所有下标并更新它乘上 $1+x^{a_i}$ 到达的位置。可以获得 20pts 的好成绩 如果这是普通的多项式乘法那么直接对于每个数 DFT 一遍算出许多点值再对应乘起来再把这些点值 IDFT 回去就是答案。 然后你大概感性理解意会一下题目中的「 $k$ 进制下不进位加法」的卷积其实也可以类似的做：把每个下标看成一个 $m$ 维的向量 $\\mathbf{V}=\\{v_0,v_1,v_2,\\cdots v_{m-1}\\}$ 且其中每一位 $v_i&lt;k$ （就是 $k$ 进制下的每一位），那么一个下标 $\\mathbf{V}=\\{v_0,v_1,v_2\\cdots,v_m\\}$ 和 $\\mathbf{U}=\\{u_0,u_1,u_2,\\cdots u_{m-1}\\}$ 的卷积 $\\mathbf{V\\cdot U}=\\{(v_0+u_0)\\mod k,(v_1+u_1)\\mod k,\\cdots,(v_{m-1}+u_{m-1})\\mod k\\}$ 就是向量中对应的每一位在模 $x^k$ 意义下的循环卷积。 循环卷积的例子：模 $x^5$ 意义下的 $x^3\\cdot x^4=x^7$ 就变成了 $x^2$ 我们尝试对于一个 $1+x^{a_i}$ 如何进行 $m$ 维下的 DFT 回想一下一般的一维 DFT 含义：对于第 $i$ 项系数它对 DFT 的结果中位置 $j$ 的贡献的系数是 $\\omega^{ij}$ 二维的话位置 $(Ax,Ay)$ 对位置 $(Bx,By)$ 的贡献就是 $\\omega^{AxBx}\\cdot\\omega^{AyBy}=\\omega^{AxBx+AyBy}$ 直接先对每一行 DFT 再对每一列 DFT 就行 那么似乎可以直接套到多维上去：对于一个向量 $\\mathbf{U}=\\{u_0,u_1,\\cdots u_{m-1}\\}$ ，其对结果中位置 $\\mathbf{V}=\\{v_0,v_1,\\cdots,v_{m-1}\\}$ 的贡献是 $\\omega^{u_0v_0}\\cdot\\omega^{u_1v_1}\\cdots\\omega^{u_{m-1}v_{m-1}}=\\omega^{u_0v_0+u_1v_1+\\cdots+u_{m-1}v_{m-1}}$ 回到题目。 因为模 $998244353$ 意义下不存在 $\\omega_5$ 和 $\\omega_6$ 的整数解，但我们又需要表示出 $\\omega_5$ 和 $\\omega_6$ ，以下内容均在扩域后的意义下进行 即把每个「数」看成是 $a_0\\omega_k^0+a_1\\omega_k^1+\\cdots+a_{k-1}\\omega_k^{k-1}$ 易证这个域里的「数」满足加法和乘法的封闭性 结合 20pts 做法，注意到每次乘上的只有两项，其中 $1=x^0=x^{\\{0,0,\\cdots,0\\}}$ 它对所有位置都会造成 $\\omega_k^{0+0+\\cdots+0}=1$ 的贡献；而 $x^{V}=x^{\\{v_0,v_1,\\cdots,v_{m-1}\\}}$ 对于每个位置 $\\mathbf{U}=\\{u_0,u_1,\\cdots u_{m-1}\\}$ 会造成 $\\omega_k^{u_0v_0}\\cdot\\omega_k^{u_1v_1}\\cdots\\omega_k^{u_{m-1}v_{m-1}}=\\omega_k^{u_0v_0+u_1v_1+\\cdots+u_{m-1}v_{m-1}}$ 的贡献 那我们对于 $n$ 个数可以每次 DFT 得到 $k^m$ 个形如 $1+\\omega_k^{t}$ 的的点值，一共求 $n$ 遍对于每一位把它对应的 $n$ 个 $1+\\omega_k^t$ 乘起来最后再 IDFT 回去就是答案 这样做复杂度可能是 $O(n(k^m\\times k^2))$ 的无疑是过不了的。 但是发现 $n$ 的范围很大但 $k^m$ 却小得多似乎指引我们按照值域做。 仔细一想对于某一位来说，似乎并不需要求出所有的 $n$ 个 $1+\\omega_k^t$ 分别是多少，只需要对于每个 $t\\in[0,k-1]$ 知道有多少个 $1+\\omega_k^t$ 就行了（只需要个数，至于它们具体属于 $n$ 个中的哪几个是无关紧要的） 那问题就转化为有 $n$ 个数 $\\mathbf{V_1,V_2,\\cdots,V_{n}}$ ，每一项对于位置 $\\mathbf{U}$ 的贡献都是上面那个很长的式子。求对于每个位置 $\\mathbf U$ 的每个 $t\\in[0,k-1]$ ，在这 $n$ 个数中有多少个数对于他的贡献是 $\\omega_k^t$ 这东西看上去异常的难以下手，出题人的标程里写的好像是什么奇奇怪怪的折半引理消去引理的奇淫技巧看不懂 讨论区里又有一位 djq 大爷说是什么单位根反演，但（道理我都懂板子我都抄过，哪里有单位根反演啊/晕） 然后我不知道怎么搞直接把每个值对应下标加一然后做一遍 DFT ，令人惊奇的发现它！就！对！了！ （我写到这里一看上面我写的，就想问自己，这**为什么不对啊） 但这里给读者讲一下（也给将来的我自己）（看懂的就直接跳过好了）： 大概是对应下标加一后位置 $\\mathbf V$ 的系数就是这个 $\\mathbf{V}$ 出现的次数，对于每一个 $\\mathbf V$ 它对于每个下标 $\\mathbf U$ 的影响都是个定值 $\\omega_k^t$ 。那么有 $a_{\\mathbf V}$ 个，贡献就是 $a_{\\mathbf V}\\omega_k^t$ 。那么我们直接把这 $a_V$ 个一起做 DFT 肯定是没有问题的（我们每次是 $a_{\\mathbf V}$ 加一（而没有改变后面的 $\\omega_k^1,\\omega_k^2\\cdots $ 的项的系数 ），所以最后乘出来对于每个位置的贡献确实就是 $\\omega_k^t$ 有多少个算多少个）感觉跟没讲一样，有啥问题评论区问吧 现在我们知道了对于一个位置 $\\mathbf U$ 和 $t\\in[0,k-1]$ 有多少个数最后对其的贡献是 $\\omega_k^t$ （记为 $a(\\mathbf V,t)$ 。那么这些数点积时都会是 $1+\\omega_k^t$ 的形式，那么最后点积出来位置 $\\mathbf V$ 的值就是 $\\prod_{t=0}^{k-1}(1+\\omega_k^t)^{a(\\mathbf V,t)}$ 最后再做一遍 IDFT 就能得到最终的答案了，总复杂度大概是 $O(k^{m+2}\\sim k^{m+3})$ 左右，如果快速幂没有预处理（见实现细节）可能还要多个 $\\log n$ 好你就这样高高兴兴的写完然后输出每个答案 ( $a_0\\omega_k^0+a_1\\omega_k^1+\\cdots+a_{k-1}\\omega_k^{k-1}$ ) 中的 $a_0$ 就发现样例都过不了？？？ 你一看题解发现要输出 $a_0+a_1-a_2-a_3$ 才行？？？而且写了就直接能过？？？ 如果你做过 cf1103E 的话可能也会对洛谷上唯一的题解里最终输出的是 a[i].a[0]-a[i].a[4] 而不是 a[i].a[0] 感到疑惑（然而题解并没有提到这个 magic number 是哪来的（以及他把 $\\omega_{10}$ 写成 $-\\omega_5^3$ 为啥是对的都没有解释，像我等蒟蒻看的真是难受）） 这里就方便一下我等蒟蒻略作证明（不需要的可以跳过看代码了）： $k=5$先说结论：可以证得：$a_1=a_2=a_3=a_4$ （可以像那篇题解一样「带进去检验」，然而对于我等来说真不容易） 我的证法是：你可以发现最终这个东西一定是个整数，并且无论我们把 $\\omega_5^1,\\omega_5^2,\\omega_5^3,\\omega_5^4$ 中的哪一个带入答案都会是整数（这个我确实不会证，应该和 FFT 最后会是不带虚部的实数是同一个原因） 那么我们在复平面中画出所有的 $\\omega_5$ 的幂 我们最后要得到 $a_0\\omega_5^0+a_1\\omega_5^1+a_2\\omega_5^2+a_3\\omega_5^3+a_4\\omega_5^4$ 是一个不带虚部的整数 有 \\begin{cases} x=a_0+a_1\\sin18^{\\circ}+a_4\\sin 18^{\\circ}-a_2\\cos 36^{\\circ}-a_3\\cos 36^{\\circ}\\in \\mathbf Z \\\\ y=a_1\\cos 18^{\\circ}-a_4\\cos 18^{\\circ}+a_2\\sin 36^{\\circ}-a_3\\sin 36^{\\circ}=0 \\end{cases}而 $\\sin 18^{\\circ}=\\frac{\\sqrt 5-1}4,\\cos 18^{\\circ}=\\frac{\\sqrt{10+2\\sqrt 5}}4,\\sin 36^{\\circ}=\\frac{\\sqrt{10-2\\sqrt 5}}4,\\cos 36^{\\circ}=\\frac{1+\\sqrt 5}4$ 所以得到 \\begin{cases} a_0+(a_1+a_4)\\sin 18^{\\circ}-(a_2+a_3)\\cos 36^{\\circ}=a_0+(a_1+a_4)\\frac{\\sqrt 5-1}4-(a_2+a_3)\\frac{\\sqrt 5 +1}4\\\\=\\frac {\\sqrt 5 }4(a_1+a_4-a_2-a_3)+\\frac 14(4a_0-a_1-a_4-a_2-a_3)\\in \\mathbf Z\\\\ (a_1-a_4)\\cos 18^{\\circ}+(a_2-a_3)\\sin 36^{\\circ}=(a_1-a_4)\\frac{\\sqrt{10+2\\sqrt 5}}4+(a_2-a_3)\\frac{\\sqrt{10-2\\sqrt 5}}{4}=0 \\end{cases}又因为 $a_0,a_1,a_2,a_3,a_4\\in \\mathbf Z$ ，由上面的第二个式子得到 $a_1-a_4=a_2-a_3=0$ ，又由第一个式子得到 $a_1+a_4-a_2-a_3=0$ 于是就有 $a_1=a_2=a_3=a_4$ 实际上不严谨的证明大概想一下上下对应的系数一定相同才能使得最后 $y$ 被抵消完落在 $x$ 轴上成为不带虚部的整数，左右两边如果相同的话就是 $\\cos 72^{\\circ}-\\cos 36^{\\circ}=-\\frac 12$ 是个有理数 感觉是对的 知道这个后求值就很简单了： \\begin{aligned} &a_0\\omega_5^0+a_1\\omega_5^1+a_2\\omega_5^2+a_3\\omega_5^3+a_4\\omega_5^4 \\\\=& a_0+a_1(\\omega_5^1+\\omega_5^2+\\omega_5^3+\\omega_5^4) \\\\=& a_0+a_1(\\frac{\\omega_5-\\omega_5^5}{1-\\omega_5}) \\\\=& a_0-a_1 \\end{aligned}当然也可以直接用刚才三角函数的式子： $x=\\frac {\\sqrt 5 }4(a_1+a_4-a_2-a_3)+\\frac 14(4a_0-a_1-a_4-a_2-a_3)=a_0-a_1$ $k=6$也差不多，不知道其他人怎么证的我还是画了个图： 和刚才类似的，我们可以得到 \\begin{cases} x=a_0+a_1\\cos 60^{\\circ}-a_2\\cos 60^{\\circ}-a_3-a_4\\cos 60^{\\circ}+a_5\\cos 60^{\\circ}\\in \\mathbf Z\\\\ y=a_1\\sin 60^{\\circ}+a_2\\sin 60^{\\circ}-a_4\\sin 60^{\\circ}-a_5\\sin 60^{\\circ}=0 \\end{cases}$\\sin 60^{\\circ}=\\frac{\\sqrt 3}2,\\cos 60^{\\circ}=\\frac 12$ ，我们得到 $a_1+a_2-a_4-a_5=0$ 以及 $x=a_0-a_3+\\frac 12(a_1-a_2-a_4+a_5)\\in \\mathbf Z$ 这里并不能保证上下对应位置的系数相等了（即不能保证 $a_1=a_2=a_4=a_5$ ），但由 $a_1+a_2-a_4-a_5=0$ 可以得到 $a_1-a_4=a_5-a_2$ 得到 $x=a_0-a_3+\\frac 12(a_1-a_4+a_5-a_2)=a_0-a_3+a_1-a_4$ 答案就是 $a_0+a_1-a_4-a_3$ （题解里好像是 $a_0+a_1-a_2-a_3$ 所以应该可以证明 $a_2=a_4,a_1=a_5$ ？感觉我还不会证，欢迎交流。反正打表出来是对的那我们就当它是对的 ） 一些实现上的细节 求 $1+\\omega_k^t$ 在 $t=0$ 的时候是 $1+1=2$ 注意不要对应系数直接赋值成 $1$ 了 $(1+\\omega_k^t)^{a(\\mathbf V,t)}$ 的时候快速幂可能被卡常，可以预处理出 $(1+\\omega_k^t)^{1000}$ 的幂来加速 $k=5$ 也可以用 $a_0+a_1-a_2-a_3$ 表示（ $=a_0-a_1$ ）不用分类讨论 DFT 时的单位根只有一项有值，可以把 $O(k^2)$ 的乘法优化成 $O(k)$ 我太懒了就没写 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;#define FIO \"P5577\"#define ll long longchar buf[1&lt;&lt;20]; int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read (T &amp;x,const int &amp;bas=10) &#123; T f=1; x=0; char ch=getch; for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getch); if (ch=='-')f=-1,ch=getch; for (; isdigit (ch); ch=getch)x=x*bas+ch-'0'; x*=f;&#125;const int MOD=998244353,V=6,N=pow(5,7)+5;inline int add(int a,const int &amp;b)&#123;a+=b;return a&gt;=MOD?a-MOD:a;&#125;inline int sub(int a,const int &amp;b)&#123;a-=b;return a&lt; 0?a+MOD:a;&#125;inline int mul(const int &amp;a,const int &amp;b)&#123;return 1ll*a*b%MOD;&#125;inline int&amp; inc(int &amp;a,const int &amp;b)&#123;return a=add(a,b);&#125;inline int&amp; dec(int &amp;a,const int &amp;b)&#123;return a=sub(a,b);&#125;inline int&amp; pro(int &amp;a,const int &amp;b)&#123;return a=mul(a,b);&#125;inline int qpow(int a,int b)&#123;int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;&#125;int n,k,m;struct Com&#123; int a[V]; inline void clear()&#123;a[0]=a[1]=a[2]=a[3]=a[4]=a[5]=0;&#125; inline Com()&#123;clear();&#125; inline int&amp; operator [](int x)&#123;return a[x];&#125; inline const int&amp; operator [](const int &amp;x)const&#123;return a[x];&#125; inline Com operator +(const Com &amp;b)const&#123;Com c;for(int i=0;i&lt;k;i++)c[i]=add(a[i],b[i]);return c;&#125; inline Com operator -(const Com &amp;b)const&#123;Com c;for(int i=0;i&lt;k;i++)c[i]=sub(a[i],b[i]);return c;&#125; inline Com operator *(const int &amp;b)const&#123;Com c;for(int i=0;i&lt;k;i++)c[i]=mul(a[i],b);return c;&#125; inline Com&amp; operator +=(const Com &amp;b)&#123;return *this=*this+b;&#125; inline Com&amp; operator *=(const int &amp;b)&#123;return *this=*this*b;&#125; inline Com operator *(const Com &amp;b)const&#123; static ll r[V&lt;&lt;1]; const ll Moc=8ll*MOD*MOD; for(int i=0;i&lt;k;i++)if(a[i])for(int j=0;j&lt;k;j++)if(b[j])&#123; r[i+j]+=1ll*a[i]*b[j]; if(r[i+j]&gt;=Moc)r[i+j]-=Moc; &#125; Com c; for(int i=0;i&lt;k;i++)c[i]=(r[i]+r[i+k])%MOD,r[i]=r[i+k]=0; return c; &#125; inline Com&amp; operator *=(const Com &amp;b)&#123;return *this=*this*b;&#125; inline void out()&#123;for(int i=0;i&lt;k;i++)printf(\"%d%c\",a[i],i^(k-1)?' ':'\\n');&#125; inline int val()&#123; return sub(add(a[0],a[1]),add(a[2],a[3])); &#125;&#125;a[N],w[2][V],b[N];inline void pre()&#123; w[0][0][0]=w[1][0][0]=1; w[0][1][1]=w[1][1][k-1]=1; for(int i=2;i&lt;k;i++) w[0][i]=w[0][i-1]*w[0][1],w[1][i]=w[1][i-1]*w[1][1];&#125;//inline Com qpow(Com a,int b)&#123;Com c;c[0]=1;for(;b;b&gt;&gt;=1,a*=a)if(b&amp;1)c*=a;return c;&#125;const int B=1000;Com pw0[B+5],pw1[B+5];inline Com qpow(Com a,int b)&#123;return pw1[b/B]*pw0[b%B];&#125;inline void getpow()&#123; for(int i=0;i&lt;n;i++)b[i][0]=1; for(int i=0;i&lt;k;i++)&#123; Com omega; //!!! i=1 gg omega[0]=1;omega[i]++; pw0[0][0]=pw1[0][0]=1; for(int i=1;i&lt;=B;i++)pw0[i]=pw0[i-1]*omega; pw1[1]=pw0[B]; for(int i=1;i&lt;=B;i++)pw1[i]=pw1[i-1]*pw1[1]; for(int id=0;id&lt;n;id++)b[id]*=qpow(omega,a[id][i]); &#125; for(int i=0;i&lt;n;i++)a[i]=b[i];&#125;int pw[V];inline void fft(int opt)&#123; pw[0]=1;for(int i=1;i&lt;m;i++)pw[i]=pw[i-1]*k; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++) if(!((j/pw[i])%k))&#123; static Com f[V]; for(int x=0;x&lt;k;x++) for(int y=0;y&lt;k;y++) f[y]+=a[j+pw[i]*x]*w[opt][x*y%k]; for(int x=0;x&lt;k;x++) a[j+pw[i]*x]=f[x],f[x].clear(); &#125; &#125; if(opt)for(int i=0,inv=qpow(n,MOD-2);i&lt;n;i++)a[i]*=inv;&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); read(n);read(k);read(m); for(int i=1,x;i&lt;=n;i++)read(x,k),a[x][0]++; n=qpow(k,m); pre(); fft(0); getpow(); fft(1); for(int i=0;i&lt;n;i++)printf(\"%d\\n\",a[i].val()); return 0;&#125;","categories":[{"name":"洛谷","slug":"洛谷","permalink":"https://buzhibujue.cf/categories/洛谷/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://buzhibujue.cf/tags/FFT/"},{"name":"扩域","slug":"扩域","permalink":"https://buzhibujue.cf/tags/扩域/"}]},{"title":"cf1214F","slug":"cf1214F","date":"2019-09-10T14:43:37.000Z","updated":"2020-05-03T15:35:00.000Z","comments":true,"path":"2019/09/10/cf1214F/","link":"","permalink":"https://buzhibujue.cf/2019/09/10/cf1214F/","excerpt":"","text":"cf1214F DescriptionTwo large companies “Cecsi” and “Poca Pola” are fighting against each other for a long time. In order to overcome their competitor, “Poca Pola” started a super secret project, for which it has total n vacancies in all of their offices. After many tests and interviews n candidates were selected and the only thing left was their employment. Because all candidates have the same skills, it doesn’t matter where each of them will work. That is why the company decided to distribute candidates between workplaces so that the total distance between home and workplace over all candidates is minimal. It is well known that Earth is round, so it can be described as a circle, and all m cities on Earth can be described as points on this circle. All cities are enumerated from 1 to m so that for each i (1≤i≤m−1) cities with indexes i and i+1 are neighbors and cities with indexes 1 and m are neighbors as well. People can move only along the circle. The distance between any two cities equals to minimal number of transitions between neighboring cities you have to perform to get from one city to another. In particular, the distance between the city and itself equals 0. The “Poca Pola” vacancies are located at offices in cities a1,a2,…,an. The candidates live in cities b1,b2,…,bn. It is possible that some vacancies are located in the same cities and some candidates live in the same cities. The “Poca Pola” managers are too busy with super secret project, so you were asked to help “Poca Pola” to distribute candidates between workplaces, so that the sum of the distance between home and workplace over all candidates is minimum possible. InputThe first line contains two integers m and n (1≤m≤109, 1≤n≤200000) — the number of cities on Earth and the number of vacancies. The second line contains n integers a1,a2,a3,…,an (1≤ai≤m) — the cities where vacancies are located. The third line contains n integers b1,b2,b3,…,bn (1≤bi≤m) — the cities where the candidates live. OutputThe first line should contain the minimum total distance between home and workplace over all candidates. The second line should contain n different integers from 1 to n. The i-th of them should be the index of candidate that should work at i-th workplace. Sample Input12310 31 5 510 4 6 Sample Output1231 2 3 Solution先给出不会证明正确性的 $O(n^2)$ 代码 123456for(int i=1;i&lt;=n;i++)&#123; int cur=0; for(int j=1;j&lt;=n;j++) cur+=dis(a[j],b[(i+j-2)%n+1]); ans=min(ans,cur);&#125; 然后考虑一个分段函数 dis(x,y)=\\min(|x-y|,m-|x-y|)= \\begin{cases} m-y+x, & x","categories":[{"name":"codeforces","slug":"codeforces","permalink":"https://buzhibujue.cf/categories/codeforces/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://buzhibujue.cf/tags/思维/"}]},{"title":"HDU4997","slug":"HDU4997","date":"2019-08-15T12:07:34.000Z","updated":"2020-05-03T15:34:06.000Z","comments":true,"path":"2019/08/15/HDU4997/","link":"","permalink":"https://buzhibujue.cf/2019/08/15/HDU4997/","excerpt":"","text":"HDU4997 DescriptionPeople are weak. Relationship between people like friendship or love is weak too. But a group of persons can have strong relationship, umm, 2-edge-connected relationship. Suppose there are n persons. If two persons, A and B, are in a relationship, then we add an un-directional edge between them. In this way we can have a relationship graph, which is an un-directional graph without self-loops or multiple edges. If this graph is 2-edge-connected, then we say these persons have a strong relationship. Now we have a group of persons without relationship between any two of them. And some pair of persons even hate each other. You will introduce some pairs of persons to know each other and set up a relationship between them to make the group of persons have a strong relationship. But notice that you can’t set up a relationship between a pair of persons who hate each other. How many ways you can do that? (Two ways are different if there exist a pair of persons which have relationship in one way but not in another way). output the answer modulo 1e9+7 InputThe first line contains an integer $T$ , denoting the number of the test cases. For each test case, the first line contains 2 integers n and m, denoting the number of persons in the group and the number of pairs of persons who hate each other. Then m lines follow, each line containing 2 integers $A$ and $B$, denoting that $A$ and B hate each other. $T\\leq5, 2\\leq n\\leq 10, 0\\leq m\\leq n*(n-1)/2.$ The persons are indexed from $1$ . OutputFor each test case, output the answer in a line. Sample Input12345635 010 05 21 22 3 Sample Output12325346699727618 HintA 2-edge-connected graph is a graph which is connected and if you remove an edge from it, it is still connected. Note that $n\\geq 2$, so we can ignore the issue that whether a single vertex is 2-edge-connected or not :). Solution1.计算集合 $S$ 形成的连通图的方案数 直接做是 $3^n$ 这里说一下 $n^22^n$ 做法：定义集合幂级数的乘法为子集卷积，$f$ 为形成连通图的方案的集合幂级数，$g$ 为形成任意子图的方案的集合幂级数( $\\varnothing$ 项的系数是 $0$ ) g+1=\\exp(f)\\\\ f=\\ln(g+1)\\\\ \\begin{align} f'&=\\frac{g'}{g+1}\\\\ f'+f'g&=g'\\\\ f'_n+\\sum_{i=0}^nf'_ig_{n-i}&=g'_n\\\\ (n+1)f_{n+1}+\\sum_{i=0}^n(i+1)f_{i+1}g_{n-i}&=(n+1)g_{n+1}\\\\ f_{n+1}&= g_{n+1}-\\frac{1}{n+1}\\sum_{i=0}^n(i+1)f_{i+1}g_{n-i} \\end{align}2. 计算集合 $S$ 形成的双连通图的方案数 为计算双连通子图的方案 $ans$，再记录一个h[S][T]表示将 $S$ 划分为若干不相互连通的连通子集 $S_0,S_1\\dots$ 使得所有子集 $S_0,S_1\\dots$ 都有且仅有一条连向 $T$ 的边 （两条就双连通了） ans[S]=f[S]-\\sum_{\\min S\\in S_0\\subseteq S}ans[S_0]\\times h[S\\backslash S_0][S_0]\\\\ h[S][T]= \\begin{cases} 1,&S=\\varnothing \\\\ \\sum_{\\min S\\in S_0\\subsetneq S}h[S_0][T]\\times f[S_0]\\times edge(S_0,T),&\\text{otherwise} \\end{cases}一开始特别菜的不知道怎么预处理这个 $edge(S,T)$ 以为只能 $4^n$ 一看其他人写的直接 $E(S\\oplus T)-E(S)-E(T)$即可，我容斥不过关 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"hdu4997\"using namespace std;const int N=10,SN=1&lt;&lt;N,MOD=1e9+7,N2=N*N;inline int add(int a,const int &amp;b)&#123;return (a+=b)&gt;=MOD?a-MOD:a;&#125;inline int sub(int a,const int &amp;b)&#123;return (a-=b)&lt; 0?a+MOD:a;&#125;inline int mul(const int &amp;a,const int &amp;b)&#123;return 1ll*a*b%MOD;&#125;inline int&amp; inc(int &amp;a,const int &amp;b)&#123;return a=add(a,b);&#125;inline int&amp; dec(int &amp;a,const int &amp;b)&#123;return a=sub(a,b);&#125;inline int&amp; pro(int &amp;a,const int &amp;b)&#123;return a=mul(a,b);&#125;inline int qpow(int a,int b)&#123;int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;&#125;inline int inv(const int &amp;a)&#123;return qpow(a,MOD-2);&#125;int n,T,m,d[N][N],E[SN],f[SN],g[SN][N+1],h[SN][SN],up,ans[SN],bin[N2];inline void clear()&#123; memset(d,0,sizeof d); memset(E,0,sizeof E); memset(f,0,sizeof f); memset(g,0,sizeof g); memset(h,0,sizeof h);&#125;inline void add(int *a,int *b)&#123;for(int i=0;i&lt;=n;i++)inc(a[i],b[i]);&#125;inline void sub(int *a,int *b)&#123;for(int i=0;i&lt;=n;i++)dec(a[i],b[i]);&#125;inline void getln(int *f)&#123; static int tmp[N+1]; for(int i=0;i&lt;=n;i++)tmp[i]=f[i]; for(int i=1;i&lt;n;i++)&#123; int cur=0; for(int j=0;j&lt;i;j++)inc(cur,mul(mul(j+1,f[j+1]),tmp[i-j])); dec(f[i+1],mul(inv(i+1),cur)); &#125;&#125;inline int edge(int S,int T)&#123;return sub(E[S^T],add(E[S],E[T]));&#125;inline void getf()&#123; for(int S=1;S&lt;up;S++)g[S][__builtin_popcount(S)]=bin[E[S]]; for(int S=1;S&lt;up;S&lt;&lt;=1)for(int i=0;i&lt;up;i++)if(i&amp;S)add(g[i],g[i^S]); for(int S=1;S&lt;up;S++)getln(g[S]); for(int S=1;S&lt;up;S&lt;&lt;=1)for(int i=0;i&lt;up;i++)if(i&amp;S)sub(g[i],g[i^S]); for(int S=1;S&lt;up;S++)f[S]=g[S][__builtin_popcount(S)];&#125;inline void getans()&#123; for(int S=0;S&lt;up;S++)h[0][S]=1; for(int S=1;S&lt;up;S++)&#123; int lst=S&amp;-S; for(int T=up-1^S;T;T=(T-1)&amp;(up-1^S)) for(int s=S^lst;~s;s=s?(s-1)&amp;(S^lst):-1) inc(h[S][T],mul(mul(h[S^s^lst][T],f[s^lst]),edge(s^lst,T))); &#125; for(int S=0;S&lt;up;S++)&#123; int lst=S&amp;-S; ans[S]=f[S]; if(S^lst) for(int s=(S^lst)&amp;((S^lst)-1);~s;s=s?(s-1)&amp;(S^lst):-1) dec(ans[S],mul(ans[s^lst],h[S^s^lst][s^lst])); &#125;&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); //freopen(FIO\".out\",\"w\",stdout); scanf(\"%d\",&amp;T); bin[0]=1;for(int i=1;i&lt;N2;i++)bin[i]=add(bin[i-1],bin[i-1]); while(T--)&#123; clear(); scanf(\"%d%d\",&amp;n,&amp;m); up=1&lt;&lt;n; while(m--)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); u--;v--; d[u][v]++; d[v][u]++; &#125; for(int S=0;S&lt;up;S++) for(int i=0;i&lt;n;i++)if(S&gt;&gt;i&amp;1) for(int j=i+1;j&lt;n;j++)if(S&gt;&gt;j&amp;1)E[S]+=!d[i][j]; getf();getans(); printf(\"%d\\n\",ans[up-1]); &#125; return 0;&#125;","categories":[{"name":"HDU","slug":"HDU","permalink":"https://buzhibujue.cf/categories/HDU/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://buzhibujue.cf/tags/计数/"},{"name":"容斥","slug":"容斥","permalink":"https://buzhibujue.cf/tags/容斥/"}]},{"title":"UOJ37","slug":"UOJ37","date":"2019-08-12T09:16:44.000Z","updated":"2020-05-03T15:34:46.000Z","comments":true,"path":"2019/08/12/UOJ37/","link":"","permalink":"https://buzhibujue.cf/2019/08/12/UOJ37/","excerpt":"","text":"UOJ37 Description响应主旋律的号召，大家决定让这个班级充满爱，现在班级里面有 $n$ 个男生。 如果 $a$ 爱着 $b$，那么就相当于 $a$ 和 $b$ 之间有一条 $a→b$ 的有向边。如果这 $n$ 个点的图是强联通的，那么就认为这个班级是充满爱的。 不幸的是，有一些不好的事情发生了，现在每一条边都可能被摧毁。我作为爱的使者，想知道有多少种摧毁的方式，使得这个班级任然充满爱呢？（说人话就是有多少边的子集删去之后整个图仍然强联通。） Input第一行两个数 $n$ 和 $m$ ，表示班级里的男生数和爱的关系数。 接下来 $m$ 行，每行两个数 $a$ 和 $b$，表示男生 $a$ 爱着男生 $b$。同时 $a$ 不等于 $b$。 所有男生从 $1$ 到 $n$ 标号。 同一条边不会出现两遍，但可能出现 $a$ 爱着 $b$，$b$ 也爱着 $a$ 的情况，这是两条不同的边。 Output输出一行一个整数，表示对 $10^9+7$ 取模后的答案。 Sample Input 123456789101112131415165 154 34 22 52 11 25 13 24 11 45 43 45 32 31 53 1 Sample Output19390 Constraints对于 $20\\%$ 的数据满足: $n≤5$; 对于 $50\\%$ 的数据满足: $n≤8$; 对于 $70\\%$ 的数据满足: $n≤10$; 对于 $100\\%$ 的数据满足: $n≤15,0≤m≤n(n−1)$。 时间限制：1s 空间限制：256MB Solution$f[S]$ 表示把集合 $S$ 分为非强连通分量的方案数 $h_k[S]$ 表示把集合 $S$ 分为 $k$ 个 $SCC$ 的方案数 $ans[S]$ 表示把集合 $S$ 分为 $1$ 个 $SCC$ 的方案数（也即是 $h_1[S]$ ） \\begin{align} f[S]&=\\sum_{\\varnothing\\neq T\\subseteq S}(-1)^{|T|-1}\\times f[T]\\times 2^{edge(T,S\\backslash T)}\\\\ &= \\sum_{\\varnothing\\neq T\\subseteq S}\\sum_{k=1}^{|T|}(-1)^{k-1}\\times h_k[T]\\times 2^{edge(T,S\\backslash T)}\\times 2^{E(S\\backslash T)} \\\\ &= \\sum_{\\varnothing\\neq T\\subseteq S}g[T]\\times 2^{edge(T,S\\backslash T)+E(S\\backslash T)}\\\\ 定义其中的 g[S]&= \\sum_{i=1}^{max}h_{2i-1}[S]-\\sum_{i=1}^{max}h_{2i}[S]\\\\ &= ans[S]-\\sum_{\\min S\\in T\\subsetneq S}ans[T]\\times g[S\\backslash T]\\\\ ans[S]&=2^{E(S)}-f[S] \\end{align}对于 $edge(T,S\\backslash T)$ , 令 $u=\\min S\\backslash T$ edge(T,S\\backslash T)=edge(T\\cup u,(S\\backslash T)\\backslash u)-edge(u,(S\\backslash T)\\backslash u)+edge(T,u)后两项可以通过预处理一个点的出度集合和入度集合来快速计算 Q： 算 $f[S]$ 时要用到 $g[S]$ 但算 $g[S] $ 时不是应该加上当前的 $ans[S]$ 吗，$ans[S]$ 又要通过 $f[S]$ 求？ A: 想一下我们现在求的是什么：当前情况的合法状态数 $ans[S]$ 。这个要通过 $2^{E[S]}-f[S]$ 实现，那么就要把之前算的答案导致的不合法情况容斥掉，而 $g$ 的意义只是为了我们后面再算的时候降低复杂度，是我们“定义”出来的一个值，没有什么实际含义，即我们只需要算之前的 $g[T]$ 导致的不合法情况并删除，剩下的就是现在合法的情况数，然后再用这个去更新现在的 $g[S]$ 以便以后用到的时候值正确 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"uoj37\"#define cnt(x) __builtin_popcount(x)using namespace std;const int N=15,N2=N*N,SN=1&lt;&lt;N,MOD=1e9+7;inline int add(int a,const int &amp;b)&#123;return (a+=b)&gt;=MOD?a-MOD:a;&#125;inline int sub(int a,const int &amp;b)&#123;return (a-=b)&lt; 0?a+MOD:a;&#125;inline int mul(const int &amp;a,const int &amp;b)&#123;return 1ll*a*b%MOD;&#125;inline int&amp; inc(int &amp;a,const int &amp;b)&#123;return a=add(a,b);&#125;inline int&amp; dec(int &amp;a,const int &amp;b)&#123;return a=sub(a,b);&#125;inline int&amp; pro(int &amp;a,const int &amp;b)&#123;return a=mul(a,b);&#125;inline int qpow(int a,int b)&#123;int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;&#125;int n,m,up;int E[SN],f[SN],g[SN],ans[SN],bin[N2],edge[SN],id[SN],d[N][N],in[N],out[N];int main()&#123; freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); up=1&lt;&lt;n; for(int i=0;i&lt;n;i++)id[1&lt;&lt;i]=i; bin[0]=1;for(int i=1;i&lt;N2;i++)bin[i]=add(bin[i-1],bin[i-1]); for(int i=1,u,v;i&lt;=m;i++)scanf(\"%d%d\",&amp;u,&amp;v),d[--u][--v]++,in[v]|=1&lt;&lt;u,out[u]|=1&lt;&lt;v; for(int S=1;S&lt;up;S++)&#123; int lst=S&amp;-S; E[S]=E[S^lst]+cnt(in[id[lst]]&amp;(S^lst))+cnt(out[id[lst]]&amp;(S^lst)); &#125; for(int S=1;S&lt;up;S++)&#123; int lst=S&amp;-S; if(S==lst)&#123; g[S]=ans[S]=1; continue; &#125; edge[S]=0; for(int T=(S-1)&amp;S;T;T=(T-1)&amp;S)&#123; int lst=(S^T)&amp;-(S^T); edge[T]=edge[T^lst]-cnt(out[id[lst]]&amp;(T^lst^S))+cnt(in[id[lst]]&amp;T); &#125; for(int T=(S^lst)&amp;((S^lst)-1);~T;T=T?(T-1)&amp;(S^lst):-1)&#123; dec(g[S],mul(ans[T^lst],g[T^lst^S])); &#125; for(int T=S;T;T=(T-1)&amp;S)&#123; inc(f[S],mul(g[T],bin[edge[T]+E[S^T]])); &#125; inc(g[S],ans[S]=sub(bin[E[S]],f[S])); &#125; printf(\"%d\\n\",ans[up-1]); return 0;&#125; ​","categories":[{"name":"UOJ","slug":"UOJ","permalink":"https://buzhibujue.cf/categories/UOJ/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://buzhibujue.cf/tags/计数/"},{"name":"容斥","slug":"容斥","permalink":"https://buzhibujue.cf/tags/容斥/"}]},{"title":"字符串选讲","slug":"字符串选讲","date":"2019-08-10T02:01:10.000Z","updated":"2020-05-03T15:35:46.000Z","comments":true,"path":"2019/08/10/字符串选讲/","link":"","permalink":"https://buzhibujue.cf/2019/08/10/字符串选讲/","excerpt":"","text":"字符串选讲只会讲几个简单模版，觉得简单的可以跑路了整理一下概念，难度随机排列 有几个概念一直绕来绕去的： 区间/全局+位置不同/本质不同+子/回文+序列/串 1. 全局+位置不同+子串不会的可以丢出去了… 2.全局+本质不同+子串同上 3. 全局+位置不同+子序列同上 4.全局+位置不同+回文串manacher 什么你不会manacher? 5.全局+本质不同+子序列序列自动机+记忆化搜索+高精度 什么你不会序列自动机？ 就是个二维数组好吧 该怎么构造怎么构造1 1234567int trans[N][26],nxt[26];for(int i=n;i;i--)&#123; memcpy(trans[i],nxt,sizeof nxt); nxt[s[i]-'a']=i;&#125;memcpy(trans[0],nxt,sizeof nxt); 6.全局+位置不同+回文序列表示我只会$O(n^2)$DP \\begin{align} dp[i][j]= \\left\\{\\begin{array}{ll} {dp[i+1][j] +dp[i][j-1]-dp[i+1][j-1],} & {s[i]=s[j]} \\\\ { \\\\ dp[i+1][j] + dp[i][j-1] -dp[i+1][j-1]+dp[i+1][j-1]+1\\\\=dp[i+1][j]+dp[i][j-1]+1 ,} & {\\\\\\\\s[i] \\neq s[j]} \\end{array}\\right. \\end{align}欢迎暴打讲课人 7. 全局+本质不同+回文串听说有manacher+后缀数组做法，然而不是很懂那些人在写什么会的人可以上来讲 我今天只是来讲板子的，于是： 回文自动机即可。2 回文自动机上一个节点代表一个本质不同的回文串，总节点个数 $-2$ 个根节点就是本质不同的回文串个数，这样讲能听懂了吧=.= 什么你不会回文自动机？ 8. 全局+本质不同+回文序列完全不会搞=.=, dfs吗？只是凑数的欢迎暴打讲课人X2 9. 区间+位置不同+子串 ：妹神，这题咋做啊。 ：我不会 ：你题都没看你就说不会，你咋这么假 ：不是，我是真不会 ：哦，那好嘛，让你看几秒，现在会了吗 ：还是不会 ：？？？这妹神怎么走水，丢出去丢出去3 10.区间+位置不同+子序列 ：该怎么$DP$怎么$DP$ ：不是$(Ber)$，这题你还要$DP$？ ：哦，我傻了 ：哎哟~~~假死了4 11. 区间+位置不同+回文串这好像是道原题但不是所有人都改了（记不到题号了，欢迎某神妹说一下） 蜜汁画外音：预处理出串的manacher数组，然后你瞎搞一下就完了。5 ？？？ =.= 设manacher预处理出来的每个位置最多往左右延伸的距离数组为f 相当于求$ \\sum_{i=l}^{r}\\min{(f[i],i-l+1,r-i+1)}$ 解不等式 \\begin{align} i-l+1&\\leq r-i+1\\\\ i&\\leq\\frac{r+l}{2}\\\\ \\end{align}所以取$mid=\\frac{l+r}{2}$可得对于$i\\in [l,mid]\\quad i-l+1\\leq r-i+1$ 左边限制更强然后继续解 \\begin{align} f[i]&\\geq i-l+1\\\\ f[i]+i&\\geq l+1 \\end{align}然后就是查满足 $l\\leq i\\leq mid$ 且 $f[i]+i\\geq l+1$ 的 $i$ 的 $f[i]$之和以及 $i$ 之和以及个数，没被“挡住”的 $i$ 的个数直接用 $mid-l+1$ 去减，右边是相似的，然后就随便写完了 可以用树状数组优化常数，也可以用主席树在线 12. 区间+本质不同+子串$WC2019$课件里提到过（当时在冬眠？完全没印象了） 先离线询问，然后变成右端点r每次往右拓展。怎么算答案？使用线段树记录对于每个左端点l有多少个子串最后一次出现是从l开始的，答案即l-r的区间和。 怎么维护？考虑拓展之后以当前r结尾的串一定在后缀树上是一条到根的链。之前这条链上有一些点，这些点的最后一次出现位置（的右端点）将要变为r， 即用LCT维护，每个节点记一下所属的right集合最大值，然后新加一个点就是对于一条链的right集合最大值全部赋值为r，即access操作。 (例如从右往左加入到 $i=1$ 时) (图来自冬令营课件，因为懒得画了) 加入前： 加入后： 然后可以知道在这棵LCT中所有在同一棵splay上的节点的right集合最大值都是相等的（归纳法） 每次右端点右移时直接区间 $[1,r]$ 都加上 $1$ ，表示左端点在 $[1,r]$ 右端点在 $r$ 的子串出现次数都加上 $1$ ，但是有可能以 $r$ 结尾的某些子串在之前出现过，那么它们在右端点移到 $r$ 之前的最后一次出现的左端点的值则要减去 $1$ ，（这些子串最后一次出现位置改变了）这可以在access途中维护。 即把一些左端点在 $[r-mxlen[x]+1,r-mnlen[x]+1]$ 右端点在 $r`$ 的点的贡献删掉，再把其右端点改为当前的$r$ 代码应该好懂 （注意mnlen的含义） 1234567891011121314151617181920//hackerrank how many substrings//or hdu4622(Weakened version)inline void pushup(int x)&#123;mnlen[x]=min(mnlen[lx],min(len[sam::fa[x]]+1,mnlen[rx]));&#125;inline void pushdown(int x)&#123; rig[lx]=max(rig[lx],rig[x]); rig[rx]=max(rig[rx],rig[x]);&#125;inline void access(int x,int n)&#123; for(int y=0;x;x=fa[y=x])&#123; splay(x); pushdown(x); if(len[x]&amp;&amp;rig[x]) mdy(rig[x]-len[x]+1,rig[x]-mnlen[x]+1,-1); rx=y; pushup(x); if(!fa[x])rig[x]=n; &#125;&#125; 13.区间+本质不同+子序列好像又是原题，不过原题字符集大小只有 $10$ ，改成 $26$ 也差不多吧 好像$O$讲过了，那我就不讲了再讲一遍 设dp[i][j]表示从左到右到第i位，以字符j结尾的子序列个数 于是 \\begin{align} dp[i][j]= \\left\\{\\begin{array}{ll} {dp[i-1][j],} & {s[i]\\neq j} \\\\ {\\sum_{k=0}^{|\\Sigma|}dp[i-1][k]+1,} & {\\\\\\\\s[i] = j} \\end{array}\\right. \\end{align}转移看成矩阵可得：(假设字符集大小为3) (矩阵公式太难打以下矩阵全部识别自原题解) A_{0}=\\left(\\begin{array}{cccc}{1} & {1} & {1} & {1} \\\\ {0} & {1} & {0} & {0} \\\\ {0} & {0} & {1} & {0} \\\\ {0} & {0} & {0} & {1}\\end{array}\\right) \\quad A_{1}=\\left(\\begin{array}{cccc}{1} & {0} & {0} & {0} \\\\ {1} & {1} & {1} & {1} \\\\ {0} & {0} & {1} & {0} \\\\ {0} & {0} & {0} & {1}\\end{array}\\right) \\quad A_{2}=\\left(\\begin{array}{cccc}{1} & {0} & {0} & {0} \\\\ {0} & {1} & {0} & {0} \\\\ {1} & {1} & {1} & {1} \\\\ {0} & {0} & {0} & {1}\\end{array}\\right)然后肉眼观察手推6可得出转移矩阵的逆矩阵 A_{0}^{-1}=\\left(\\begin{array}{cccc}{1} & {-1} & {-1} & {-1} \\\\ {0} & {1} & {0} & {0} \\\\ {0} & {0} & {1} & {0} \\\\ {0} & {0} & {0} & {1}\\end{array}\\right) \\quad A_{1}^{-1}=\\left(\\begin{array}{cccc}{1} & {0} & {0} & {0} \\\\ {-1} & {1} & {-1} & {-1} \\\\ {0} & {0} & {1} & {0} \\\\ {0} & {0} & {0} & {1}\\end{array}\\right) \\quad A_{2}^{-1}=\\left(\\begin{array}{cccc}{1} & {0} & {0} & {0} \\\\ {0} & {1} & {0} & {0} \\\\ {-1} & {-1} & {1} & {-1} \\\\ {0} & {0} & {0} & {1}\\end{array}\\right)然后答案即为 \\left(\\begin{array}{c}{1} \\\\ {1} \\\\ {1} \\\\ {1}\\end{array}\\right)^{T} A_{c_{j}} \\cdots A_{c_{i}}\\left(\\begin{array}{l}{0} \\\\ {0} \\\\ {0} \\\\ {1}\\end{array}\\right)=\\left(\\begin{array}{l}{1} \\\\ {1} \\\\ {1} \\\\ {1}\\end{array}\\right)^{T}( A_{c_{j}} \\cdots A_{c_{i}} A_{c_{i-1}} \\cdots A_{c_{1}}) (A_{c_{1}}^{-1} \\cdots A_{c_{i-1}}^{-1})\\left(\\begin{array}{l}{0} \\\\ {0} \\\\ {0} \\\\ {1}\\end{array}\\right)然后预处理前缀积可做到$O\\left(n|\\Sigma|^{3}+q|\\Sigma|^{3}\\right)$ 然后可以通过非零项只有$2|\\Sigma |+1$项来做到$O(n|\\Sigma| ^2)$我不会 讲下最优解 考虑 $A$ 矩阵左乘另一个矩阵的含义 即$C=B\\times A$ C[i][j]=\\sum_{k=0}^{|\\Sigma|}B[i][k]*A[k][j]对于$j= s[这一项]$ C[i][j]=\\sum_{k=0}^{|\\Sigma|}B[i][k]*A[k][j]=\\sum_{k=0}^{|\\Sigma|}B[i][k]否则 C[i][j]=0+B[i][j]*A[j][j]=B[i][j]这是什么意思？相当于$C$ 矩阵的第s[这一项]列的每一个数都变成所在行的行和了，其余不变 这个是可以通过维护每一行行和维护的 对于$A^{-1}$右乘一个矩阵是相当于每行的除了第s[这一项]列的这个数都减等于这个数（这真可以手推），维护一下每一行所有数一共减了多少即可 再来看我们求什么，一个全是 $1$ 的行向量右乘 $A$ 相当于只有 $1$ 行，预处理出来列和，然后一个只有最后一项的列向量左乘 $A^{-1}$ 只有 $1$ 列，预处理出行和，然后$ans=\\sum_{i=0}^{|\\Sigma|}preA[r][i]\\times preB[l-1]][i]$即可（ $B$ 即 $A^{-1}$ )复杂度是 $O(n|\\Sigma|)$ 的 1234567891011121314151617181920212223242526272829//可能预处理的是A^-1左乘，A右乘，不过等价的//B即是A^-1for(int i=0;i&lt;M;i++)A[i][i]=B[i][i]=sum_A[i]=1;preB[0][M-1]=1;for(int i=1;i&lt;=n;i++)&#123; int v=s[i]-'a'; for(int j=0;j&lt;M;j++)&#123; dec(sum_A[j],A[v][j]); inc(A[v][j],sum_A[j]); inc(sum_A[j],A[v][j]); inc(B[j][v],sum_B[j]); dec(sum_B[j],B[j][v]); dec(B[j][v],sum_B[j]); /* 上面三行等价于 int tmp=sum_B[j]; sum_B[j]=sub(0,B[j][v]); B[j][v]=add(mul(2,B[j][v]),tmp); */ &#125; for(int j=0;j&lt;M;j++)&#123; preA[i][j]=sum_A[j]; preB[i][j]=add(B[j][M-1],sum_B[j]); &#125;&#125;//算答案for(int i=0;i&lt;M;i++)inc(ans,mul(preB[l-1][i],preA[r][i])); 14.区间+本质不同+回文串有一个性质就是一个回文串的所有回文后缀可以分为不超过 $\\log$个等差数列（证明可以翻鏼课件） 还是和求区间本质不同子串相似的做法，先离线，考虑右端点每次右移，不同的是直接维护左端点在每个位置时的答案。 考虑怎么求以新增的r结尾的串的贡献 大概这个样子，会造成若干个回文串最后一次出现位置被更新，例如红色回文串就会以红色串上次出现左端点 $+1$ 到这次红色串出现的左端点为左端点的区间内的本质不同回文串个数加一，绿色的同理，但可以注意到它们可以恰好拼成一个区间，那么就可以一起修改了。 =.=不对吧，如果绿色除了r结尾最后一次出现不以红色开头呢？不会算成（如下绿色框）吗？ 比如这样 =v=你冷静观察下就会发现红色串在回文树上的父亲不是绿色串而是蓝色串，根据回文树的定义蓝色串一定是最长的，绿色的出现位置会形成一个等差数列，（意会一下可以知道）形成的回文串出现位置一定是连着的，所以还是没有问题的 12345678910111213141516171819202122232425262728//bzoj5384inline void append(int n)&#123; int p=lst,c=s[n]-'a'; while(s[n-len[p]-1]^s[n])p=fa[p]; if(!ch[p][c])&#123; int q=fa[p]; while(s[n-len[q]-1]^s[n])q=fa[q]; len[++ptr]=len[p]+2; fa[ptr]=ch[q][c]; ch[p][c]=ptr; dif[ptr]=len[ptr]-len[fa[ptr]]; anc[ptr]=dif[ptr]^dif[fa[ptr]]?fa[ptr]:anc[fa[ptr]]; &#125; lst=ch[p][c];&#125;for(int i=1;i&lt;=n;i++)&#123; for(int u=pos[i];u;u=anc[u])&#123; int l=max(1,qry(id[u],id[u]+sz[u]-1)-len[u]+2); int r=i-(len[anc[u]]+len[u]-len[fa[u]])+1; bit.add(l,r); &#125; mdy(id[pos[i]],i); while(!q[i].empty())&#123; pii x=q[i].back();q[i].pop_back(); ans[x.first]=bit.qry(x.second); &#125; &#125; 15 区间+位置不同+回文序列同$6$，只会 $O(n^2)$ &gt;_&lt; 16.区间+本质不同+回文序列完全不会=.= ：Ber！这不XX题吗，就XXOJXXXX和XXOIXXXX的那道一样的 （其他做过该题的与没做过该题的）：？？？ ：哦，那还是差不多嘛，你看都是XX再套个XX就完了 ：？？？所以就一样？？？7 再讲几个板子来拖时间吧 （毕竟除了板子就啥都不会了） 真一点的广义后缀自动机可能插入一个新节点时已经有从之前到现在的转移边了，判断一下len，可能需要拆之前的点（其实和之前拆点的写法几乎一样） 1234567891011121314151617181920212223242526272829303132inline void append(int c)&#123; int p=lst; if(ch[p][c])&#123; if(len[ch[p][c]]==len[p]+1)lst=ch[p][c]; else&#123; int q=ch[p][c],nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; lst=nq; &#125; &#125;else&#123; //printf(\"p=%d c=%d\\n\",p,c); int x=++ptr;len[x]=len[p]+1;lst=x; while(p&amp;&amp;!ch[p][c])ch[p][c]=x,p=fa[p]; if(!p)fa[x]=1; else&#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[x]=q; else&#123; int nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[x]=fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; &#125; &#125; &#125;&#125; 双端插入的回文自动机记一下两端加入的回文串的最后插入位置（及总串的最长回文前缀和最长回文后缀），然后和普通回文自动机一样的写就行了，注意一点就是根据定义当插入后当前节点长度变为总长的时候要把另一端的最后插入位置也变成当前节点。=.=看代码吧 1234567891011121314151617//hdu5421//f=1 left //f=2 rightinline void append(int n,int f)&#123; int p=lst[f-1],c=s[n]-'a',ff=f*2-3;//f=1 -&gt; ff=-1 | f=2 -&gt; ff=1 while(s[n-len[p]*ff-ff]^s[n]) p=fa[p]; if(!ch[p][c])&#123; int q=fa[p]; while(s[n-len[q]*ff-ff]^s[n])q=fa[q]; len[++ptr]=len[p]+2; fa[ptr]=ch[q][c]; lst[f-1]=ch[p][c]=ptr; if(r-l+1==len[ptr])lst[!(f-1)]=ptr;//! dep[ptr]=dep[fa[ptr]]+1; &#125;else lst[f-1]=ch[p][c]; sum+=dep[ch[p][c]];&#125; 后缀平衡树维护一个母串，支持加后缀、删后缀、询问一个模版串出现次数。 母串模版串都反过来，变为每次在左边加减字符就可以动态的维护后缀数组。 新加入节点时最好能 $O(1)$ 比较rk ，于是使用平衡树维护一个long long数组val 类似于 $val[mid]=\\cfrac{val[l]+val[r]}{2}$最好使用重量平衡树 $Treap$ 或替罪羊 查串 $T$ 出现次数即查 $rk[T+char(‘z’+1)]-rk[T]$，可在平衡树上查找（这里判断字符串大小听说不知道为什么二分没有暴力for快 我不知道我瞎说的我自己这题也没过被卡常了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//bzoj4768inline void relabel(int x=X,ll l=L,ll r=R)&#123; if(!x)return; val[x]=mid; relabel(ch[x][0],l,mid); relabel(ch[x][1],mid,r); if(x==X)X=0;&#125;inline void ins(int pos,int &amp;x=rt,ll l=0,ll r=1e18)&#123; if(!x)&#123; x=newnode(pos,mid); return; &#125; int t=s[x]&lt;s[pos]||(s[x]==s[pos]&amp;&amp;val[x-1]&lt;val[pos-1]); ins(pos,ch[x][t],t?mid:l,t?r:mid); if(rnd[ch[x][t]]&lt;rnd[x])&#123; rot(x,t); X=x;L=l;R=r; &#125; pushup(x);&#125;inline bool les(int x)&#123; for(int i=0;i&lt;min(len,x);i++)if(s[x-i]^str[i]) return s[x-i]&lt;str[i]; return x&lt;len;&#125;inline void qry(int x=rt)&#123; while(x)&#123; if(les(x))ans+=sz[ch[x][0]]+1,x=ch[x][1]; else x=ch[x][0]; &#125;&#125;switch(type[0])&#123; case 'Q':&#123; scanf(\"%s\",str); len=strlen(str); decode(mask); reverse(str,str+len); ans=0; qry(); ans=-ans; str[len++]='Z'+1; qry(); printf(\"%d\\n\",ans); mask^=ans; break; &#125; case 'A':&#123; scanf(\"%s\",str); len=strlen(str); decode(mask); for(int i=0;i&lt;len;i++)s[++n]=str[i],ins(n),relabel(); break; &#125; case 'D':&#123; int x; scanf(\"%d\",&amp;x); while(x--)&#123; del(n); s[n--]=0; &#125; break; &#125;&#125; 拓展KMP国外好像叫Z-algorithm，用来 $O(n+m)$ 计算串 $S$ 每一个后缀和串 $T$ 的 $LCP$ 设答案数组为ext[i]即S[i]与T的 $LCP$ 再预处理出一个nxt[i]表示S[i]与S[0]的 $LCP$ 长度 ：就，你记录一个最长延伸到的点，再用类似manacher的方法算就完了。8 ？？？ 就分三种情况讨论$Case 1$ 这种情况我们什么也不知道，只能令 $nxt[i]=0$ $Case 2$ 这表示 $i+nxt[i-mid]\\leq mid+nxt[mid]$ 什么意思呢？即 $s[i:mid+nxt[mid]]=s[i-mid:nxt[mid]]$ 第 $i$位与 $S$ 的 $LCP$ 已经在第 $i-mid$ 项算过了，且肯定不会变多，可以直接赋值为 $nxt[i-mid]$ $Case3$ 这时最上方两个蓝色的串处于红色串没包含的部分一定不相等（否则红色串将更长），只能赋值为已知的长度即 $nxt[i]=mid+nxt[mid]-i$ 可以把 $Case 1,3$ 并为一种 （代码巨短无比） （这是预处理 $nxt$ 至于计算 $ext$ 就基本完全一样了） 1234567891011121314151617//luogu P5410 int mid=0;for(int i=1;i&lt;n;i++)&#123; if(nxt[mid]+mid&gt;=i+nxt[i-mid])nxt[i]=nxt[i-mid]; else nxt[i]=max(0,mid+nxt[mid]-i); while(i+nxt[i]&lt;=n&amp;&amp;s[nxt[i]]==s[i+nxt[i]])nxt[i]++; if(i+nxt[i]&gt;mid+nxt[mid])mid=i;&#125;mid=0;while(t[ext[0]]==s[ext[0]])ext[0]++;for(int i=1;i&lt;m;i++)&#123; if(ext[mid]+mid&gt;=i+nxt[i-mid])ext[i]=nxt[i-mid]; else ext[i]=max(0,mid+ext[mid]-i); while(i+ext[i]&lt;=m&amp;&amp;s[ext[i]]==t[i+ext[i]])ext[i]++; if(i+ext[i]&gt;mid+ext[mid])mid=i;&#125; Lyndon分解定义：对于字符串 $s$ ，若 $s$ 的最小后缀为其本身，那么称 $s$ 为 $Lyndon$ 串 性质：任意字符串 $s$ 都可以分解为 $s=s1s2\\cdots sk$ ，其中 $∀si$ 为 $Lyndon$ 串且 $si⩾si+1$ 。且这种分解方法是唯一的 证明：到处都有就不搬了。。。我证明不过关9 如何构造：考虑维护当前结尾的若干个相等的 $Lyndon$ 串，每次往右移，令未确定分解的开始位置为 $i$ ，当前新增位置为 $k$ , $j$ 是 $k$ 这一位在之前循环的对应位置，分情况讨论 \\begin{align} s[j]&=s[k]\\to 周期不变\\\\ s[j]&s[k]\\to s[k]一定不能与左边的合并了，所以记录答案再从 k 所在的循环头部开始\\\\ \\end{align}大概是这样 123456789101112//loj129for(int i=1;i&lt;=n;)&#123; int j=i,k=i+1; for(;k&lt;=n&amp;&amp;s[j]&lt;=s[k];k++)&#123; if(s[k]==s[j])j++; else j=i; &#125; while(i&lt;=j)&#123; i+=k-j; printf(\"%d \",i-1); &#125;&#125; 如果有时间，再讲点奇$(quan)$奇$(shi)$怪$(tao)$怪$(lu)$的题$(ban)$ 真 · 只讲板子.jpg CF666E Description给你一个串 $S$ 以及一个字符串数组 $T[1..m]$ ，$q$ 次询问，每次问 $S$ 的子串 $S[p_l..p_r]$ 在 $T[l..r]$ 中的哪个串里的出现次数最多，并输出出现次数。如有多解输出最靠前的那一个。 Sample Input12345678suffixtree3suffixtreesareawesomecartesiantreeisworsethansegmenttreenyeeheeheee21 2 1 101 3 9 10 Sample Output121 13 4 Constraint$1&lt;=|s|&lt;=5·10^{5}, 1&lt;=m&lt;=5·10^{4}, 1&lt;=q&lt;=5·10^{5}, 1&lt;=l&lt;=r&lt;=m, 1&lt;=pl&lt;=pr&lt;=∣s∣$ Solution建出广义 $SAM$ 每个节点使用线段树合并维护每个节点在每个 $T$ 中出现次数 对 $S$ 每个前缀记录匹配到广义 $SAM$ 的哪个节点 $pos$ 以及匹配长度 $L$ ，查询时如果 $L[p_r]$ 不足 $p_r-p_l+1$ 直接返回 $(l, 0)$ ，否则倍增到找到最长的长度大于等于 $p_r-p_l+1$ 的 $pos$ 的后缀树上的祖先，在该祖先的线段树里随便查询一下就行了 （注意线段树合并的时候要新建节点，不然信息（很有可能）被破坏，小样例还测不出来） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ll long long#define pii pair&lt;int,int&gt;#define FIO \"cf666e\"using namespace std; const int N=5e5+5,M=5e4+5,C=26,lgM=18; int n,ptr=1,m;char s[N],t[M]; int rt[M&lt;&lt;1];namespace seg&#123; int ptr; int ch[M*80][2]; pii tr[M*80];#define lk ch[k][0]#define rk ch[k][1]#define mid (l+r&gt;&gt;1) inline void mdy(int &amp;k,int pos,int l=1,int r=m)&#123; if(!k)k=++ptr; if(l==r)&#123; tr[k]=pii(tr[k].second+1,-l); return; &#125; if(pos&lt;=mid)mdy(lk,pos,l,mid); else mdy(rk,pos,mid+1,r); tr[k]=max(tr[lk],tr[rk]); &#125; inline pii qry(int k,int ql,int qr,int l=1,int r=m)&#123; if(!k)return pii(0,-ql); if(ql&lt;=l&amp;&amp;r&lt;=qr)return tr[k]; if(qr&lt;=mid)return qry(lk,ql,qr,l,mid); if(mid&lt;ql)return qry(rk,ql,qr,mid+1,r); return max(qry(lk,ql,mid,l,mid),qry(rk,mid+1,qr,mid+1,r)); &#125; inline int merge(int x,int y,int l=1,int r=m)&#123; if(!x||!y)return x|y; int z=++ptr; if(l==r)&#123; tr[z]=pii(tr[x].first+tr[y].first,-l); return z; &#125; ch[z][0]=merge(ch[x][0],ch[y][0],l,mid); ch[z][1]=merge(ch[x][1],ch[y][1],mid+1,r); tr[z]=max(tr[ch[z][0]],tr[ch[z][1]]); return z;&#125; #undef lk#undef rk#undef mid&#125; int fa[M&lt;&lt;1],ch[M&lt;&lt;1][C],len[M&lt;&lt;1],lst;inline void append(int c,int id)&#123; int p=lst; if(ch[p][c])&#123; if(len[ch[p][c]]==len[p]+1)lst=ch[p][c]; else&#123; int q=ch[p][c],nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; lst=nq; &#125; &#125;else&#123; //printf(\"p=%d c=%d\\n\",p,c); int x=++ptr;len[x]=len[p]+1;lst=x; while(p&amp;&amp;!ch[p][c])ch[p][c]=x,p=fa[p]; if(!p)fa[x]=1; else&#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[x]=q; else&#123; int nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[x]=fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; &#125; &#125; &#125; seg::mdy(rt[lst],id);&#125; int h[M&lt;&lt;1],nxt[M&lt;&lt;1],to[M&lt;&lt;1],ecnt;inline void add(int u,int v)&#123;nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;&#125; int anc[M&lt;&lt;1][lgM];inline void dfs(int u=1)&#123; for(int i=1;anc[u][i-1];i++)anc[u][i]=anc[anc[u][i-1]][i-1]; for(int i=h[u],v;i;i=nxt[i])anc[v=to[i]][0]=u,dfs(v),rt[u]=seg::merge(rt[u],rt[v]);&#125; int q,pos[N],L[N];int main()&#123; scanf(\"%s\",s+1); n=strlen(s+1); scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%s\",t+1); int len=strlen(t+1); lst=1; for(int j=1;j&lt;=len;j++)append(t[j]-'a',i); &#125; for(int i=2;i&lt;=ptr;i++)add(fa[i],i); dfs(); for(int i=1,p=1,l=0;i&lt;=n;i++)&#123; int c=s[i]-'a'; while(p&amp;&amp;!ch[p][c])p=fa[p],l=len[p]; if(!p)&#123; p=1;l=0; &#125;else&#123; p=ch[p][c]; l++; &#125; pos[i]=p;L[i]=l; &#125; scanf(\"%d\",&amp;q); while(q--)&#123; int l,r,ql,qr; scanf(\"%d%d%d%d\",&amp;ql,&amp;qr,&amp;l,&amp;r); l=r-l+1; if(L[r]&lt;l)&#123;printf(\"%d %d\\n\",ql,0);continue;&#125; int u=pos[r]; for(int i=lgM-1;~i;i--)if(len[anc[u][i]]&gt;=l)u=anc[u][i]; pii ans=seg::qry(rt[u],ql,qr); printf(\"%d %d\\n\",-ans.second,ans.first); &#125; return 0;&#125; LuoguP4482 Description求区间最长 $Border$ 长度 $Border$: 对于给定的串 $s$ ，最大的 $i$ 使得 $s[1..i] = s[|s|-i+1..|s|]$ , $|s|$ 为 $s$ 的长度。 Sample Input12345abbabbaa31 81 72 7 Sample Output123143 Constraint$ n,q≤2⋅10^5$ Solution题意可以转化为对于一个 $r$ 找到一个最大的 $i$ 满足 $l\\leq i &lt;r$ 使得 $lcs[i,r]\\geq i-l+1$ ，在后缀树上即是r所代表的节点的某个祖先x的right集合内大于等于l且满足 $len[x]\\geq i-l+1$ 的最大的 $i$ 一个在串随机的情况下的可能的算法就是每次从 r 的节点暴力往上跳使用线段树合并/Set启发式合并找到符合要求的right集合内的值，期望情况下SAM大概树高是log的，大概可以过这部分分 考虑正解链分治，之前的做法复杂度不对的原因是每个询问可能被处理树高次，在树高特别高（如全是一个字符）时会挂掉。 那么能否离线下来呢？如果只是保留下来对每个点的询问还是会查若干遍，因为要查的和len[x]和l都有关，转化式子 $len[x]\\geq i-l+1 \\Leftrightarrow l+len[x]\\geq i+1 \\Leftrightarrow l+len[x]&gt;i\\Leftrightarrow l&gt;i-len[x] $ 可以对每个节点以i为下标维护i-len[x]的最小值即求一段区间最靠右的满足 $val[i]&lt;i$ 的位置 $i$ ，然后链剖，发现我们每次询问的是若干重链的前缀的信息，把询问到根的路径拆成若干条重链前缀的询问，对每个点先继承重链父亲（如果有）的状态，再加入自己的虚子树（直接暴力DFS，因为一个点最多往上走log跳虚边即最多在log个点的虚子树内），计算在这个节点的询问，再递归处理子树，然后计算答案在自己子树内时的影响（即和之前一样维护right集合，用个rig[u].lower_bound(min(ql[cur]+len[u],qr[cur]))） 如这样，从询问点到根的路径被分为 $3$ 条重链的前缀。 以 $qry$ 的点和所求 $LCA$ 在最上面红点到根的前缀时对答案的影响： 首先会继承继承到根的重链的虚子树部分（蓝色三角）的信息if(u^top[u])rt[u]=rt[fa[u]]; 然后对于每一个询问直接seg::qry(rt[u],qr[cur]-1,ql[cur]-1)即可 然后是 $LCA$ 恰为当前点的答案，加入所有虚子树（绿色三角）内right-len[x] （这时right集合还没有合并，最多有一个值） 123456inline void dfs4(int u,int x)&#123; if(rig[u].size())seg::mdy(rt[x],*rig[u].begin(),*rig[u].begin()-len[x]); for(int i=h[u],v;i;i=nxt[i])dfs4(v=to[i],x);&#125; for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^son[u])dfs4(v,u); 递归计算所有儿子的信息，然后合并这个点的right集合，更新答案在这个子树内的影响 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"P4482\"using namespace std;const int N=2e5+5,C=26,INF=1e9;inline void chkmax(int &amp;a,const int &amp;b)&#123;if(a&lt;b)a=b;&#125;inline void chkmin(int &amp;a,const int &amp;b)&#123;if(a&gt;b)a=b;&#125;int n,m,fa[N&lt;&lt;1],len[N&lt;&lt;1];char s[N];set&lt;int&gt;rig[N&lt;&lt;1];int R[N&lt;&lt;1];namespace sam&#123; int lst=1,ptr=1,ch[N&lt;&lt;1][C]; inline void append(int n)&#123; int c=s[n]-'a',p=lst,x=++ptr;len[x]=len[p]+1;lst=x;rig[x].insert(n);R[x]=n; for(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=x; if(!p)fa[x]=1; else&#123; int q=ch[p][c]; if(len[q]==len[p]+1)fa[x]=q;else&#123; int nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[x]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; &#125; &#125; &#125;&#125;int h[N&lt;&lt;1],nxt[N&lt;&lt;1],to[N&lt;&lt;1],ecnt;inline void add(int u,int v)&#123;nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;&#125;int sz[N&lt;&lt;1],top[N&lt;&lt;1],son[N&lt;&lt;1];inline void dfs1(int u=1)&#123; sz[u]=1; for(int i=h[u],v;i;i=nxt[i])&#123; dfs1(v=to[i]),sz[u]+=sz[v]; if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; &#125;&#125;inline void dfs2(int u=1,int tp=1)&#123; top[u]=tp; if(son[u])dfs2(son[u],tp); for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^son[u])dfs2(v,v);&#125;int pos[N],rt[N&lt;&lt;1];int ql[N],qr[N],ans[N];namespace seg&#123; int mn[N*50],ptr,ch[N*50][2];#define lk ch[k][0]#define rk ch[k][1]#define mid (l+r&gt;&gt;1) inline int qry(int k,int qr,int val,int l=1,int r=n)&#123; if(mn[k]&gt;val)return -INF; if(l==r)return l; if(r&lt;=qr)&#123; if(mn[rk]&lt;=val)return qry(rk,qr,val,mid+1,r); return qry(lk,qr,val,l,mid); &#125;else&#123; if(qr&lt;=mid)return qry(lk,qr,val,l,mid); else return max(qry(lk,mid,val,l,mid),qry(rk,qr,val,mid+1,r)); &#125; &#125; inline void mdy(int &amp;k,int pos,int val,int l=1,int r=n)&#123; if(!k)k=++ptr; chkmin(mn[k],val); if(l==r)return; if(pos&lt;=mid)mdy(lk,pos,val,l,mid); else mdy(rk,pos,val,mid+1,r); &#125;&#125;inline void dfs4(int u,int x)&#123; if(rig[u].size())seg::mdy(rt[x],*rig[u].begin(),*rig[u].begin()-len[x]); for(int i=h[u],v;i;i=nxt[i])dfs4(v=to[i],x);&#125;vector&lt;int&gt;q[N&lt;&lt;1];inline void merge(int u,int v)&#123; if(rig[u].size()&lt;rig[v].size())swap(rig[u],rig[v]); for(set&lt;int&gt;::iterator it=rig[v].begin();it!=rig[v].end();it++)rig[u].insert(*it);&#125;inline void dfs3(int u=1)&#123; if(u^top[u])rt[u]=rt[fa[u]]; for(int i=0,sz=q[u].size();i&lt;sz;i++) chkmax(ans[q[u][i]],seg::qry(rt[u],qr[q[u][i]]-1,ql[q[u][i]]-1)); for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^son[u])dfs4(v,u); assert(rig[u].empty()||*rig[u].begin()==R[u]); if(rig[u].size())seg::mdy(rt[u],*rig[u].begin(),*rig[u].begin()-len[u]); for(int i=h[u],v;i;i=nxt[i])&#123; dfs3(v=to[i]); merge(u,v); &#125; for(int i=0,sz=q[u].size();i&lt;sz;i++)&#123; set&lt;int&gt;::iterator it=rig[u].lower_bound(min(ql[q[u][i]]+len[u],qr[q[u][i]])); if(it!=rig[u].begin()) chkmax(ans[q[u][i]],*--it); &#125;&#125;int main()&#123; memset(seg::mn,0x3f,sizeof seg::mn); scanf(\"%s%d\",s+1,&amp;m); n=strlen(s+1); for(int i=1;i&lt;=n;i++)sam::append(i),pos[i]=sam::lst; for(int i=2;i&lt;=sam::ptr;i++)add(fa[i],i); dfs1();dfs2(); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;ql[i],&amp;qr[i]); ans[i]=ql[i]-1; for(int u=pos[qr[i]];u;u=fa[top[u]]) q[u].push_back(i); &#125; dfs3(); for(int i=1;i&lt;=m;i++)printf(\"%d\\n\",ans[i]-ql[i]+1); return 0;&#125; JSOI2019节日庆典 Description对于给定字符串 $S$ 的每一个前缀 $S[1\\cdots i]$ $(1 \\leq i \\leq |S|)$，求出 $f(S[1\\cdots i])$。 定义 $f(T)$ 为最小的 $i\\ (1\\leq i\\leq|T|)$ 满足 $T_i=min(T_1,T_2\\cdots T_{|T|})$ 其中$T_{i}=T[i \\ldots | T |] : T1 \\ldots i-1$ (冒号表示字符串拼接) $|S|\\leq 3\\times 10^6$ Sample Input1abaacaba Sample Output11 1 3 3 3 6 3 8 ​ Solution可以尝试记录到当前点为止可能成为答案点的集合，这些起始点之间任意两个的 $ LCP$ 都一定能够延伸到当前点（否则的话无论后面再加什么字符，有一位大了的一定永远大于另一个） 考虑有两个候选答案 $i$ ，$j$ ，它们关系如下图 那么可以看出红色串一定是某个 $S_a$串重复若干遍最后截了一部分（可能没有）形成的， 假设此时 $n-i+1\\geq 2*(i-j+1)$ ,那么我们可以找到 $i$ 之后的第一个 $S_a$ 开始的位置记为 $k$ ,并把最后剩下的不满一个 $S_a$ 的记为 $S_b$ ，$j$ 左边记为 $S_x$ ，$k$ 之后 $S_a$ 出现了 $n$ 次 $(n\\geq 0)$ 然后我们考虑原题中的 $T$ 函数 \\begin{align} T_j&={S_a}^{n+2}S_bS_x\\\\ T_i&={S_a}^{n+1}S_bS_xS_a\\\\ T_k&={S_a}^nS_bS_x{S_a}^2\\\\ \\end{align}然后考虑相邻两项大小关系的充要条件 \\begin{align} T_j","categories":[{"name":"总结","slug":"总结","permalink":"https://buzhibujue.cf/categories/总结/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://buzhibujue.cf/tags/字符串/"}]},{"title":"SPOJ DIV1CNT","slug":"SPOJDIV1CNT","date":"2019-06-14T01:29:50.000Z","updated":"2020-05-03T15:34:36.000Z","comments":true,"path":"2019/06/14/SPOJDIV1CNT/","link":"","permalink":"https://buzhibujue.cf/2019/06/14/SPOJDIV1CNT/","excerpt":"","text":"SPOJ DIV1CNT DescriptionLet$ s_1(n)$be the sum of positive proper divisors of $n$.For example, $s_1(1) = 0, $$ s_1(2) = 1$ and $s_1(6) = 6$Let$S(n) = \\sum _{i=1}^n s_1(i).$Given $N$, find $S(N)$. InputFirst line contains $T$ $(1 \\le T \\le 10^5$), the number of test cases.Each of the next $T$ lines contains a single integer $N$. $(1 \\le N &lt;2^{63}$) OutputFor each number $N$, output a single line containing $S(N)$. Sample Input12345676123101001000000000000000000 Sample Output123456012323249322467033424113218863487627735401433 洛谷题面 Solution题意即求$\\sigma_0 i$的前缀和 \\begin{align} \\sigma_{0}(n)&=\\sum_{i=1}^{n}\\left\\lfloor\\frac{n}{i}\\right\\rfloor\\\\ &=\\sum_{i=1}^{n}\\sum_{j=1}^n\\left[i\\times j","categories":[{"name":"SPOJ","slug":"SPOJ","permalink":"https://buzhibujue.cf/categories/SPOJ/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://buzhibujue.cf/tags/数学/"},{"name":"凸包","slug":"凸包","permalink":"https://buzhibujue.cf/tags/凸包/"}]},{"title":"2019江苏省队集训Day6T2","slug":"2019江苏省队集训Day6T2","date":"2019-06-13T05:57:51.000Z","updated":"2020-05-03T15:33:28.000Z","comments":true,"path":"2019/06/13/2019江苏省队集训Day6T2/","link":"","permalink":"https://buzhibujue.cf/2019/06/13/2019江苏省队集训Day6T2/","excerpt":"","text":"【2019 江苏省队第一轮集训】D6T2 计数 Description对于一个01 串s, 定义f (s) 为. $ f(s)=\\sum_{i=0}^{\\frac{|s|}{2}-1}\\left[s_{i}=s_{|s|-1-i}\\right]$ 其中$[x = y] $是个函数, 其定义为 $[x=y]=\\left\\{\\begin{array}{ll}{1,} &amp; {x=y} \\\\ {0,} &amp; {x \\neq y}\\end{array}\\right.$ 读入一个串01 串S , 记其所有非空子序列构成的多重集为$P(S)$. 比如$S = 010$,那么$P(S) = [0; 1; 0; 01; 00; 10; 010]$. S 一共有$2^{|S|-1} $个不同的非空子序列, 于是有$|P(S )| = 2^{|S|-1}$ .求$\\sum_{s\\in P(S )} f (s)$ 对$998244353 $取模后的值.比如对于$S = 010$, 答案为$f (0) + f (1) + f (0) + f (01) + f (00) + f (10) + f (010) =0 + 0 + 0 + 0 + 1 + 0 + 1 = 2$. Input从文件$count.in $中读入数据。输入第一行读入一个字符串$S$ . Output输出到文件$count.out $中。输出$\\sum_{s\\in P(S)}f(s)$对$998244353 $取模后的值. Sample Input1010 Sample Output12 Solution如果按照神仙的题解方式： 贪心即可。 ————《衍芃福音——雅礼集训》第1章——矩阵 搞出来 dp 就行。————《衍芃福音——雅礼集训》第3章——水箱 李超树板子。 ————《衍芃福音——雅礼集训》第3章——线段游戏 该怎么 dp 怎么 dp 就行了吧。 ————《衍芃福音——雅礼集训》第10章——数列 原文地址 那么就应该是 NTT即可。 搞出来卷积即可。 NTT板子。 该怎么卷积就怎么卷积就行了吧。 。。。 还是写点我等凡人能看懂的题解：=.= 有一个套路式子（我考场上就不会太菜了） \\begin{align} &\\sum_{k=0}^{n}\\sum_{i=0}^{n}\\sum_{j=0}^{n-i}\\binom{i}{k}\\binom{j}{k}\\\\ &=\\sum_{i=0}^n\\sum_{j=0}^n\\binom{i+j}{i} \\end{align}然后枚举一对$A,\\ B\\ 使得\\ S[A]==S[n-B-1]\\ (0base)$，它们对答案的贡献就是左右各自选相等的若干个，中间的$n-2-A-B$个任意选或者不选，则有 \\begin{align} ans&=\\sum_{A=0}^{n-2}\\sum_{k=0}^{n-2}\\binom{A}{k}\\times\\sum_{B=0}^{n-2-A}[s[A]=S[n-B-1]]\\binom{B}{k}\\times2^{n-2-A-B}\\\\ &枚举相等的值val\\\\ &=\\sum_{val=0}^1[S[A]=S[n-B-1]=val]\\sum_{k=0}^{n-2}\\sum_{A=0}^{n-2}\\sum_{B=0}^{n-2-A}\\binom{A}{k}\\times\\binom{B}{k}\\times2^{n-2-A-B}\\\\ &=\\sum_{val=0}^1[S[A]=S[n-B-1]=val]\\sum_{A=0}^{n-2}\\sum_{B=0}^{n-2-A}\\binom{A+B}{A}\\times2^{n-2-A-B}\\\\ &=\\sum_{val=0}^1[S[A]=S[n-B-1]=val]2^{n-2}\\times\\sum_{C=A+B=0}^{n-2}\\frac{C!}{2^C}\\times\\sum_{A=0}^{n-2}\\frac{1}{A!\\times (C-A)!}\\\\ \\end{align}这下可以说该怎么卷积就怎么卷积了 代码里字符串是1base Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"count\"#define mul3(a,b,c) mul(mul(a,b),c)using namespace std;const int N=2.5e5+5,MOD=998244353,P=19;inline int add(int a,const int &amp;b)&#123;if((a+=b)&gt;=MOD)a-=MOD;return a;&#125;inline int sub(int a,const int &amp;b)&#123;if((a-=b)&lt; 0)a+=MOD;return a;&#125;inline int mul(const int &amp;a,const int &amp;b)&#123;return 1ll*a*b%MOD;&#125;inline int sqr(const int &amp;a)&#123;return mul(a,a);&#125;inline int&amp; inc(int &amp;a,const int &amp;b)&#123;return a=add(a,b);&#125;inline int&amp; dec(int &amp;a,const int &amp;b)&#123;return a=sub(a,b);&#125;inline int&amp; pro(int &amp;a,const int &amp;b)&#123;return a=mul(a,b);&#125;inline int qpow(int a,int b)&#123;int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;&#125;int fac[N],inv[N],invc[N],bin[N],invb[N];int w[2][1&lt;&lt;P],rev[1&lt;&lt;P];inline int C(const int &amp;a,const int &amp;b)&#123;return a&gt;=b?mul3(fac[a],invc[b],invc[a-b]):0;&#125;int n,ans;inline void pre()&#123; fac[0]=fac[1]=inv[0]=inv[1]=invc[0]=invc[1]=bin[0]=invb[0]=1; bin[1]=2;invb[1]=MOD+1&gt;&gt;1; for(int i=2;i&lt;=n;i++)fac[i]=mul(fac[i-1],i),inv[i]=mul(inv[MOD%i],MOD-MOD/i),invc[i]=mul(invc[i-1],inv[i]),bin[i]=mul(bin[i-1],2),invb[i]=mul(invb[i-1],invb[1]); for(int i=1;i&lt;1&lt;&lt;P;i&lt;&lt;=1)&#123; w[0][i]=w[1][i]=1; int wn1=qpow(3,(MOD-1)/(i&lt;&lt;1)),wn0=qpow(wn1,MOD-2); for(int j=1;j&lt;i;j++) w[0][i+j]=mul(w[0][i+j-1],wn0),w[1][i+j]=mul(w[1][i+j-1],wn1); &#125;&#125;inline void ntt(int *f,int opt,int l)&#123; for(int i=0;i&lt;l;i++)&#123;rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)*l&gt;&gt;1;if(i&lt;rev[i])swap(f[i],f[rev[i]]);&#125; for(int i=1;i&lt;l;i&lt;&lt;=1) for(int j=0;j&lt;l;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++)&#123; int x=f[j+k],y=mul(f[i+j+k],w[opt][i+k]); f[j+k]=add(x,y); f[i+j+k]=sub(x,y); &#125; if(opt)for(int i=0,inv=qpow(l,MOD-2);i&lt;l;i++)pro(f[i],inv);&#125;char s[N];#define poly vector&lt;int&gt;inline void out(const poly &amp;a)&#123; for(int i=0,n=a.size();i&lt;n;i++)printf(\"%d%c\",a[i],i^n-1?' ':'\\n');&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),l=1; while(l&lt;n+m)l&lt;&lt;=1; a.resize(l);b.resize(l); ntt(&amp;a[0],0,l);ntt(&amp;b[0],0,l); for(int i=0;i&lt;l;i++)pro(a[i],b[i]); ntt(&amp;a[0],1,l); a.resize(n+m-1); return a;&#125;inline poly&amp; operator *=(poly &amp;a,const poly &amp;b)&#123;return a=a*b;&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); //freopen(FIO\".out\",\"w\",stdout); scanf(\"%s\",s+1); n=strlen(s+1); pre(); poly f,g; for(int val=0;val&lt;2;val++)&#123; f.clear(); g.clear(); f.resize(n); g.resize(n); for(int i=0;i&lt;n;i++)f[i]=(s[i+1]==val+'0')?invc[i]:0,g[i]=(s[n-i]==val+'0')?invc[i]:0; f*=g; f.resize(n); for(int k=0;k&lt;n-1;k++) inc(ans,mul3(f[k],fac[k],invb[k])); &#125; printf(\"%d\\n\",mul(ans,bin[n-2])); return 0;&#125;","categories":[],"tags":[{"name":"计数","slug":"计数","permalink":"https://buzhibujue.cf/tags/计数/"},{"name":"NTT","slug":"NTT","permalink":"https://buzhibujue.cf/tags/NTT/"}]},{"title":"SCOI2019总结","slug":"SCOI2019总结","date":"2019-04-16T15:04:58.000Z","updated":"2020-05-03T15:34:32.000Z","comments":true,"path":"2019/04/16/SCOI2019总结/","link":"","permalink":"https://buzhibujue.cf/2019/04/16/SCOI2019总结/","excerpt":"","text":"SCOI2019 总结 Day -1整个白天就打了个$SA$的板子，感觉$SCOI$应该要考字符串，再打了个$FFT$板子题就没做什么事了，然后就颓一下午知乎。不上晚自习提前放学跑步时看到佬和几个物理组的在打球，感觉马上退役了晚自习前就也可以这么玩了。 在家里随意看了一下之前省选前定的计划发现可能还有$Polya$和$Min25$没学，感觉应该不会考也没多在意，上洛谷看了几道今日推荐结果全是数据结构而且题解都看得很麻烦就都没打，大致过了几个背不到的板子就睡了。 Day0上午报到基本没人，就一张表填一下就发一个学校的准考证，感觉好水然后看了一下下午考场就骑自行车回去开会，感觉人手一本复习的单子有点方，不过应该没什么大问题。吃了饭进考场拿到试题一看抬头 一、选择题 100/100 ???说好的字迹清晰呢？还以为填空题，差点就去全字匹配了。结果是没有机读卡，而且连个答题卡都没有，NOIP初赛都有啊，初中周练也有啊，不知道怎么回事于是开始慢慢做然后旁边老哥以1分钟翻一面的速度快速AK搞得我有点慌就也加了点速度用了5分钟做完。剩余的$55$分钟感觉非常浪费人生。后面并没有提前离场因为看到有同班的也没有走，于是开始检查试卷。一共找了卷子上$5$个BUG…… 回去之后大致扫了下$polya$感觉考到也不会就弃了。 Day1$7:50$时全场都在敲键盘什么鬼，测试电脑硬件需要打板吗，一开始还没反应过来，反应过来之后就也开始“测试键盘鼠标是否正常”了（CCF：“竞”赛一年） 拿到题感觉$T1$可做$T2$区间重心$T3$不知道是个什么鬼 看了一遍$T1$咋不是直接从$1$到$n$过去呢？后来才发现好像很不对，一定是最小的才能跳，感觉很汉诺塔就画了个$n=3$一推感觉很对，发现样例是$2$还是对的，写了一个辣鸡递归感觉${O}(qm)$随便跑，一测大样例$3,4$个点没过盲猜$long\\ long$一测过了感觉很对的样子，曰：此乃签到，不久后突然发现可能需要高精度，但是不是很懂$30$的限制是怎么回事，打一下表发现大多$long\\ long$是在$38,39$左右挂的，感叹原来是防止炸$long\\ long$避免我们写高精，赞曰SCOI出题人什么时候这么良心！然后$T2$一看各种做法，然后想到了虚树的$35$但不知怎么换根$DP$没想到，以为复杂度$O(n^3)$就乱搞了一个链剖$O(nq\\log n)$每次枚举选哪个。写着写着发现需要可持久化，那就加吧，然后又发现要区间操作，凭着可能两周前还有的印象开始写，然后经历了一些时间消失的魔法（虚拟机卡卡卡卡卡卡卡卡卡，写区间修改主席树调调调调调调调）之后就到了$12:00$，哇$8:45$写完$T1$这个$T2$写$3$个小时写不出来有毒，不过并没有慌因为平时熬夜晚上调$2,3$个小时调出来并不慌，开始写$T3$特判感觉非常顺畅然后后并没有爆搜分感觉非常不可做赶紧回来调$T2$，可能发现之前的线段树写法有锅$qry$两边都有的情况写成$qry(ql,qr,l,mid)+qry(ql,qr,mid+1,r)$然而这里应该是$qry(ql,mid,l,mid)+qry(mid+1,qr,mid+1,r)$可能查了很久的错以及改半天找到的错才改完等终于过了自测小样例拍了起来。还有$20$分钟想着先测一下虚拟机能否编译再写一下链或者$T1$高精度吧（这时候都没反应到高精要多$500$的常数导致$O(qm)$过不了）然后开虚拟机，然后卡死，然后测编译过了，然后点击关闭，然后卡死，然后就时间到了。辣鸡电脑毁我青春 出来之后感觉全世界都写了高精，真是菜，一下被甩$50pts$，不过抱着本来就是来打酱油的心情并没有什么不好（主要终于调出$T2$开心的一比，差点写了不知道多少$k$的代码就爆零了）。然后下午面试第一组，准备了半天的“不含个人信息及学校信息”的自我介绍没用上……直接无领导讨论，感觉有几个人是互相认识的就一直在那扯一些别的与主题不相关的东西，我提醒一遍后还是走偏了，于是感觉正常水平吧（出分后面试很菜，不知道为什么，神大以后如果还有面试分组的时候还是注意点分组比较好）然后看成绩$50+20+30$和估分一样可还行(然而考场估分$100+20+30$)当时感觉还行吧，不过其他人$T1$的$O(qm)$好像被卡了，和不写高精的我一样哈哈，睡觉的时候才反应过来好像接近垫底了，不过还是没什么感觉，主要就是来打酱油也不会去想翻盘什么的。晚上并没有看$Min25$（感觉这东西并不会考）而是随便翻翻书，看了会手机就睡了。 Day 2 今年的$SCOI$依旧有计算几何$.jpg$ 有了昨天的经验还是早早的“测试好键盘鼠标工作正常”然后开题，$T1$一眼看过去区间叉积求绝对值最大，又看了几下感觉没什么问题开始推式子，看数据范围(昨天$T1$没写$Q$数据范围所以自信$long\\ long$)没什么坑点，先写一个$O(n^3)$感觉很对，然后感觉前缀和一下就是直接的最大减最小不用考虑前后关系，用这两个拍了一会感觉很对，感觉$O(n^2)dp$的一个优化套路就是凸包啥的，草稿纸上手算一下没问题，写了一下拍过了，这么这么水，考前一周才在调一个凸包的题边界被恶心死了，结果这题一遍过样例一遍过拍???EXM???然后$O(n\\log n)$曰：此乃签到。然后看$T2$一眼看上去感觉送了$60$分分类讨论，$T3$也是好像做的时间越长得分越多的样子。（这之间突然说$T2$要加模数，感觉SCOI出题人真😁不过有昨天调到十二点的经历我觉得还是达到$11$点写不出来就换$T3$，结果到了$10$点过电脑开始卡死了，编译一次一分钟有毒，叫了“监考人员”（还是工作人员？记不到了）于是来了一个应该也是大学生退役的$Oier$来看，并没有什么用(辣鸡电脑，确实没救)。说可能换$IDE$会快点，（我$vimer$就是从这里跳下去，也不会用你一个$dev$! 真香）然后他就走了。测了一下$dev$编译用时$49$秒整（神大电脑真😁😁）然后可能突然好了点十多秒就可以编译，然后写着写着又卡死了，$PDF$往下翻会出现大片空白，开个$vim$一分钟，又找了一遍“监考人员”来了一个很像专家的工作人员，然后注销，然后没用，然后重启，然后好了，我问能不能加时结果对曰:“这是你程序的问题，在你程序运行之前是没有问题的。懂我意思吧。”我😁😁😁。然后继续调$T2$突然过了样例，一测小数据一$WA$答案大了一点，然后有个地方写的锅有点大，改之，然后样例过不了了…发现把一个$i$，$j$打反了， 改之，样例还是过不了，我xxxxx这数据真😁。然后可能突然$12:08$了，不慌不忙写了$T3$的$20$分暴力，然后一个$W=0$感觉可以线性基，然后就感觉不可做了（这熟悉的套路）然后继续冷静调$T2$好像一对$f,g$算了多次，加了个$break$，过了，一拍很稳，然后时间不多了不敢开虚拟机怕又卡死就检查了下文件然后结束。 出来在楼梯上听到$Joker$说什么$T1$两个$log$的优化吓我一跳，以为自己写了个惊天假做法，然后遇到$DXY master$写的是一样的感觉稳多了，$T2$，$T3$感觉也没什么问题该写的都写了。下午在神大闲逛，和$J{\\color{red}{erome_wei}}$大神打了会球然后颓了会昨天新下回来的虚荣，老年人操作不来$5$连跪。然后就出成绩了，$100+30+40$还是和估分一样可还行，$J{\\color{red}{erome_wei}}$好像挂了$100$不然就进队了，$142857\\ SC$队长好稳啊，高二$4$个$A$队好稳啊，我又被初中生吊打了好菜啊，然后就该申诉的申诉，该回家的回家了。 总结感觉省选发挥还行吧，抱着打酱油的心态就会“不以物喜不以己悲”了吧。第一天比较菜也没有影响第二天翻盘（?)，两天都调了一道两三个小时的题还都调出来了可还行吧(?)，然后可能就还是不回文化课放松(?)了吧，新装备正在路上，还是要继续努力啊！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/tags/随笔/"}]},{"title":"动态DP","slug":"动态DP","date":"2018-12-07T16:24:00.000Z","updated":"2020-05-03T15:35:38.000Z","comments":true,"path":"2018/12/08/动态DP/","link":"","permalink":"https://buzhibujue.cf/2018/12/08/动态DP/","excerpt":"","text":"从$NOIPD2T3$发现的神仙玩意，虽然可能没啥用但还是试试学一学顺便练练码力。 保卫王国 DescriptionZ国有$n$ 座城市，$n-1$ 条双向道路，每条双向道路连接两座城市，且任意两座城市都能通过若干条道路相互到达。Z国的国防部长小Z要在城市中驻扎军队。驻扎军队需要满足如下几个条件：● 一座城市可以驻扎一支军队，也可以不驻扎军队。● 由道路直接连接的两座城市中至少要有一座城市驻扎军队。● 在城市里驻扎军队会产生花费，在编号为$i$的城市中驻扎军队的花费是$p_i$ 。小Z很快就规划出了一种驻扎军队的方案，使总花费最小。但是国王又给小Z提出了$m$个要求，每个要求规定了其中两座城市是否驻扎军队。小Z需要针对每个要求逐一给出回答。具体而言，如果国王提出的第$j$个要求能够满足上述驻扎条件（不需要考虑第$j$个要求之外的其它要求），则需要给出在此要求前提下驻扎军队的最小开销。如果国王提出的第$j$个要求无法满足，则需要输出$-1$ $(1\\leq j\\leq m)$ 。现在请你来帮助小Z。 Input第 $1$ 行包含两个正整数$n,m$和一个字符串$type$，分别表示城市数、要求数和数据类型。$type$是一个由大写字母 $A$，$B$ 或 $C$ 和一个数字 $1$，$2$，$3$ 组成的字符串。它可以帮助你获得部分分。你可能不需要用到这个参数。这个参数的含义在【数据规模与约定】中 有具体的描述。第 $2$ 行$n$个整数$p_i$ 表示编号$i$的城市中驻扎军队的花费。接下来 $n−1$ 行，每行两个正整数$u,v$，表示有一条uu到vv的双向道路。接下来 $m$ 行，第$j$行四个整数$a,x,b,y(a ≠ b)$，表示第$j$个要求是在城市$a$驻扎$x$支军队， 在城市$b$驻扎$y$支军队。其中，$x$、$ y$ 的取值只有$0$或$1$：若$x$ 为$0$，表示城市$a$ 不得驻 扎军队，若$x$ 为$1$，表示城市$a$ 必须驻扎军队；若$y$为$0$，表示城市$b$不得驻扎军队， 若$ y$为$1$，表示城市$b$ 必须驻扎军队。输入文件中每一行相邻的两个数据之间均用一个空格分隔。 Output输出共 $m$ 行，每行包含 $1$ 个整数，第$j$行表示在满足国王第$j$个要求时的最小开销， 如果无法满足国王的第$j$个要求，则该行输出 $−1$。 Sample Input1234567895 3 C3 2 4 1 3 9 1 5 5 2 5 3 3 4 1 0 3 0 2 1 3 1 1 0 5 0 Sample Output12312 7 -1 Hint【样例解释】对于第一个要求，在$4$ 号和 $5$ 号城市驻扎军队时开销最小。对于第二个要求，在 $1$ 号、$2$ 号、$3$ 号城市驻扎军队时开销最小。第三个要求是无法满足的，因为在 $1$ 号、$5$ 号城市都不驻扎军队就意味着由道路直接连 接的两座城市中都没有驻扎军队。【数据规模与约定】对于 $100\\%$的数据，$n,m ≤ 100000,1 ≤ p_i ≤ 100000$数据类型的含义：$A$：城市ii与城市$i +1$直接相连。$B$：任意城市与城市 $1$ 的距离不超过 $100$（距离定义为最短路径上边的数量），即如果这棵树以 $1$ 号城市为根，深度不超过 $100$。$C$：在树的形态上无特殊约束。$1$：询问时保证$a = 1,x = 1$即要求在城市 $1$ 驻军。对$b,y$没有限制。$2$：询问时保证$a,b$是相邻的（由一条道路直接连通）$3$：在询问上无特殊约束。 Solution考场上并不会，前几天先写了个简简单单的倍增然后就草到榜一，主要就是比一般倍增记自己状态外多记$2^{i-1}$父亲是否取的状态，这样才能转移 \\begin{align} f[u][i][0/1][0/1]&表示u的2^i级祖先在u是否取及u的2^i级祖先是否取时的答案\\\\ 转移即是 &\\quad f[u][i-1][0/1（u是否取）][0/1（2^{i-1}级祖先是否取）]\\\\ &+f[u的2^{i-1}级祖先][i-1][0/1（2^{i-1}级祖先是否取)][0/1(2^{i}级祖先是否取)]\\\\ &=f[u][i][0/1(u是否取)][0/1（2^i级祖先是否取)]\\\\ 边界情况i=0&时即自己和父亲\\\\ &f[u][0][0][0]=INF;\\\\ &f[u][0][1][0]=dp[p][0];\\\\ &f[u][0][1][1]=dp[p][1]-min(dp[u][0],dp[u][1])+dp[u][1];\\\\ &f[u][0][0][1]=dp[p][1]-min(dp[u][0],dp[u][1])+dp[u][0];\\\\ \\end{align}查询时像求$LCA$一样往上倍增即可还有注意到计算方法是先减去原来这条链的答案再加现在这条链的答案。（搞不清楚循环咋搞的可以循环展开）可能会快个$200ms$左右并不太大影响记得数组不要开小以及$long\\ long$就行居然没调很久2A。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define FIO \"defense\"#define ll long longusing namespace std;const int N=1e5+5;const ll INF=1e15;char type[5];int w[N],n,m,u,v,dep[N],x,y;int ecnt,head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],fa[N][18];ll dp[N][2],f[N][18][2][2],cur[2][2],tmp[2][2];inline void add(int u,int v)&#123;nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;&#125;inline void dfs1(int u,int p)&#123; fa[u][0]=p;dp[u][1]=w[u];dep[u]=dep[p]+1; for(int i=1;i&lt;18;i++)fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^p)&#123;dfs1(v,u);dp[u][0]+=dp[v][1];dp[u][1]+=min(dp[v][0],dp[v][1]);&#125;&#125;inline void dfs2(int u,int p)&#123; f[u][0][0][0]=INF; f[u][0][1][0]=dp[p][0]; f[u][0][1][1]=dp[p][1]-min(dp[u][0],dp[u][1])+dp[u][1]; f[u][0][0][1]=dp[p][1]-min(dp[u][0],dp[u][1])+dp[u][0]; for(int i=1;i&lt;18;i++)&#123; int t=fa[u][i-1]; f[u][i][0][0] = min(f[t][i-1][0][0]-dp[t][0]+f[u][i-1][0][0], f[t][i-1][1][0]-dp[t][1]+f[u][i-1][0][1]); f[u][i][1][0] = min(f[t][i-1][0][0]-dp[t][0]+f[u][i-1][1][0], f[t][i-1][1][0]-dp[t][1]+f[u][i-1][1][1]); f[u][i][0][1] = min(f[t][i-1][0][1]-dp[t][0]+f[u][i-1][0][0], f[t][i-1][1][1]-dp[t][1]+f[u][i-1][0][1]); f[u][i][1][1] = min(f[t][i-1][0][1]-dp[t][0]+f[u][i-1][1][0], f[t][i-1][1][1]-dp[t][1]+f[u][i-1][1][1]); /* 等价于 for(int j=0;j&lt;=1;j++) for(int k=0;k&lt;=1;k++) f[u][i][j][k]=min(f[t][i-1][0][k]-dp[t][0]+f[u][i-1][j][0],f[t][i-1][1][k]-dp[t][1]+f[u][i-1][j][1]); */ &#125; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^p)dfs2(v,u);&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d%s\",&amp;n,&amp;m,type); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;u,&amp;v),add(u,v),add(v,u); dfs1(1,0);dfs2(1,0); while(m--)&#123; scanf(\"%d%d%d%d\",&amp;u,&amp;x,&amp;v,&amp;y); if(!x&amp;&amp;!y&amp;&amp;(fa[u][0]==v||fa[v][0]==u))&#123;puts(\"-1\");continue;&#125; if(dep[u]&lt;dep[v])swap(u,v),swap(x,y); cur[0][0]=x?INF:dp[u][0]; cur[0][1]=x?dp[u][1]:INF; cur[1][0]=y?INF:dp[v][0]; cur[1][1]=y?dp[v][1]:INF; for(int i=17;~i;i--)if(dep[fa[u][i]]&gt;=dep[v])&#123; tmp[0][0]=min(f[u][i][0][0]-dp[u][0]+cur[0][0],f[u][i][1][0]-dp[u][1]+cur[0][1]); tmp[0][1]=min(f[u][i][0][1]-dp[u][0]+cur[0][0],f[u][i][1][1]-dp[u][1]+cur[0][1]); cur[0][0]=tmp[0][0];cur[0][1]=tmp[0][1]; u=fa[u][i]; &#125; if(u==v)&#123; if(y)cur[0][0]=INF;else cur[0][1]=INF; &#125;else&#123; for(int i=17;~i;i--)if(fa[u][i]^fa[v][i])&#123; tmp[0][0]=min(f[u][i][0][0]-dp[u][0]+cur[0][0],f[u][i][1][0]-dp[u][1]+cur[0][1]); tmp[0][1]=min(f[u][i][0][1]-dp[u][0]+cur[0][0],f[u][i][1][1]-dp[u][1]+cur[0][1]); tmp[1][0]=min(f[v][i][0][0]-dp[v][0]+cur[1][0],f[v][i][1][0]-dp[v][1]+cur[1][1]); tmp[1][1]=min(f[v][i][0][1]-dp[v][0]+cur[1][0],f[v][i][1][1]-dp[v][1]+cur[1][1]); /* 等价于 for(int j=0;j&lt;=1;j++) for(int k=0;k&lt;=1;k++) tmp[j][k]=min(f[j?v:u][i][0][k]-dp[j?v:u][0]+cur[j][0],f[j?v:u][i][1][k]-dp[j?v:u][1]+cur[j][1]); */ memcpy(cur,tmp,sizeof cur); u=fa[u][i];v=fa[v][i]; &#125; int p=fa[u][0]; tmp[1][0]=dp[p][0]-dp[u][1]-dp[v][1]; tmp[1][1]=dp[p][1]-min(dp[v][0],dp[v][1])-min(dp[u][0],dp[u][1]); tmp[0][0]=tmp[1][0]+cur[0][1]+cur[1][1]; tmp[0][1]=tmp[1][1]+min(cur[0][0],cur[0][1])+min(cur[1][0],cur[1][1]); cur[0][0]=tmp[0][0];cur[0][1]=tmp[0][1];u=p; &#125; for(int i=17;~i;i--)if(fa[u][i])&#123; tmp[0][0]=min(f[u][i][0][0]-dp[u][0]+cur[0][0],f[u][i][1][0]-dp[u][1]+cur[0][1]); tmp[0][1]=min(f[u][i][0][1]-dp[u][0]+cur[0][0],f[u][i][1][1]-dp[u][1]+cur[0][1]); cur[0][0]=tmp[0][0];cur[0][1]=tmp[0][1];u=fa[u][i]; &#125; printf(\"%lld\\n\",min(cur[0][0],cur[0][1])); &#125; return 0;&#125; 然后就是本文主角 (出场这么晚)的动态$DP$(动态动态规划orz)的做法，其实就是链剖然后用线段树维护矩阵。 注意转移轻链时的情况怎么写的。然而比倍增慢太多不开$O2$洛谷上T翻了$(72)$其实是我写的丑。以及开$LL$(好奇会不会有考场上写正解忘开$LL$见祖宗的神犇) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define FIO \"defense\"#define ll long longusing namespace std;const int N=1e5+5;ll INF=1e15,F[2]=&#123;INF,-INF&#125;;char type[5];int n,m,u,v,x,y;int ecnt,head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],fa[N],top[N];ll w[N],dp[N][2];int id[N],rnk[N],cnt,son[N],sz[N],len[N];inline void add(int u,int v)&#123;nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;&#125;inline void dfs1(int u,int p)&#123; fa[u]=p;dp[u][1]=w[u];sz[u]=1; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^p)&#123; dfs1(v,u);sz[u]+=sz[v];if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; dp[u][0]+=dp[v][1];dp[u][1]+=min(dp[v][0],dp[v][1]); &#125;&#125;inline void dfs2(int u,int t)&#123; len[t]++;id[u]=++cnt;rnk[cnt]=u;top[u]=t;if(son[u])dfs2(son[u],t); for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u])dfs2(v,v);&#125;//id[u]=i rnk[i]=u#define mid ((l+r)&gt;&gt;1)#define lk (k&lt;&lt;1)#define rk (k&lt;&lt;1|1)struct matrix&#123; ll v[2][2]; matrix()&#123;v[0][0]=v[0][1]=v[1][0]=v[1][1]=INF;&#125; inline ll *operator [](int x)&#123;return v[x];&#125; matrix operator *(matrix t)&#123; matrix ret; for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)for(int k=0;k&lt;2;k++)ret[i][j]=min(ret[i][j],v[i][k]+t[k][j]); return ret; &#125;&#125;a[N&lt;&lt;2],val[N];inline void pushup(int k)&#123;a[k]=a[lk]*a[rk];&#125;inline void build(int k,int l,int r)&#123; if(l==r)&#123; ll &amp;g0=a[k][0][1],&amp;g1=a[k][1][0]; g0=0;g1=w[rnk[l]]; for(int u=rnk[l],i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) g0+=dp[v][1],g1+=min(dp[v][0],dp[v][1]); a[k][1][1]=g1; val[l]=a[k]; return; &#125; build(lk,l,mid);build(rk,mid+1,r); pushup(k);&#125;inline matrix qry(int k,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr);&#125;inline matrix qry(int u)&#123;return qry(1,1,n,id[u],id[u]+len[u]-1);&#125;inline void modify(int k,int l,int r,int pos)&#123; if(l==r)&#123;a[k]=val[l];return;&#125; if(pos&lt;=mid)modify(lk,l,mid,pos); else modify(rk,mid+1,r,pos); pushup(k);&#125;#undef mid#undef lk#undef rkinline void modify(int u,ll x)&#123; val[id[u]][1][0]+=x-w[u];val[id[u]][1][1]=val[id[u]][1][0];w[u]=x; matrix pre,nxt; while(u)&#123; pre=qry(top[u]); modify(1,1,n,id[u]); nxt=qry(top[u]); u=fa[top[u]]; val[id[u]][0][1]+=nxt[1][1]-pre[1][1]; val[id[u]][1][0]+=min(nxt[0][1],nxt[1][1])-min(pre[0][1],pre[1][1]); val[id[u]][1][1]=val[id[u]][1][0]; &#125;&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d%s\",&amp;n,&amp;m,type); for(int i=1;i&lt;=n;i++)scanf(\"%lld\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;u,&amp;v),add(u,v),add(v,u); dfs1(1,0); dfs2(1,1); build(1,1,n); while(m--)&#123; scanf(\"%d%d%d%d\",&amp;u,&amp;x,&amp;v,&amp;y); if(!x&amp;&amp;!y&amp;&amp;(fa[u]==v||fa[v]==u))&#123;puts(\"-1\");continue;&#125; int tmp1=w[u],tmp2=w[v]; modify(u,F[x]);modify(v,F[y]); matrix ans=qry(1); printf(\"%lld\\n\",min(ans[0][1],ans[1][1])+(x?tmp1-F[x]:0)+(y?tmp2-F[y]:0)); modify(u,tmp1);modify(v,tmp2); &#125; return 0;&#125; 洛谷4719 Description给定一棵$n$个点的树，点带点权。有$m$次操作，每次操作给定$x,y$表示修改点$x$的权值为$y$。你需要在每次操作之后求出这棵树的最大权独立集的权值大小。 Input第一行，$n,m$分别代表点数和操作数。第二行，$V_1,V_2,…,V_n$ 代表$n$个点的权值。接下来$n-1$行，$x,y$,描述这棵树的$n-1$条边。接下来$m$行，$x,y$,修改点$x$的权值为$y$。 Output对于每个操作输出一行一个整数，代表这次操作后的树上最大权独立集。保证答案在$int$范围内 Hint对于$30\\%$的数据，$1\\leq n,m\\leq 10$ 对于$60\\%$的数据，$1\\leq n,m\\leq 1000$ 对于$100\\%$的数据，$1\\leq n,m\\leq 10^5$ Solution动态$DP$求树上最大权独立集板子，想法类似刚才那道题。所以$NOIP$考$NOIplus$吗?注意什么时候是$[1][0]$什么时候是$[0][1]$不要搞反以及矩阵初值是零不是$-inf$就好(鬼知道这两个东西我找了多久) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define FIO \"P4719\"using namespace std;const int N=1e5+5,INF=1e9;int w[N],n,m,top[N],rnk[N],id[N],cnt,x,y,f[N][2];int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],ecnt,sz[N],son[N],fa[N],len[N];namespace tree&#123; inline void add(int u,int v)&#123;nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;&#125; inline void dfs1(int u)&#123; sz[u]=1;f[u][1]=max(w[u],0); for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u])&#123; fa[v]=u;dfs1(v);sz[u]+=sz[v]; f[u][0]+=max(f[v][0],f[v][1]);f[u][1]+=f[v][0]; if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; &#125; &#125; inline void dfs2(int u,int t)&#123; rnk[++cnt]=u;id[u]=cnt;top[u]=t;len[t]++; if(son[u])dfs2(son[u],t); for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u])dfs2(v,v); &#125; inline void build()&#123; for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(1);dfs2(1,1); &#125;&#125;namespace seg&#123; struct matrix&#123; int v[2][2]; matrix()&#123;v[0][0]=v[0][1]=v[1][0]=v[1][1]=0;&#125; inline int *operator[](int x)&#123;return v[x];&#125; matrix operator *(matrix t)&#123; matrix ret; for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)for(int k=0;k&lt;2;k++)ret[i][j]=max(ret[i][j],v[i][k]+t[k][j]); return ret; &#125; inline void out()&#123; printf(\"%d %d\\n%d %d\\n-----\\n\",v[0][0],v[0][1],v[1][0],v[1][1]); &#125; &#125;a[N&lt;&lt;2],val[N];#define mid ((l+r)&gt;&gt;1)#define lk (k&lt;&lt;1)#define rk (k&lt;&lt;1|1) inline void pushup(int k)&#123;a[k]=a[lk]*a[rk];&#125; inline void build(int k,int l,int r)&#123; if(l==r)&#123; int &amp;g0=a[k][0][0],&amp;g1=a[k][1][0]; g0=0;g1=w[rnk[l]]; for(int u=rnk[l],i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) g0+=max(f[v][0],f[v][1]),g1+=f[v][0]; a[k][0][1]=g0; val[l]=a[k]; return; &#125; build(lk,l,mid);build(rk,mid+1,r); pushup(k); &#125; inline matrix qry(int k,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr); &#125; inline void modify(int k,int l,int r,int pos)&#123; if(l==r)&#123;a[k]=val[l];return;&#125; if(pos&lt;=mid)modify(lk,l,mid,pos);else modify(rk,mid+1,r,pos); pushup(k); &#125; inline void output(int k,int l,int r)&#123; if(l==r)&#123;printf(\"%d~%d\\n\",l,r); a[k].out();return;&#125; output(lk,l,mid);output(rk,mid+1,r); printf(\"%d~%d\\n\",l,r); a[k].out(); &#125; //id[u]=i rnk[i]=u#undef mid#undef lk#undef rk inline matrix qry(int u)&#123;return qry(1,1,n,id[u],id[u]+len[u]-1);&#125; inline void modify(int u,int v) &#123; val[id[u]][1][0]+=v-w[u]; w[u]=v; matrix pre,nxt; while(u)&#123; pre=qry(top[u]); modify(1,1,n,id[u]); nxt=qry(top[u]); u=fa[top[u]]; val[id[u]][0][0]+=max(nxt[0][0],nxt[1][0])-max(pre[0][0],pre[1][0]); val[id[u]][0][1]=val[id[u]][0][0]; val[id[u]][1][0]+=nxt[0][0]-pre[0][0]; &#125; &#125;&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); tree::build(); seg::build(1,1,n); while(m--)&#123; scanf(\"%d%d\",&amp;x,&amp;y); seg::modify(x,y); //seg::output(1,1,n); seg::matrix ans=seg::qry(1); printf(\"%d\\n\",max(ans[0][0],ans[1][0])); &#125; return 0;&#125; 洛谷p4751 Description同上题，强制在线 Hint$n\\leq1∗10^6$,$m \\leq 3*10^6$ Solution（这难度咋跟上一道一样啊=.=可能是没有更高的了吧？？？）然而你谷日常入门难度打NOI+。 卡强制在线的毒瘤玩意，不过之前也不会什么离线乱搞算法，但是之前的树剖$log^2n$肯定$GG$于是学习了一下一个叫全局平衡二叉树的毒瘤玩意 主要想法就是考虑为什么树剖不行？$\\sqrt n$个大小为$\\sqrt n$的节点组成一个二叉树（堆状树）就完美挂掉了，据说对每条重链开一颗线段树可以过，但是现在好像被出题人改数据后过不了，然后又对前$500$个询问离线下来加点权使得更接近中点结果也被卡了。数据加强了这么几次导致我做这题的时候写正解也被卡了 回到这题，本来除了链剖还有一种$LCT$的做法，可惜常数太大过不了这题，而且这题平衡树可以不用改变形态，那么这传说中的全局平衡二叉树究竟是个什么玩意？ 主要思想是先链剖，然后对于每条重链找重心建平衡树，不过每个点的权重是轻儿子的个数$+1$，找到这个中心后重链左右两边再递归建下去就行，这样整颗平衡树的深度是$log$级别的。 为什么？ 如果是重链上的父子，每次向上跳的时候子树大小（这里的子树都是平衡树上的子树，以下类同）至少乘二，（最小的情况是原树这一条链上没有任何其他节点即没有轻儿子），然后对于非重链上的父子，每次向上跳的时候子树大小也会严格大于当前子树大小乘二（因为原树上它父亲至少还有一个重儿子大小大于当前子树大小，不然它就成重儿子了），所以每次在平衡树边向上跳时子树大小都至少乘二，所以总的高度是$log$级别。注意到是平衡树不是线段树所以pushutp时要$a[lk]\\times b[k]\\times a[rk]$而不是$a[lk]\\times a[rk]$123456789101112131415161718192021222324252627//初始化inline void init(int k)&#123; b[k][0][0]=b[k][0][1]=dp[k][0];b[k][1][0]=dp[k][1];&#125;//建二叉树inline int build2(int l,int r)&#123; if(l&gt;r)return 0; int sum=0; for(int i=l;i&lt;=r;i++)sum+=sz[st[i]]; for(int i=l,k=st[i],cur=sz[k];i&lt;=r;i++,k=st[i],cur+=sz[k])if((cur&lt;&lt;1)&gt;=sum)&#123; lk=build2(l,i-1);rk=build2(i+1,r); fa[lk]=fa[rk]=k;pushup(k); return k; &#125; return 0;&#125;//建原树inline int build(int x,int t)&#123; for(int u=x;u;t=u,u=son[u])&#123; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t&amp;&amp;v^son[u])fa[build(v,u)]=u; init(u); &#125; cnt=0; for(int u=x;u;u=son[u]) st[++cnt]=u,sz[u]-=sz[son[u]]; return build2(1,cnt);&#125; 还有注意到这题卡常，大输入输出优化+循环展开+自定义max才过的… Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define FIO \"p4751\"using namespace std;const int N=1e6+5,INF=1e9;inline int maxx(int a,int b)&#123;return a&gt;b?a:b;&#125;int w[N],n,m,x,y,lst,dp[N][2],fa[N],sz[N],son[N],rt,ch[N][2];int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],ecnt,cnt,st[N];char buf[1&lt;&lt;20];int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read(T &amp;x)&#123;T f=1;x=0;char ch=getch;for(;!isdigit(ch)&amp;&amp;ch!='-';ch=getch);if(ch=='-')f=-1,ch=getch;for(;isdigit(ch);ch=getch)x=x*10+ch-'0';x*=f;&#125;char ss[30000010],tt[20];int ssl,ttl;inline int print(int x)&#123; if(!x) ss[++ssl]='0';for(ttl=0;x;x/=10) tt[++ttl]=char(x%10+'0'); for(;ttl;ttl--) ss[++ssl]=tt[ttl];return ss[++ssl]='\\n';&#125;inline void add(int u,int v)&#123;nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;&#125;inline void dfs1(int u,int t)&#123; sz[u]=1;dp[u][1]=w[u]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t)&#123; dfs1(v,u);sz[u]+=sz[v]; dp[u][0]+=maxx(dp[v][0],dp[v][1]); dp[u][1]+=dp[v][0]; if(!son[u]||sz[son[u]]&lt;sz[v])son[u]=v; &#125;&#125;inline void dfs2(int u,int t)&#123; if(!son[u])return; dp[u][0]-=maxx(dp[son[u]][0],dp[son[u]][1]); dp[u][1]-=dp[son[u]][0]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t) dfs2(v,u);&#125;struct matrix&#123; int v[2][2]; inline int* operator [](int x)&#123;return v[x];&#125; matrix()&#123;v[0][0]=v[0][1]=v[1][0]=v[1][1]=-INF;&#125; matrix operator *(matrix &amp;t)&#123; matrix ret; ret[0][0]=maxx(v[0][0]+t[0][0],v[0][1]+t[1][0]); ret[0][1]=maxx(v[0][0]+t[0][1],v[0][1]+t[1][1]); ret[1][0]=maxx(v[1][0]+t[0][0],v[1][1]+t[1][0]); ret[1][1]=maxx(v[1][0]+t[0][1],v[1][1]+t[1][1]); return ret; &#125; void out()&#123;printf(\"%d %d\\n%d %d\\n-----\\n\",v[0][0],v[0][1],v[1][0],v[1][1]);&#125;&#125;a[N],b[N];#define lk ch[k][0]#define rk ch[k][1]inline void init(int k)&#123; b[k][0][0]=b[k][0][1]=dp[k][0];b[k][1][0]=dp[k][1];&#125;inline void pushup(int k)&#123; a[k]=a[lk]*b[k]*a[rk];&#125;inline int build2(int l,int r)&#123; if(l&gt;r)return 0; int sum=0; for(int i=l;i&lt;=r;i++)sum+=sz[st[i]]; for(int i=l,k=st[i],cur=sz[k];i&lt;=r;i++,k=st[i],cur+=sz[k])if((cur&lt;&lt;1)&gt;=sum)&#123; lk=build2(l,i-1);rk=build2(i+1,r); fa[lk]=fa[rk]=k;pushup(k); return k; &#125; return 0;&#125;inline void modify(int u,int x)&#123; dp[u][1]+=x-w[u];w[u]=x; int pre[2],nxt[2]; for(;u;u=fa[u])&#123; pre[0]=maxx(a[u][0][0],a[u][0][1]); pre[1]=maxx(a[u][1][0],a[u][1][1]); init(u);pushup(u); nxt[0]=maxx(a[u][0][0],a[u][0][1]); nxt[1]=maxx(a[u][1][0],a[u][1][1]); if(u^ch[fa[u]][0]&amp;&amp;u^ch[fa[u]][1])&#123; dp[fa[u]][0]+=maxx(nxt[0],nxt[1])-maxx(pre[0],pre[1]); dp[fa[u]][1]+=nxt[0]-pre[0]; &#125; &#125;&#125;#undef lk#undef rkinline int build(int x,int t)&#123; for(int u=x;u;t=u,u=son[u])&#123; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t&amp;&amp;v^son[u])fa[build(v,u)]=u; init(u); &#125; cnt=0; for(int u=x;u;u=son[u]) st[++cnt]=u,sz[u]-=sz[son[u]]; return build2(1,cnt);&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); read(n);read(m); for(int i=1;i&lt;=n;i++)read(w[i]); for(int i=1;i&lt;n;i++)read(x),read(y),add(x,y),add(y,x); dfs1(1,0);dfs2(1,0); //左右儿子为空时的的判断 a[0][0][0]=a[0][1][1]=0;a[0][0][1]=a[0][1][0]=-INF; rt=build(1,0); while(m--)&#123; read(x);read(y); x^=lst; modify(x,y); print(lst=(maxx(maxx(a[rt][0][0],a[rt][0][1]),maxx(a[rt][1][0],a[rt][1][1])))); &#125; return fwrite(ss+1,sizeof(char),ssl,stdout),0;&#125; BZOJ4712 Description小A走到一个山脚下，准备给自己造一个小屋。这时候，小A的朋友（op，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小A面前出现了一个瀑布。作为平民的小A只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个$n$个节点的树，每个节点有权值（爬上去的代价）。小A要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小A的朋友觉得这样子太便宜小A了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小A觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。 Input输入文件第一行包含一个数$n$，表示树的大小。接下来一行包含$n$个数，表示第$i$个点的权值。接下来$n-1$行每行包含两个数$fr$，$to$。表示书中有一条边（$fr$，$to$）。接下来一行一个整数，表示操作的个数。接下来$m$行每行表示一个操作，若该行第一个数为$Q$，则表示询问操作，后面跟一个参数$x$，表示对应子树的根；若为$C$，则表示修改操作，后面接两个参数$x$，$to$，表示将点$x$的权值加上$to$。$n&lt;=200000$，保证任意$to$都为非负数 Output对于每次询问操作，输出对应的答案，答案之间用换行隔开。 Sample Input1234567891044 3 2 11 21 34 24Q 1Q 2C 4 10Q 1 Sample Output123314 Solution矩阵转移 \\begin{equation} g[u]=\\sum_{v是u的轻儿子}{f[v]}\\\\ \\left[ \\begin{matrix} f[u]\\\\ 0\\\\ \\end{matrix} \\right] =\\left[ \\begin{matrix} g[u]&w[u]\\\\ 0&0\\\\ \\end{matrix} \\right]\\times \\left[ \\begin{matrix} f[son[u]\\\\ 0\\\\ \\end{matrix} \\right] \\end{equation}注意qry时是id[u],id[top[u]+len[u]-1]不是id[top[u],id[top[u]+len[u]-1] 还有$g[u]$不能直接用$f[u]-f[son[u]]$，原因…很浅显了，可为什么第一次写的时候想不到呢（答：为了压行） 还有又双叒叕没开long long 以及这东西调起来真爽 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#define FIO \"4712\"#define ll long longusing namespace std;const int N=2e5+5;const ll INF=1e15;int w[N],n,x,y,head[N],to[N&lt;&lt;1],nxt[N&lt;&lt;1],ecnt;ll dp[N],g[N];int top[N],id[N],rnk[N],fa[N],dep[N],son[N],sz[N],len[N],cnt,q;char ch;inline void add(int u,int v)&#123;nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;&#125;inline void dfs1(int u)&#123; sz[u]++; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u])&#123; a[v]=u;dep[v]=dep[u]+1;dfs1(v);sz[u]+=sz[v];if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; &#125;&#125;//id[u]=i rnk[i]=uinline void dfs2(int u,int t)&#123; top[u]=t;len[t]++; id[u]=++cnt;rnk[cnt]=u; if(son[u])dfs2(son[u],t),dp[u]+=dp[son[u]]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) dfs2(v,v),g[u]+=dp[v]; if(!son[u])g[u]=INF,dp[u]=w[u]; else dp[u]=min(dp[u]+g[u],(ll)w[u]);&#125;struct matrix&#123; ll v[2][2]; matrix()&#123;v[0][0]=v[0][1]=v[1][0]=v[1][1]=INF;&#125; inline ll* operator [](int x)&#123; return v[x]; &#125; matrix operator *(matrix t)&#123; matrix ret; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ret[i][j]=min(ret[i][j],v[i][k]+t[k][j]); return ret; &#125; inline void out()&#123;printf(\"%lld %lld\\n%lld %lld\\n-----\\n\",v[0][0],v[0][1],v[1][0],v[1][1]);&#125;&#125;a[N&lt;&lt;2],val[N];#define mid ((l+r)&gt;&gt;1)#define lk (k&lt;&lt;1)#define rk (k&lt;&lt;1|1)inline void pushup(int k)&#123;a[k]=a[lk]*a[rk];&#125;inline void build(int k,int l,int r)&#123; if(l==r)&#123; a[k][0][0]=g[rnk[l]];a[k][0][1]=w[rnk[l]];a[k][1][0]=a[k][1][1]=0; val[l]=a[k]; return; &#125; build(lk,l,mid);build(rk,mid+1,r); pushup(k);&#125;inline matrix qry(int k,int l,int r,int ql,int qr)&#123; //if(k==1)printf(\"qrying%d-%d\\n\",ql,qr); if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr);&#125;inline matrix qry(int u)&#123; return qry(1,1,n,id[u],id[top[u]]+len[top[u]]-1); &#125;inline void modify(int k,int l,int r,int pos)&#123; if(l==r)&#123;a[k]=val[l];return;&#125; if(pos&lt;=mid)modify(lk,l,mid,pos); else modify(rk,mid+1,r,pos); pushup(k);&#125;inline void modify(int u,int x)&#123; w[u]+=x;val[id[u]][0][1]+=x; while(u)&#123; //printf(\"u=%d\\n\",u); matrix pre,nxt; pre=qry(top[u]); modify(1,1,n,id[u]); nxt=qry(top[u]); u=fa[top[u]]; //nxt.out();pre.out(); val[id[u]][0][0]+=nxt[0][1]-pre[0][1]; &#125;&#125;inline void output(int k,int l,int r)&#123; printf(\"%d-%d\\n\",l,r);a[k].out(); if(l==r)return; output(lk,l,mid);output(rk,mid+1,r);&#125;#undef mid#undef lk#undef rkint main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(1); dfs2(1,1); build(1,1,n); scanf(\"%d%*c\",&amp;q); //for(int i=1;i&lt;=n;i++)printf(\"val%d:\\n\",i),val[i].out(); output(1,1,n); while(q--)&#123; scanf(\"%c%d%*c\",&amp;ch,&amp;x); if(ch=='Q') &#123; matrix ans=qry(x); printf(\"%lld\\n\",min(ans[0][1],ans[0][0])); //ans.out(); &#125; else&#123; scanf(\"%d%*c\",&amp;y); modify(x,y); //for(int i=1;i&lt;=n;i++)printf(\"val%d:\\n\",i),val[i].out(); output(1,1,n); &#125; &#125; return 0;&#125; BZOJ5210 Description给出一棵$n$个点、以$1$为根的有根树，点有点权。要求支持如下两种操作：$M\\ x\\ y$：将点$x$的点权改为$y$；$Q\\ x$：求以$x$为根的子树的最大连通子块和。其中，一棵子树的最大连通子块和指的是：该子树所有子连通块的点权和中的最大值（本题中子连通块包括空连通块，点权和为$0$）。 Input第一行两个整数$n、m$，表示树的点数以及操作的数目。第二行$n$个整数，第$i$个整数$w_i$表示第$i$个点的点权。接下来的$n-1$行，每行两个整数$x、y$，表示$x$和$y$之间有一条边相连。接下来的$m$行，每行输入一个操作，含义如题目所述。保证操作为$M\\ x\\ y$或$Q\\ x$之一。$1≤n,m≤200000 $，任意时刻$ |w_i|≤10^9$ 。 Output对于每个$Q$操作输出一行一个整数，表示询问子树的最大连通子块和。 Sample Input123456789105 43 -2 0 3 -11 21 34 22 5Q 1M 4 1Q 1Q 2 Sample Output123431 Solution（并不是）一眼得出转移式子$f[u]=max(0,\\sum{f[v]}+w[u])$ 矩阵形式 g[u]=\\sum_{v是u的轻儿子}{f[v]}\\\\ \\left[ \\begin{matrix} f[u]\\\\0 \\end{matrix} \\right]= \\left[ \\begin{matrix} w[u]+g[u]&0\\\\ 0&0\\\\ \\end{matrix} \\right] \\times \\left[ \\begin{matrix} f[son[u]]\\\\0 \\end{matrix} \\right]然后有点无聊开始写全局平衡二叉树练(cao)习(bang)。打到快一半才发现每次只是询问子树可能不能这么搞怒删$100$行代码开始打线段树，然后发现可能要求的子块并不包含根，于是怀着这辈子不可能手打平衡树的想法就去搜了下题解发现直接可删堆就行了，而且矩阵也不是必要的，把一个点的虚儿子的贡献加在重链上这个点上后就相当于重链上查一个最大连续子段和，可以用线段树上的一般的搞法即记录每个点左边连续最大$lmax$，右边连续最大$rmax$，总共连续最大$max$以及总和$sum$。 转移即为 a[k].lmax=max(a[lk].lmax,a[lk].sum+a[rk].lmax)\\\\ a[k].rmax=max(a[rk].rmax,a[lk].rmax+a[rk].sum)\\\\ a[k].max=max(a[lk].max,a[rk].max,a[lk].rmax+a[rk].lmax)\\\\ a[k].sum=a[lk].sum+a[rk].sum\\\\可删堆的实现大家都懂就不赘讲了 注意$ch$数组开四倍因为是线段树上的点，由平衡树改成线段树的时候没改可能会调一会。 以及记得照着标程改完后能拍的起的时候记得测下样例，一会标程莫名其妙都改错了就直接$GG$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define FIO \"5210\"#define ll long long using namespace std;const int N=2e5+5,INF=1e9;int w[N],n,m,x,y,sz[N],fa[N],son[N],top[N];int h[N],to[N&lt;&lt;1],nxt[N&lt;&lt;1],ecnt,ch[N&lt;&lt;2][2],id[N],rnk[N],cnt,ptr,len[N],rt;ll f[N],g[N];inline void add(int u,int v)&#123;nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;&#125;struct heap&#123; priority_queue&lt;ll&gt;de,q; inline ll top()&#123; while(!de.empty()&amp;&amp;!q.empty()&amp;&amp;q.top()==de.top())q.pop(),de.pop(); return q.empty()?0:q.top(); &#125; inline void del(ll x)&#123;de.push(x);&#125; inline void insert(ll x)&#123;q.push(x);&#125;&#125;q[N];//可删堆inline void dfs1(int u)&#123; sz[u]=1;f[u]=w[u]; for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^fa[u])&#123; fa[v]=u; dfs1(v); if(sz[v]&gt;sz[son[u]])son[u]=v; f[u]+=f[v]; sz[u]+=sz[v]; &#125; f[u]=max(f[u],0ll);&#125;inline ll dfs2(int u,int t)&#123; ll ret=0; id[u]=++cnt;rnk[cnt]=u;top[u]=t;len[t]++; if(son[u])ret=dfs2(son[u],t); g[u]=w[u]; for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) g[u]+=f[v],q[u].insert(dfs2(v,v)); return max(ret,max(f[u],q[u].top()));&#125;struct node&#123; ll mx,lm,rm,sum; node(ll _mx=0,ll _lm=0,ll _rm=0,ll _sum=0)&#123;mx=_mx;lm=_lm;rm=_rm;sum=_sum;&#125; node operator *(node t)&#123; //合并两个node的操作，矩乘写惯了这题也用乘号 //建议对照上方构造函数 return node( max(rm+t.lm,max(mx,t.mx)), max(lm,sum+t.lm), max(t.rm,rm+t.sum), sum+t.sum); &#125;&#125;a[N&lt;&lt;2];#define lk ch[k][0]#define rk ch[k][1]#define mid ((l+r)&gt;&gt;1)inline void pushup(int k)&#123; a[k]=a[lk]*a[rk]; &#125;inline node qry(int k,int l,int r,int ql,int qr)&#123; //fprintf(stderr,\"qrying%d-%d %d-%d\\n\",l,r,ql,qr); if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr);&#125;inline node qry(int x)&#123;return qry(rt,1,n,id[x],id[top[x]]+len[top[x]]-1);&#125;inline void init(int k,int u)&#123; a[k].sum=g[u]; a[k].lm=a[k].rm=max(0ll,g[u]); a[k].mx=max(a[k].lm,q[u].top());&#125;inline void build(int &amp;k,int l,int r)&#123; k=++ptr; if(l==r)&#123; init(k,rnk[l]); return; &#125; build(lk,l,mid);build(rk,mid+1,r); pushup(k);&#125;inline void modify(int k,int l,int r,int pos)&#123; if(l==r)&#123; init(k,rnk[l]); // if(l==2)printf(\"%d %d\\n\",a[k].lm,q[rnk[l]].top()); //printf(\"%d-%d\\n%lld %lld\\n%lld %lld\\n-----\\n\",l,r,a[k].lm,a[k].rm,a[k].sum,a[k].mx); return; &#125; if(pos&lt;=mid)modify(lk,l,mid,pos);else modify(rk,mid+1,r,pos); pushup(k);&#125;inline void modify(int u,ll del)&#123; node pre,nxt; bool flag; while(u)&#123; pre=qry(top[u]); g[u]+=del; //printf(\"gu=%lld\\n\",g[u]); modify(rt,1,n,id[u]); nxt=qry(top[u]); del=nxt.lm-f[top[u]];f[top[u]]=nxt.lm; //nxt.lm相当于新的这条重链上0或者包含top[u]的这个连通块（一条链）的最值 u=fa[top[u]]; if(u)q[u].del(pre.mx),q[u].insert(nxt.mx); //top[u]是fa[top[u]]的虚儿子，所以需要在对应的堆里进行更改 &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(1);dfs2(1,1); build(rt,1,n); while(m--)&#123; char ch=getchar(); while(ch!='M'&amp;&amp;ch!='Q')ch=getchar(); scanf(\"%d\",&amp;x); if(ch=='M')scanf(\"%d\",&amp;y),modify(x,y-w[x]),w[x]=y; else printf(\"%lld\\n\",qry(x).mx); &#125; return 0;&#125; 总结动态DP真是个不错的东西，它与题目半身的关联性不大，所以适用范围还是比较广的，啥时候想练练码力了可以来做一做，而且调试起来还非常方(e)便(du)。相信当你在一个寒冷的深冬的夜晚抬起头来，手指早已冻僵却仍不住的按着F5，屏幕终于从一直的时而泛紫又时候泛红到泛起一道绿光改了无数遍丑的看不下去的代码终于过了的时候,你一定会由衷的对该题的出题人表示 : ********！","categories":[{"name":"总结","slug":"总结","permalink":"https://buzhibujue.cf/categories/总结/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://buzhibujue.cf/tags/DP/"},{"name":"动态DP","slug":"动态DP","permalink":"https://buzhibujue.cf/tags/动态DP/"}]},{"title":"NOIP2018杂记","slug":"NOIP2018杂记","date":"2018-11-14T14:55:08.000Z","updated":"2020-05-03T15:38:36.000Z","comments":true,"path":"2018/11/14/NOIP2018杂记/","link":"","permalink":"https://buzhibujue.cf/2018/11/14/NOIP2018杂记/","excerpt":"","text":"DAY 0考前默默打了下配置文件练手，记不到怎么调用系统复制粘贴啥的啥啥啥的，准备用自带的辣鸡寄存器复制粘贴就学习了一下命令123ggVG //全选&quot;+y //复制到系统寄存器&quot;+p //粘贴到系统寄存器 然后有次模拟赛就复制输入的时候出锅调试半天结果GG。。。一整天就写了几道代码量短的题，本来想打道树套树板子怕调不出来影响信心并且NOIP不考就弃了。或者是所谓的“超量恢复”？不是很懂，反正当年体考前几天也没有再跑长跑了，或许有用？ 问题就是下午到家的时候开始肚子痛，喝了点热水没啥用，当时心里还是有点慌的毕竟最后一天了不能这种时候掉链子，然后默默坐地铁，人又多又挤没座位，到站的时候各种不爽感觉凉凉，然后走到一个垃圾桶旁就吐了然后感觉好多了=.=。然后还是不能大意到酒店喝了点啥药然后好得差不多了，出去考前最后集合了一下然后回来看了下很久没看的前面内容都挺傻吊的一本通提高版 的tarjan求强连通分量然后洗洗睡了，居然没有失眠。 DAY 1早上起来吃两个小包子不敢吃多了害怕肚子不舒服，然后一行人走去考场，一堆人开始毒奶（所以DAY1如此傻吊）一堆神仙玩意，到场没多久就进去了 进场发现过道有矿泉水和面包当时想的是会发结果并没有，然后就走到考场坐下，发现我们学校的一个高二神犇在前面问了老师哪个盘不会被清空，我都忘了这回事去问了下然后彼此点了下头就坐下了，并不让碰键盘然后就呆坐，想过上厕所但觉得不必要反而会会徒增紧张感就并没有去，然后发网络地址，开始码配置文件，发现自带mswin真好，码完配置文件编译不起发现是没加&lt;ESC&gt;还行，然后还是打了个快读板子，一遍打对没有出错涨了点自信，头文件不用bits就只用三个cstdio iostream algorithm 然后发密码飞雪连天可能是纪念金庸先生的，接下来打开第一题第一眼单调栈矩形覆盖第二眼发现傻逼原题，10分钟切了一遍过大样例稳稳，然后随便写了个$n$玄学的暴力过了大样例开始拍。 第二题第一眼同余最短路，第二眼神仙题不可做，瞎搞搞发现有点像个背包，发现从小到大第一个不能表示的就必定在最小的系统中，比最小的数小的一定不合法，比最大的数大的一定不优想到这都没发现必定在原来的几个数中也是菜死了然后搞到九点半一遍过样例$2000\\times 2000$，最后半小时才发现所有部分分要开到5000 x 5000还打了一个$n=2$的特判直接输出$2$也是后来才发现一个是另一个的倍数的时候可能有锅，还要特判（都到这里了怎么还没想到正解啊喂） 慌慌张张搞到九点半没有更优做法果断选择80分瞎打了一个$2000\\times 2000$的乱搞一遍过了大样例后想用$bitset$优化发现有锅还是要右移$2000/a[i]$次复杂度$2000\\times 2000\\times 2000/a[i]/32$还不如直接$2000\\times 2000$不过反正是用来对拍的就写完开始拍，后来发现应该是$5000\\times 5000$(考完还担心了一下然后再冷静分析一下复杂度不是值域平方而是是调和级数，主要当时不知道最大开到多少才能保证正确性怕WA，现在一想只用开到最大的$a[i]$可能还是可以过的。（update:刚刚洛谷跑了一下多过了一个点85其他的TLE…）不过这是后话了)还是随便跑。 然后看T3，之前T2做不动的时候看了几眼可能就像语文考试先看作文一样，没有想但后台有了个大致的思路，然后一眼二分答案，再把题意理清了感觉就是个傻逼贪心，码码码，小样例随便过大样例居然WA，简直震惊，仔细分析算法正确性可能没啥锅，应该是打挂了，于是把一开始正确的从小到大贪心改成从大到小贪心（想的是反正改起来不难怎么样过了大样例就是对的，没有手推正确性，以后要注意避免）然后当然还是WA，而且答案一样，当时就震惊了，没啥办法，想到没测会不会CE，开了个虚拟机测了下T1,T2没CE还行（不会虚拟机D2T1就凉凉了后面会说），然后可能还剩一个多小时，T2当时心里想要么是个非常高级的算法几乎不可能当场推出来（主要$n=100$的数据范围非常奇怪呀）或者是个非常傻吊的东西没想到，而且这种第一眼没想到后面就难以再想到了估计再去看也是浪费时间，于是全力调T3，刚刚刚，码码码…… 一看时间我去只剩20分钟了这毒瘤题怎么还没调出来，现在代码已经是千疮百孔了各种debug,cout以及特判特别毒瘤，心里开始慌张，冷静一下（就用冻手使劲搓自己脸几下）开始用纸笔推（发现这样可能才是最好的方法）发现应该从小到大贪心啊啊啊啊啊，然后改改改。 小样例都不对，还剩$15$分钟，手心在冒汗，不自觉想这题爆零的话今天预估分数，然后锤自己一下强行停止。 想找之前能过小样例的错误做法来凑数，改.ans为.out放到D:/noip完成，还剩$14$分钟。 发现mfind边界不对改之，能感受到手上由寒冷导致的僵硬，还剩$13$分钟。 愣了一会通过cout发现有的up[u]没被更新导致答案偏小（现在一直测的是小样例），还剩$12$分钟。 改改改，改好了测试，第一个点$15$，第二个点$31$,那么第三个大样例也不能放松之前的反向错误做法也能过前两个样例，那么答案是…鼠标滚轮快速的划过上方的调试信息，后突然醒悟用G快捷键，翻到底是$26762$吗（因为没有过过大样例不记得答案是啥了），手在发抖，还剩$11$分钟。 因为手太紧张，点几次都没有点到，当时想的是这就最后一次了，没过就没过去检查文件了也没时间耗了，可能是完完全全算法错了吧。点开，$26762$。恩，还剩$10$分钟，我过大样例了。 然后以可能是这天来手速的极限删掉了所有调试信息，一个个过了样例然后才像耗尽了全身力气一样的摊在了后一个人的桌前，（椅子没有靠背特别不爽，还有要吐槽的硬件就是backspace居然只占一格大小,回车占两行，斜杠(或者叫反斜杠反正就是\\n的这个)跑到退格键的左边去，导致换行的时候每次都按错特别影响速度） 然后检查应该没有啥问题，也没时间开虚拟机了（毒瘤电脑虚拟机开半天第二天还几乎接近崩溃了见下文）（没检查memset与memcpy第二天刺激CE导致考后有点慌，也是经常有类似的什么感觉文件名打错了了啊什么直接CE了啊这种心理确实不是很好以后要注意） 然后时间到，起立，关闭两个对拍，关闭vim走出去，看到高二神犇一句话“每个数可被删去当且仅当可被另外的数表示”，感觉自己菜爆了啊。出楼，一问感觉全世界就我不会T2，太菜了哎。然后去吃饭，一行人开始讨论今天的原题，结果神仙jmr发现O好像之前出过T2加强版（顺带一提O，佬，司都提前阿克立场了太强啦orz）就在校内OJ上果然我还是太菜了，然后UOJ群又有人在说T3原题，看了下还是有区别一个要求全覆盖一个不用，除了二分以外做法还是很不同的。然后下午到酒店闲得无聊看西酱退役记（文笔太好了）感慨一下自己这条路还是很险的，然后迷迷糊糊中某阿克DAY1的神犇找我打乒乓然而当时想睡觉把拍给他就咕咕了。然后去吃晚饭，路上一直在想T2复杂度是多少感觉会遭卡成$50$啊，整个人都不好了，更加确信了DAY1三道傻逼题以及就我不会T2这件事，菜没啥肉差评。在酒店大厅的时候遇到蔺老还是说了一些稳住心态啊可以看一下高二的心态跟我们不一样什么的，然后就上去了，洛谷民间数据已出，5min手打T2居然$80$分并且都只用过不到$100$ms，推了一下复杂度$nlogn$的不禁感叹为啥不开大点不过当时也不知道这回事，怕T就没开那么大，还是做了一个非常明智的选择。过了一会蔺老到来“查房”（幸好没颓咕咕）说了一下今天的情况，以及下午看起来比较丧不是肚子痛而是担心T2的缘故，估分$280$，说了一下明天题可能会难一点不要死磕一道啥啥啥的。然后睡前又看了一会tarjan，喝了药就睡觉了，不过今天睡的不是很好一直担心T3有没有关memset啥的会不会CE，以及只测了大样例会不会WA，非常纠结（以后还是要尽量避免这种）在迷迷糊糊中睡着了。 DAY 2跑到酒店的餐厅吃早餐然后只有一两个小房间并不是想象的那种，吃了半个烤面包有点不舒服就没吃了，然后走到考场路上一群人怎么开始讨论普及组题啊是都阿克提高了没事干吗 然后进考场，这次拿了零食感觉很好。开始看T1感觉树的形态非常可做，基环树的形态手推贪心结果都被第二个小样例卡了，没法，一看数据范围$n=5000$，这数据范围加上i7的新机感觉是要$n^2$的节奏，枚举一下环上每个边断开然后就行了，问题是直接调用的树上的函数导致每次都会sort一遍非常不好（听说$sort$有序数列是$O(n)$?可能可过？(update: 民间数据都没过=.=)）当时偷懒了没重新打一个，哎。一遍过了大样例再写了个每个边断一次开始拍就做T2去了，这题可能做了将近一个小时。 T2最开始看题的时候哎$N$那么大$M$那么小不是太明显的状压DP吗都连续出了好几年了哎…… 然后开始推式子，恩就是右下小于等于左上嘛式子一些，手算一下应该$2\\times 2$是对的，$3\\times 3$咋是$144$???不管，先打了再说，然后确实$2\\times 2$是对的并且$3\\times 3$是错的更不用说$5\\times 5$了，冷静分析，可能思路错了，改为一个斜线一个斜线的考虑，只能是连续的$1$然后全是$0$嗯嗯……手算一下样例还是过不了$3\\times 3$，没办法，时间可能已经花太多，想到昨天说的不要刚太久，估计这题不简单，选择再打了个$2^{n\\times m}$暴力，测了下发现所有$2\\times n$时状压都是对的，然后就分了两个subtask骗50（咋不打表找找$n=3$的情况呢其实也是时间花太多也担心找不到规律太浪费时间了） 然后数据生成$2\\times n$的验证状压正确性开始拍，拍到一半卡起动不了点击关闭也关不了，任务管理器也不行，叫老师来捣鼓一会任务管理器后也无果，说不影响收题，愿意的话可以重启（这辈子不可能的）于是就缩小到最小放在边边上免得难看zz) 打开T3一看不带修改是个非常套路的树形DP，简单的码完$44$分就只剩40多分钟了，剩下的分一看不可做也不硬钢了，也没啥事用虚拟机（打开虚拟机的时候卡机了一分钟，吓得赶紧像老师示意，结果老师看了几秒就自己好了搞得非常尴尬，不过好了是万幸）测了一下发现T1居然CE！！！论memcpy不加cstring的后果（以后不用bits的时候记得写四个头文件了）还是比较惊心动魄的，不过时间比较充裕，改完后继续对拍。 可能检查了几分钟的文件后猛的发现datamaker没有srand!!!这可真刺激，不过还是拍起了，问题不大=.=。 还有十多分钟的时候反应过来深度&lt;=100的点可以从下往上更新两条链的答案复杂度很对，不过写起来太麻烦而且怕调不出来就弃了。稳稳当当检查了十多遍文件名（昨天就几分钟检查，还在担心文件名有没有打挂）（第二天不担心文件名了，却担心没有看cena用户名会不会有锅，果然是操不完的心==）（DAY2确实没有DAY1那么惊心动魄主要后面的都不会了O.O，有大把时间检查） 然后出来一问T1果然懒的写sort复杂度多了个log有锅，其他的分都差不多，基本高一都是$100+50+44$(就我不会T1系列)然后在门口照相，吐槽了一下两天题目难度差异如此巨大，T2据说分类讨论繁杂到佬都没写完？T3据说叫做动态DP？？？不管了反正没啥大的失误就还好，之后一行人去吃了个自助餐，感觉大家都稳省一了呀还是非常强的，然后就回家颓了。 后记今天来看的话确实没有挂题非常优秀，然后就是小的细节上比最高预估的分少了一点，考场上的考试策略还是很对的，就是考后的心态要注意调整（考前还有点担心肚子会不会疼，果然身体是革命的本钱，平时注意锻炼这种事情才不会发生）总之这次NOIP算是超额完成省一的目标了（目标就这么低吗某神仙400+还嫌少呢=.=）至于冬令营啥的也是能去就去不能去算了，去了多半也是被吊打，总之对这个结果还是很满意了。 不管怎样高一的联赛已经落下帷幕，在接下来的日子里还需继续努力！！！😝😝😝","categories":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/tags/随笔/"}]},{"title":"洛谷4921","slug":"洛谷4921","date":"2018-11-02T15:19:08.000Z","updated":"2020-05-03T15:36:08.000Z","comments":true,"path":"2018/11/02/洛谷4921/","link":"","permalink":"https://buzhibujue.cf/2018/11/02/洛谷4921/","excerpt":"","text":"洛谷4921 Description有$n$ 对情侣来到电影院观看电影。在电影院，恰好留有$ n$ 排座位，每排包含 $2$ 个座位，共 $2×n $个座位。现在，每个人将会随机坐在某一个位置上，且恰好将这 $2×n $个座位坐满。如果一对情侣坐在了同一排的座位上，那么我们称这对情侣是和睦的。你的任务是求出当 $k = 0, 1, … , n$ 时，共有多少种不同的就坐方案满足恰好有 k 对情侣是和睦的。两种就坐方案不同当且仅当存在一个人在两种方案中坐在了不同的位置。不难发现，一共会有 $(2n)!$ 种不同的就坐方案。 Input输入包含多组数据。输入的第一行包含一个正整数 $T(1 \\leq T \\leq 1000)$，表示数据的组数。接下来$ T$ 行，每行包含一个正整数 $n(1 \\leq n \\leq 1000)$。 Output对于每组输入数据，输出共 $n + 1$ 行，每行包含 $1$ 个整数，分别表示$ k = 0, 1, …, n$ 时满足恰好有 $k$ 对情侣是和睦的就坐方案数。由于结果可能较大，因此输出对 $998244353$取模的结果。 Sample Input123212 Sample Output12345021608 Hint本题只有一个$T=1000$ 的数据点。。。暴力还是算了吧！ Solution看到第一眼我会$ (2n)!$ 然而没分（毒瘤） 并没有怎么做过错排于是就直接看题解了 记$ans_k$为我们要求的恰$k$对情侣和睦的方案数 首先我们从$n$对CP中选这$k$对CP有$C_n^k$种方案数，给这$k$对CP找$k$排座位有$C_n^k$种方案，每一对人对应每一排座位共有$k!$种对应方法，这$k$对CP每一对的两个人在同一排有两种坐法(男左女右or男右女左) 在这$k$对CP就共$2^k$种 然后呢？考虑剩下的被拆散的$n-k$对CP怎么搞，而且这$n-k$对CP的坐法好像和$N$无关，Emmm…有点错排的味道了 记$f(x)​$表示$x​$对CP坐$x​$排座位并且都被拆散的方案数 所以可以得到 ans_k={C_n^k}^2*2^k*k!*f(n-k)类似错排考虑最后一个放哪里的方法，我们考虑最后一排的两个人的情况现在这两个人有三种情况 两男 这两个人有$x\\times(x-1)$种选法，考虑他们的两个配偶 钦定这两个女生不坐一起，所以把她俩看作一对CP防止配对(橘里橘气) 方案数为$f(x-1)$ 钦定这两个女生坐一起，共有$x-1$排位置可坐，两人可以交换位置，剩下$x-2$对CP还是要被拆散，即方案数为$(x-1)\\times 2\\times f(x-2)$ 两女 同两男即可 一男一女（并不是CP）还是一样的考虑他们的两个配偶，转移类似，不过注意的是这一男一女的选择方案数是$x\\times (x-1)\\times2$ 而不是$x\\times(x-1)$ (男A女B和男B女A两种) 所以得到递推式 f(x)=2*x*(x-1)*(f(x-1)+(x-1)*2*f(x-2)))\\\\ +x*(x-1)*2*(f(x-1)+(x-1)*2*f(x-2))\\\\ =4*x*(x-1)*(f(x-1)+(x-1)*2*f(x-2))边界$f(0)=1$然后就成水题了 Code1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define FIO \"P4921\"#define INF 0x3f3f3f#define DBUG(...) fprintf(stderr,__VA_ARGS__)typedef long long ll;const int MOD=998244353,MAXN=1e3;using namespace std;char buf[1&lt;&lt;20];int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read(T &amp;x)&#123;T f=1;x=0;char ch=getchar();for(;!isdigit(ch)&amp;&amp;ch!='-';ch=getchar());if(ch=='-')f=-1,ch=getchar();for(;isdigit(ch);ch=getchar())x=x*10+ch-'0';x*=f;&#125;int N,T,f[MAXN+5],inv[MAXN+5],fac[MAXN+5],bin[MAXN+5];inline int mul(int a,int b)&#123;return (ll)a*b%MOD;&#125;inline int add(int a,int b)&#123;a+=b;if(a&gt;=MOD)a-=MOD;return a;&#125;inline int CC(int a,int b)&#123; int t=mul(fac[a],mul(inv[b],inv[a-b])); return mul(t,t);&#125;int main()&#123; freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); fac[0]=inv[0]=fac[1]=inv[1]=bin[0]=1;bin[1]=2; for (int i=2;i&lt;=MAXN;i++) fac[i]=mul(fac[i-1],i),inv[i]=mul(MOD/i,add(MOD,-inv[MOD%i])),bin[i]=add(bin[i-1],bin[i-1]); for (int i=2;i&lt;=MAXN;i++) inv[i]=mul(inv[i],inv[i-1]); f[0]=1; for (int i=1;i&lt;=MAXN;i++) f[i]=mul(mul(i&lt;&lt;1,2*i-2),add(f[i-1],mul(2*i-2,f[i-2]))); read(T); while (T--)&#123; read(N); for (int i=0;i&lt;=N;i++) printf(\"%d\\n\",mul(mul(mul(CC(N,i),bin[i]),fac[i]),f[N-i])); &#125; return 0;&#125;","categories":[{"name":"洛谷","slug":"洛谷","permalink":"https://buzhibujue.cf/categories/洛谷/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://buzhibujue.cf/tags/计数/"},{"name":"错排","slug":"错排","permalink":"https://buzhibujue.cf/tags/错排/"}]},{"title":"BZOJ4735","slug":"BZOJ4735","date":"2018-11-02T08:50:15.000Z","updated":"2020-05-03T15:33:42.000Z","comments":true,"path":"2018/11/02/BZOJ4735/","link":"","permalink":"https://buzhibujue.cf/2018/11/02/BZOJ4735/","excerpt":"","text":"BZOJ4735 Description众所周知，萌萌哒六花不擅长数学，所以勇太给了她一些数学问题做练习。但是今天六花酱不想做数学题，于是他们开始打牌。现在他们手上有 $m$ 张不同的牌，牌有两种：普通牌和功能牌。功能牌一共有 $n$ 张，每张功能牌都有一个属性值 $w_i$，保证 $\\sum{w_i}=m,1&lt;=i&lt;=N$ 现在勇太将这 $m$ 张牌随机打乱（一共有 $m!$ 种不同的顺序）。一开始，六花先从牌堆顶端取一张牌。接着每回合六花可以选择手中的一张牌打出，如果这张牌是普通牌，那么什么都不会发生；如果这种牌是功能牌，那么六花需要从牌堆顶端再取 $w_i$ 张牌。重复这个过程直到六花手中没有手牌或六花要摸牌的时候牌堆已经空了，如果是前者，则勇太胜利，否则六花胜利。举例来说，如果牌堆是 {3，0，2，0，0）（用 0 表示普通牌，其他数字表示 $w_i$），那么六花打牌的过程可以为：1) 取一张牌，手中的牌为 {3}。2) 打出 {3}，再取三张牌，手中的牌为 {0，2，0}。3) 打出这三张牌，还需要再取两张，取到第二张的时候牌堆中已没有牌，六花胜利。而如果牌堆是 {2，0，0，3,0}，不难发现是勇太大胜利。现在，六花想要知道，这 M! 种顺序中，有多少种是能让自己取得胜利的呢。当然这个问题对萌萌哒六花来说实在是太雉了，所以她来向你寻求帮助，你能帮帮她吗。 Input第一行一个整数$ n$。第二行$n$他个空格隔开的正整数 $w_i$。通过输入你可以自己算出来 $m=\\sum{w_i},1&lt;=i&lt;=n$$n≤40，1&lt;wi≤10^5$ Output输出一个整数表示答案，答案可能很大，你只需要输出对 998244353 取模后的结果。 Sample Input1213 Sample Output12 Hintm! 种牌堆中，{3，0，0），{0，3，0）{0，0，3）各有两个，其中只有第一种满足条件。 Solution神仙JMR推荐的神仙题，考场上遇到直接$m!$暴力走人… 再想到从顶端取牌相当于每次还可以摸的牌数$-1$，遇到一个特殊牌即可以多摸那么多张牌，记录下这个“还可以摸的牌数”就会发现，这$m$个数（每张牌对应一个数，下同）的排列中，把每个数都$-1$好像是要求所有前缀和都大于等于$0$。 好像卡特兰数但一仔细看是正数和$-1$不是$1$和$-1$。所以GG 正解的话观察样例每个数都减一后形成的数列$\\{2,-1,-1\\}$它的总和为零($\\sum{w_i}=m$废话)于是可以在最后补一个$-1$即求除最后一项以外其他前缀和都大于$0$的方案数，对这$m+1$个数环排列(共$m!$种方案)每种环排列钦定这个多出来的$-1$放最后所以每种排列只有唯一对应的方案。 会发现有些方案重复计算了，具体是哪些呢，比如$\\{2,-1,-1,-1\\}$在第$1,2,3$个$-1$处都被算了一遍所以方案要除以$-1$的个数即普通牌数加钦点的那张牌，也即是牌总数-功能牌数+钦点的的那张牌所以答案表达式 ans=\\frac{m!}{m-n+1}十分简短沙雕 Code12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define FIO \"4735\"#define INF 0x3f3f3ftypedef long long ll;const int MOD=998244353;using namespace std;char buf[1&lt;&lt;20]; int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read (T &amp;x) &#123; T f=1; x=0; char ch=getch; for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getch); if (ch=='-')f=-1,ch=getch; for (; isdigit (ch); ch=getch)x=x*10+ch-'0'; x*=f;&#125;int N,M,ans=1,x;int main() &#123; read (N); for (int i=1; i&lt;=N; i++)read (x),M+=x; for (int i=1; i&lt;=M; i++)if (i^M-N+1)ans= (ll)ans*i%MOD; printf (\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://buzhibujue.cf/categories/BZOJ/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://buzhibujue.cf/tags/思维/"},{"name":"数学","slug":"数学","permalink":"https://buzhibujue.cf/tags/数学/"}]},{"title":"LOJ4","slug":"loj4","date":"2018-10-24T14:49:48.000Z","updated":"2020-05-03T15:35:20.000Z","comments":true,"path":"2018/10/24/loj4/","link":"","permalink":"https://buzhibujue.cf/2018/10/24/loj4/","excerpt":"","text":"LOJ4 Description写一个程序，使其能输出自己的源代码。代码中必须至少包含十个可见字符。 Input无 Output你的源代码 Solution不是很懂为什么天天做水题=.=复习一下常见字符$Ascii$表值(然而背不到，可能有用的就是快读中$ch-‘0’$以后可以直接用$ch\\%16$（即$ch\\&amp;15$) \\begin{align} ' \\n'&\\Leftrightarrow10 \\\\ '\\ \" \\ '&\\Leftrightarrow34\\\\ '\\ '\\ '&\\Leftrightarrow96\\\\ '0'-'9'&\\Leftrightarrow48-57\\\\ 'A'-'Z'&\\Leftrightarrow65-90\\\\ 'a'-'z'&\\Leftrightarrow97-122 \\end{align}Code简单$C++$123#include&lt;bits/stdc++.h&gt;const char *str=\"#include&lt;bits/stdc++.h&gt;%cconst char *str=%c%s%c;%cint main()&#123;printf(str,10,34,str,34,10);&#125;\";int main()&#123;printf(str,10,34,str,34,10);&#125; 以及一份来自神仙网友的更神仙的$python$代码(。・∀・)ノ1print(open(__file__).read())","categories":[{"name":"LOJ","slug":"LOJ","permalink":"https://buzhibujue.cf/categories/LOJ/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://buzhibujue.cf/tags/水题/"}]},{"title":"BZOJ4289","slug":"BZOJ4289","date":"2018-10-23T07:17:24.000Z","updated":"2020-05-03T15:33:36.000Z","comments":true,"path":"2018/10/23/BZOJ4289/","link":"","permalink":"https://buzhibujue.cf/2018/10/23/BZOJ4289/","excerpt":"","text":"BZOJ4289 Description给出一个$N$个点$M$条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点$1$到终点$N$的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权。$N&lt;=100000\\quad M&lt;=200000$ Input第一行两个整数$N,M$表示共$N$个点$M$条边。接下来的第$2$到$ M+1$行，一行三个整数$u,v,w$表示有一条从$u$到$v$边权为$w$的边。 Output一行一个整数表示从$1$号点到$N$号点的最小代价 Sample Input1234564 51 2 51 3 22 3 12 4 43 4 8 Sample Output112 Solution朴素的$M^2$级别的建图跑最短路肯定事跑不过这道题的，考虑优化边数，发现对于点$u$出发的一条边 $i$，它到所有点$u$出发的边的边权都是它自己的边权$w[i]$ ,而到所有$u$出发比它大的$j$的边权都是$w[j]=(w[j]-w[i])+w[i]$所以可以利用类似网络流中的补流的方法，先把$u$出发的每个边按边权排序，每条边$E[j](E[j]是边的序号，下同）$和它对应的反向边E[j]^1连一条边权为它本身边权$w[E[j]]$的边，然后对于第$j$大的边$E[j]$只用向$E[j-1]$连边权为$0$的边，向$E[j+1]$连边权为$w[E[j+1]]-w[E[j]]$的边，而起点$1$出发的边和到达终点$N$的边也是分别连$S到E[j]$和$E[j]到T$就是了图建完了就最短路随便瞎搞注意本题要开$long\\ long$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define FIO \"4289\"#define INF 0x3f3f3f#define xx first#define yy second#define pli pair&lt;ll,int&gt;typedef long long ll;const int MOD=1e9+7,MAXN=1e5+5,MAXM=2e5+5;using namespace std;char buf[1&lt;&lt;20]; int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read (T &amp;x) &#123; T f=1; x=0; char ch=getchar(); for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getchar()); if (ch=='-')f=-1,ch=getchar(); for (; isdigit (ch); ch=getchar())x=x*10+ch-'0'; x*=f;&#125;int n,m,u,v,w,S,T;namespace graph &#123;int head[MAXM&lt;&lt;1],nxt[MAXM*6],to[MAXM*6],va[MAXM*6],ecnt;ll dis[MAXM&lt;&lt;1];inline void add (int u,int v,int w) &#123; nxt[++ecnt]=head[u]; head[u]=ecnt; to[ecnt]=v; va[ecnt]=w;&#125;inline void dijkstra() &#123; memset (dis,INF,sizeof dis); static priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt; &gt; q; q.push (pli (0ll,S)); while (!q.empty()) &#123; pli u=q.top(); q.pop(); if (dis[u.yy]&lt;u.xx) continue; for (int i=head[u.yy]; i; i=nxt[i]) if (u.xx+va[i]&lt;dis[to[i]]) dis[to[i]]=u.xx+va[i],q.push (pli (dis[to[i]],to[i])); &#125; printf (\"%lld\\n\",dis[T]);&#125;&#125;;namespace ori &#123;int head[MAXN],to[MAXM&lt;&lt;1],nxt[MAXM&lt;&lt;1],va[MAXM&lt;&lt;1],ecnt=1;inline bool cmp (const int &amp;x,const int &amp;y) &#123; return va[x]&lt;va[y];&#125;inline void add (int u,int v,int w) &#123; nxt[++ecnt]=head[u]; head[u]=ecnt; to[ecnt]=v; va[ecnt]=w;&#125;inline void build() &#123; S=1; T=ecnt+1; static int a[MAXM],t=0; for (int i=1; i&lt;=n; i++) &#123; t=0; for (int j=head[i]; j; j=nxt[j]) a[++t]=j; sort (a+1,a+t+1,cmp); for (int j=1; j&lt;=t; j++) &#123; if (i==1) graph::add (S,a[j],va[a[j]]); if (to[a[j]]==n) graph::add (a[j],T,va[a[j]]); if (j^1) graph::add (a[j],a[j-1],0); if (j^t) graph::add (a[j],a[j+1],va[a[j+1]]-va[a[j]]); graph::add (a[j]^1,a[j],va[a[j]]); &#125; &#125;&#125;&#125;;int main() &#123; freopen (FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); read (n); read (m); for (int i=1; i&lt;=m; i++) read (u),read (v),read (w),ori::add (u,v,w),ori::add (v,u,w); ori::build(); graph::dijkstra(); return 0;&#125;","categories":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://buzhibujue.cf/categories/BZOJ/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://buzhibujue.cf/tags/思维/"},{"name":"图论","slug":"图论","permalink":"https://buzhibujue.cf/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"https://buzhibujue.cf/tags/最短路/"}]},{"title":"BZOJ2144","slug":"BZOJ2144","date":"2018-10-17T10:48:24.000Z","updated":"2020-05-03T15:33:32.000Z","comments":true,"path":"2018/10/17/BZOJ2144/","link":"","permalink":"https://buzhibujue.cf/2018/10/17/BZOJ2144/","excerpt":"","text":"BZOJ2144 Description跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。我们用跳跳棋&gt;来做一个简单的游戏：棋盘上有3颗棋子，分别在a，b，c这三个位置。我们要通过最少的跳动把他们的位置移动成x，y，z。（棋子是没有区别的）跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过1颗棋子。写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。 Input第一行包含三个整数，表示当前棋子的位置a b c。（互不相同）第二行包含三个整数，表示目标位置x y z。（互不相同） (输入数据均在$10^9$内) Output如果无解，输出一行NO。如果可以到达，第一行输出YES，第二行输出最少步数。 Sample Input121 2 30 3 5 Sample Output12YES2 Solution对于一个三元组作为状态$a,b,c$考虑能够转移到的所有状态再来判和$x,y,z$是否相同的暴搜肯定是过不了这题的。然后尝试找找规律，如果一个状态$(a,b,c)$中$(a&lt;b&lt;c下同)$ b-a=c-b则只能转移到 (2*a-b,a,c)\\\\ (a,c,2*c-b)\\\\两种状态，而如果不等的话只能选一边跳(因为只允许跳过一个棋子)，$(不妨令a-b&gt;c-b)$共有三个转移 (2*a-b,a,c)\\\\ (a,c,2*c-b)\\\\ (a,2*b-c,b)\\\\冷静分析，什么东西是特殊点两个”转移“普通点三个”转移“？二叉树！（这题来说树就够了）这一步想通了之后的就简单了相当于每个状态都是树上的节点，可能转移到与之相邻的节点，特殊点就是两个转移的的点即为根，1问相当于问是否同属一个树，2问相当于求两点之间距离，用求LCA的方法即可。还有一个问题就是可能两个点之间距离太小如数据$(0,1,99999999)$可能要很久才会到达一个根，考虑每次转移的两个距离$(x,y)$到$(x,y-x)$直到$x=y$发现相当于每次减了若干小的那个数，可以算出能够减多少次和当前往上跳的次数取min来直接减去以加速这个过程，代码如下： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define FIO \"2144\"#define DBUG(...) fprintf(stderr,__VA_ARGS__)typedef long long ll;const int MOD=1e9+7;const int INF=1e9;const int N=4;using namespace std;template &lt;class T&gt;inline void read (T &amp;x) &#123; T f=1; x=0; char ch=getchar(); for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getchar()); if (ch=='-')f=-1,ch=getchar(); for (; isdigit (ch); ch=getchar())x=x*10+ch-'0'; x*=f;&#125;struct node &#123; int v[N]; inline int&amp; operator [] (int x) &#123; return v[x]; &#125; inline void rd() &#123; read (v[1]); read (v[2]); read (v[3]); if (v[1]&gt;v[2]) swap (v[1],v[2]); if (v[2]&gt;v[3]) swap (v[2],v[3]); if (v[1]&gt;v[2]) swap (v[1],v[2]); &#125; bool operator == (const node &amp;t)const &#123; return v[1]==t.v[1] &amp;&amp; v[2]==t.v[2] &amp;&amp; v[3]==t.v[3]; &#125; void operator = (node t) &#123; v[1]=t[1]; v[2]=t[2]; v[3]=t[3]; &#125;&#125; a,b;int L,R,mid,cur,d1,d2,ans;node up (node x,int step) &#123; int k1,k2; if ((k1=x[2]-x[1])== (k2=x[3]-x[2])) return x; node ret=x; if (k1&gt;k2) &#123; int delta=min (step, (k1-1)/k2); step-=delta; cur+=delta; ret[2]=ret[2]-delta*k2; ret[3]-=delta*k2; &#125; else &#123; int delta=min (step, (k2-1)/k1); step-=delta; cur+=delta; ret[2]+=delta*k1; ret[1]+=delta*k1; &#125; return step?up (ret,step):ret;&#125;int main() &#123; freopen (FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); a.rd(); b.rd(); cur=0; node x=up (a,INF); d1=cur; cur=0; node y=up (b,INF); d2=cur; if (x==y) &#123; puts (\"YES\"); if (d1&lt;d2) swap (d1,d2),swap (a.v[1],b.v[1]),swap (a.v[2],b.v[2]),swap (a.v[3],b.v[3]); a=up (a,d1-d2); L=0; R=d2; ans+=d1-d2; while (L&lt;=R) &#123; mid= (L+R)&gt;&gt;1; if (up (a,mid)==up (b,mid)) R=mid-1; else L=mid+1; &#125; printf (\"%d\",ans+ (L&lt;&lt;1)); &#125; else puts (\"NO\"); return 0;&#125;","categories":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://buzhibujue.cf/categories/BZOJ/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://buzhibujue.cf/tags/思维/"},{"name":"二分","slug":"二分","permalink":"https://buzhibujue.cf/tags/二分/"}]},{"title":"杜教筛与莫比乌斯反演","slug":"杜教筛与莫比乌斯反演","date":"2018-10-13T14:51:13.000Z","updated":"2020-05-03T15:35:56.000Z","comments":true,"path":"2018/10/13/杜教筛与莫比乌斯反演/","link":"","permalink":"https://buzhibujue.cf/2018/10/13/杜教筛与莫比乌斯反演/","excerpt":"","text":"首先是杜教筛套路式子 求\\sum_{x=1}^n f(x)其中n很大一般$10^9 \\sim 2^{32}​$ 左右导致常规线性筛超时 一般做法： 令S(x)=\\sum_{i=1}^{x}f(i)\\\\再找一和$f$卷积起来有特殊性质的函数$g(x)$ \\begin{align} \\sum_{i=1}^{n}f*g(i) &=\\sum_{i=1}^{n}\\sum_{d|i}g(d)*f(\\frac{i}{d})\\\\ &=\\sum_{d=1}^{n}g(d)*\\sum_{d|i}f(\\frac{i}{d})\\\\ &=\\sum_{d=1}^{n}g(d)*\\sum_{i=1}^{n/d}f(i)\\\\ &=\\sum_{d=1}^{n}g(d)*S(\\frac{n}{d}) \\\\ &=\\sum_{d=2}^{n}g(d)*S(\\frac{n}{d})+g(1)*S(n) \\end{align}然后就发现右边等式最后一项除以$g(1)$是要求的答案 而 $\\displaystyle\\sum_{d=2}^{n}g(d)*S(\\frac{n}{d}) $ 这玩意可以递归下去 $\\displaystyle\\sum_{i=1}^n f*g(i)$ 一般会在我们的选择下比较好算 先是一道模板题 BZOJ3944 Description给定一个正整数N(N&lt;=$2^{31}-1$)求$ans1=\\displaystyle\\sum_{i=1}^{n} \\phi(i) \\quad\\ ans2= \\displaystyle\\sum_{i=1}^n \\mu(i) $ Input一共$T+1$行第$1$行为数据组数$T(T&lt;=10)$第$2~T+1$行每行一个非负整数N，代表一组询问 Output一共T行，每行两个用空格分隔的数ans1,ans2 对于这道题可以知道 \\begin{align} (\\mu * 1)&=[x=1] \\\\ \\phi*1&=x \\\\ 令g(x)&=1 \\\\ 对于 \\mu\\\\ \\sum_{i=1}^{n}f*g(i)&=1\\\\ 所以S(n)&=1-\\sum_{d=2}^{n}S(n/d)\\\\ 对于\\phi \\\\ \\sum_{i=1}^{n}f*g(i)&=1+2+\\dots+n=\\frac{n(n+1)}{2}\\\\ 所以S(n)&=\\frac{n(n+1)}{2}-\\sum_{d=2}^{n}S(n/d) \\end{align}具体实现我就使用map了=.= Code12345678910inline ll solve(int opt,unsigned x)&#123; if (x&lt;MAXN) return opt?sum1[x]:sum0[x]; if (M[opt][x]) return M[opt][x]; ll ret=opt?1ll:1ll*x*(x+1)&gt;&gt;1; for (unsigned i=2,j=2;i&lt;=x;i=j+1)&#123; j=x/(x/i); ret-=solve(opt,x/i)*(j-i+1); &#125; return M[opt][x]=ret;&#125; 傻逼题讲完了T.T BZOJ3930 Description我们知道，从区间[L,H]（L和H为整数）中选取N个整数，总共有$(H-L+1)^N$种方案。小z很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的N个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小z会告诉你一个整数K，你需要回答他最大公约数刚好为K的选取方案有多少个。由于方案数较大，你只需要输出其除以1000000007的余数即可。 Input输入一行，包含4个空格分开的正整数，依次为N，K，L和H。 Output输出一个整数，为所求方案数。 Sample Input12 2 2 4 Sample Output13 HINT样例解释所有可能的选择方案：(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (4, 4)其中最大公约数等于2的只有3组：(2, 2), (2, 4), (4, 2)对于100%的数据，$1≤N,K≤10^9，1≤L≤H≤10^9，H-L≤10^5$ 一看这数据范围就懵逼了=.= 先$L,R都除以K$就变成求区间$gcd=1$的方案了 然后看上去要杜教筛不过$R-L&lt;=10^5​$可以枚举选的N个数的$ gcd​$ 一堆差不超过$10^5 $的数的$gcd$也在$10^5$以内（易证） 令f(x)表示gcd恰好为x的方案数 \\\\ g(x)表示gcd是x的倍数的方案数 可以O(1)求\\\\ \\begin{align} 然后g(x)&=\\sum_{x|d}f(d) \\\\ 通过反演模板 f(x)&=\\sum_{x|d}\\mu(d)f(x/d)\\\\ 得f(1)&=\\sum_{i=1}\\mu(i)g(i) \\end{align}$g(x)$ 怎么求？ 区间任选$N$个数使得都是一个数$x$的倍数=.=快速幂搞搞 并且选的这$N$个数不能全部一样 所以选的方案要减去这个区间的数的个数（刚好这么多种所有数都一样的方案） 还有个特判为区间是否包含1，包含$1的话有1种全部都是1$时的$gcd为1$ Code123456789101112inline int getf(int x)&#123; int lt=(L%x)?L/x+1:L/x,rt=R/x; return add(qpow(rt-lt+1,N),-rt+lt-1);&#125;int main()&#123; pre(); read(N);read(K);read(L);read(R); L=L%K?L/K+1:L/K;R/=K;n=R-L; for (int i=1;i&lt;=n;i++) ans=add(ans,mul(mu[i],getf(i))); if (L&lt;=1 &amp;&amp; 1&lt;=R) ans=add(ans,1);&#125; BZOJ3529 Description有一张$ n×m$ 的数表，其第 $i$ 行第$ j$ 列$（1 &lt;= i &lt;= n, 1 &lt;= j &lt;= m）$的数值为能同时整除 $i$ 和$ j$ 的所有自然数之和。给定$ a$ , 计算数表中不大于$ a$ 的数之和。 Input输入包含多组数据。输入的第一行一个整数$Q$表示测试点内的数据组数接下来$Q$行，每行三个整数$n，m，a(|a| &lt; =10^9)$描述一组数据。$1 &lt; =N．m &lt; =10^5 ， 1 &lt; =Q &lt; =2×10^4$ Output对每组数据，输出一行一个整数，表示答案模$2^31$的值。 Sample Input12324 4 310 10 5 Sample Output1220148 好像很难搞=.=不过1e5数据范围可以不用杜教筛 吼啊 写成数学符号就是 令F(x)=\\sum_{i|x}^{x}i\\\\ 求\\sum_{i=1}^{N}\\sum_{j=1}^{M}[F(gcd(i,j)","categories":[{"name":"总结","slug":"总结","permalink":"https://buzhibujue.cf/categories/总结/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://buzhibujue.cf/tags/数学/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://buzhibujue.cf/tags/莫比乌斯反演/"}]},{"title":"My first blog","slug":"my first blog","date":"2018-10-09T14:55:08.000Z","updated":"2020-05-03T15:35:26.000Z","comments":true,"path":"2018/10/09/my first blog/","link":"","permalink":"https://buzhibujue.cf/2018/10/09/my first blog/","excerpt":"","text":"新开的博客，日常鸽0.0","categories":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://buzhibujue.cf/tags/随笔/"}]}]}